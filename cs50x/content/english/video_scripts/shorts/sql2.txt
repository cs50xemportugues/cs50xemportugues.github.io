Just like in C, every column of our SQL table is capable of holding data of different data types. So in C, for example, we had characters and strings and integers and floats. And SQL has a few more data types than that. This is just 20 of them, and this is not even an exhaustive list. But some of these things should look familiar. So, for example, we have int, which can store integers. But we also have these four other types, which can hold integers with different upper bounds. So you may recall from C that the upper bound of integer is 2 to the 31st power, or 2 to the 32nd power if they're unsigned integers. But here we can say small ints or tiny ints or medium or big ints, each of which have different upper bounds on the values. Decimal and float stand in place of double and float, which we're familiar with from C. We can also store date and time stamps in SQL databases. There's no data type for that that's native to C. But in SQL, there are a couple of different ways to do this. We can even do more exotic things like store geometry or line strings.

And what are these? Well, geometry and line strings can be used to store in a SQL database a mapping out or a drawing out of an area on a map, such as using GIS data. And we can actually store that in our SQL table and recreate that exact drawing a little bit later on. Text sort of stands in the stead of strings for just arbitrarily large chunks of text. Enums are also a type that exists in C, but we don't talk about them too much in C. But really quickly, what an enum is is it is a column of your table that can be used to store a limited set of values. So, for example, I could have an enum that is called, like, favorite colors, for example. And I could specify when I'm building my table that it can only be capable of holding red, green, and blue. If you tried to insert a row that had purple in that place, that wouldn't work because it is not one of the enumerated values that can be stored in that column. There are also char and varchar. And these are not quite the same as what you might think they are in C. So let's just take a quick second to explain the difference between these two data types, which are pretty important. So unlike in C, char does not refer to a single character. It is actually sort of akin to our notion of a string, but with a caveat that that string is a fixed length. And typically when we specify a char or a varchar type, we have to specify the length of that string at the outset, just like we do in c. So, for example, my column type might be a char 10. That means that I can store 10 character strings in that column of my table, exactly 10 character strings.

So if I tried to store, for example, the word "hi," H-I, which is just two letters, that would go into the column OK. But it would also store 8 extra-- the equivalent of null bytes, basically, so that I still had 10 characters, per se, in that column for that row. And if I tried to store, like, a 15-character string, that wouldn't work. I'd only end up storing the first 10 letters. So it's always going to be 10, every time. A varchar, on the other hand, refers to a variable-length string. So if I said that my column was varchar 99, I can store 1, 2, 3, 4, 5 character strings, up to 99 characters long, without having to have all of this extra sort of slack space or null bytes or zeros tacked onto the end. So char, fixed-length strings. Varchar, variable-length strings. We won't get into the difference between why you might want to use one or the other. But there are reasons why you might not always want to use a varchar, and you might want to use a char in some situations. Now, SQLite actually has many or all of these same data types. But the difference there is that each of those data types is affiliated with what's called a type affinity to simplify things.

So that whole list of 20-- or more, really-- can be reduced to one of these five different affinities-- null, integer, real, text, and blob. Null is probably pretty obvious-- nothing. Integer-- whole numbers. Real-- that would include things like decimal and float. Text would include things like char and varchar. Blob is just-- that would be more like the geometry or data that isn't really text, but it's just a large number of bits or bytes. That would be a blob. And everything can reduce to one of these five different type affinities. So after specifying the columns, it's also really important in our SQL table to have one other consideration, which is to have one column which is our primary key. Why do we need a primary key? The reason is every row of our table, in order to make our SQL queries most effective, should be able to be uniquely and quickly identified. So choosing the right primary key will allow us to make sure that there is one value in every row that is completely unique. And if that is true, if there is one column in every row that's unique, then we can uniquely identify or very quickly identify which row we're talking about. Now, it's also possible to establish a joint primary key, which is just a combination of, say, two columns-- but it can be an arbitrarily large number of columns-- that is always guaranteed to be unique. So I could have one column that could always have A's or B's or C's. I could have another column that has ones and twos and threes and fours. I could have multiple A's and multiple B's and multiple C's, multiple ones, twos, and threes. But across all of those rows, I'm only ever allowed to have 1 combination of A1. I can have B1, C1. I can have A2, A3, A4. But there's only ever one combination of those two columns that is unique. That would also be acceptable because that is a joint primary key.