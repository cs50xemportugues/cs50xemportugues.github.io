So what is a pointer? A pointer is a data item whose value is a memory address. That was that zero x eight zero stuff going on, that was a memory address. That was a location in memory. And the type of a pointer describes the kind of data you'll find at that memory address. So there's the int star part right. If I follow that arrow, it's going to lead me to a location. And that location, what I will find there in my example, is a green colored box. It's an integer, that's what I will find if I go to that address. The data type of a pointer describes what you will find at that memory address. So here's the really cool thing though. Pointers allow us to pass variables between functions. And actually pass variables and not pass copies of them. Because if we know exactly where in memory to find a variable, we don't need to make a copy of it, we can just go to that location and work with that variable. So in essence pointers sort of make a computer environment a lot more like the real world, right. 

So here's an analogy. Let's say that I have a notebook, right, and it's full of notes. And I would like you to update it. You are a function that updates notes, right. In the way we've been working so far, what happens is you will take my notebook, you'll go to the copy store, you'll make a Xerox copy of every page of the notebook. You'll leave my notebook back on my desk when you're done, you'll go and cross out things in my notebook that are out of date or wrong, and then you'll pass back to me the stack of Xerox pages that is a replica of my notebook with the changes that you've made to it. And at that point, it's up to me as the calling function, as the caller, to decide to take your notes and integrate them back into my notebook. So there's a lot of steps involved here, right. Like wouldn't it be better if I just say, hey, can you update my notebook for me, hand you my notebook, and you take things and literally cross them out and update my notes in my notebook. And then give me my notebook back. That's kind of what pointers allow us to do, they make this environment a lot more like how we operate in reality. 

All right so that's what a pointer is, let's talk about how pointers work in C, and how we can start to work with them. So there's a very simple pointer in C called the null pointer. The null pointer points to nothing. This probably seems like it's actually not a very useful thing, but as we'll see a little later on, the fact that this null pointer exists actually really can come in handy. And whenever you create a pointer, and you don't set its value immediately- an example of setting its value immediately will be a couple slides back where I said pk equals & k, pk gets k's address, as we'll see what that means, we'll see how to code that shortly- if we don't set its value to something meaningful immediately, you should always set your pointer to point to null. You should set it to point to nothing. 

That's very different than just leaving the value as it is and then declaring a pointer and just assuming it's null because that's rarely true. So you should always set the value of a pointer to null if you don't set its value to something meaningful immediately. You can check whether a pointer's value is null using the equality operator (==), just like you compare any integer values or character values using (==) as well. It's a special sort of constant value that you can use to test. So that was a very simple pointer, the null pointer. Another way to create a pointer is to extract the address of a variable you've already created, and you do this using the & operator address extraction. Which we've already seen previously in the first diagram example I showed. So if x is a variable that we've already created of type integer, then &x is a pointer to an integer. &x is- remember, & is going to extract the address of the thing on the right. And since a pointer is just an address, than &x is a pointer to an integer whose value is where in memory x lives. It's x's address. So &x is the address of x. Let's take this one step further and connect to something I alluded to in a prior video. If arr is an array of doubles, then &arr square bracket i is a pointer to a double. OK. arr square bracket i, if arr is an array of doubles, then arr square bracket i is the i-th element of that array, and &arr square bracket i is where in memory the i-th element of arr exists. 

So what's the implication here? An arrays name, the implication of this whole thing, is that an array's name is actually itself a pointer. You've been working with pointers all along every time that you've used an array. Remember from the example on variable scope, near the end of the video I present an example where we have a function called set int and a function called set array. And your challenge to determine whether or not, or what the values that we printed out the end of the function, at the end of the main program. 

If you recall from that example or if you've watched the video, you know that when you- the call to set int effectively does nothing. But the call to set array does. And I sort of glossed over why that was the case at the time. I just said, well it's an array, it's special, you know, there's a reason. The reason is that an array's name is really just a pointer, and there's this special square bracket syntax that make things a lot nicer to work with. And they make the idea of a pointer a lot less intimidating, and that's why they're sort of presented in that way. But really arrays are just pointers. And that's why when we made a change to the array, when we passed an array as a parameter to a function or as an argument to a function, the contents of the array actually changed in both the callee and in the caller. Which for every other kind of variable we saw was not the case. So that's just something to keep in mind when you're working with pointers, is that the name of an array actually a pointer to the first element of that array. 

OK so now we have all these facts, let's keep going, right. Why do we care about where something lives. Well like I said, it's pretty useful to know where something lives so you can go there and change it. Work with it and actually have the thing that you want to do to that variable take effect, and not take effect on some copy of it. This is called dereferencing. We go to the reference and we change the value there. So if we have a pointer and it's called pc, and it points to a character, then we can say *pc and *pc is the name of what we'll find if we go to the address pc. What we'll find there is a character and *pc is how we refer to the data at that location. So we could say something like *pc=D or something like that, and that means that whatever was at memory address pc, whatever character was previously there, is now D, if we say *pc=D. 

So here we go again with some weird C stuff, right. So we've seen * previously as being somehow part of the data type, and now it's being used in a slightly different context to access the data at a location. I know it's a little confusing and that's actually part of this whole like, why pointers have this mythology around them as being so complex, is kind of a syntax problem, honestly. But * is used in both contexts, both as part of the type name, and we'll see a little later something else, too. And right now is the dereference operator. So it goes to the reference, it accesses the data at the location of the pointer, and allows you to manipulate it at will. 

Now this is very similar to visiting your neighbor, right. If you know what your neighbor lives, you're not hanging out with your neighbor. You know you happen to know where they live, but that doesn't mean that by virtue of having that knowledge you are interacting with them. If you want to interact with them, you have to go to their house, you have to go to where they live. And once you do that, then you can interact with them just like you'd want to. And similarly with variables, you need to go to their address if you want to interact them, you can't just know the address. And the way you go to the address is to use *, the dereference operator.


