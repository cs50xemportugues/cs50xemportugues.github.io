All right, so let's talk about command-line arguments. So, so far in the course pretty much all of your programs have probably started like this-- int main void. We've been collecting user input if we need it in our programs, such as the Mario program, for example, by in-program prompts. We haven't needed to modify the declaration of main, because instead inside of main we just say, you may call it to get int. How large do you want the pyramid to be? Or you may call it to get float-- how much change should I output to the user? 

There is another way though, and if we want our users to be able to provide data to our program at runtime instead of while the program is running, a subtle distinction but sometimes a very useful one, we need a new form of declaring main. We can't use int main void if we want to collect other data at the command-line when the user runs the program, hence command-line arguments. 

To collect these command-line arguments from the user, change your declaration of main to look like this-- int main, open paren, int argc, comma, string argv, square brackets, and then open curly brace. So what does that mean already? Well, we are passing in two parameters, or arguments, or inputs to main. One, an integer called argc, and the other is what? It's an array of strings, right? We see that square bracket notation. It's an array of strings. It's not an individual string, it's an array of strings. And these two arguments, argc and argv, enable you to know what data the user has provided at the command-line and how many things they provided at the command-line. Pretty useful things to work with. 

Argc stands for argument count, and you should know, by the way, that you could call argc whatever you want it. You can call argv whatever you wanted. These are just conventional names that we use for them-- argument count, and as we'll see in a second, argument vector, argv. But you don't have to call them argc and argv if you don't want to, but conventionally, that's what we do. 

So anyway, argc, the argument count. It's an integer-type variable and so, as you might expect, if we have two things that we're going to be finding out what these are typed and how much stuff the user typed, argc is going to tell us how much stuff the user typed. So it gives you a number of command-line arguments user typed when the program was executed. So if your program is run dot slash greedy, and inside of your greedy program your main function has the declaration int main int argc, string argv square brackets, then argc in that case is one. Now notice we don't count how many things the user typed after the program name. The program name itself counts as a command-line argument. 

So dot slash greedy, in that case, argc is one. If the user typed slash greedy 1024 CS50 at the command-line, argc in that case would be three. And we know this because the way that the division between the strings is detected is whether there is a space, or a tab, or something like that between them. So any amount of white space, so-called, between the values typed command-line indicates how many there are. So dot slash greedy space 1024 space CS50, argc, in that case, is three. 

Argv is the argument vector. Vector, by the way, is just another word for an array, and this is an array that stores strings. One string per element, which is the strings that the user actually typed at the command-line when the program was executed. Now, as is the case with any array, if you recall from our discussion of arrays, the first element of argv is always going to be found at argv square bracket zero. That's the first index of the argv array. So that will-- and in fact, that will always be the name of the program, will always be located at argv square bracket zero. 

The last element of argv is always found at argv square brackets argc minus one. Do you see why? Remember how many elements exist in this array. Well, we know that-- it's argc number of elements. If the user typed three things at the command-line, argc is three. But because in c, when we're working with arrays, each element of the array, or rather the indices of the array, start at zero. If we have three elements in our array, we have an element at argv zero, an element at argv one, and an element at argv two. There is no element at argv three, and an array of size three. So that's why the last element of argv can always be found at argv square brackets argc minus one. 

So let's assume the user executes the greedy program as follows-- if they type in the command-line dot slash greedy space 1024 space CS50, and for whatever reason we've already prepared our greedy program to know and work with these command-line arguments. We didn't previously when we worked on it for the greedy problem, but let's say we've now modified it so that we do process the command-line arguments in some way. In this case, argv zero is dot slash greedy. What's argv one? Well, it's 1024, right? It is 1024, but here's a really important distinction-- do you remember the data type of argv? 

It stores strings, right? But it looks like 1024 is an integer value. This is a really important distinction, and is actually going to become something that you might encounter in later problems. Everything in argv is stored as a string. So argv one's contents are the string one, zero, two, four, consisting of those four characters. It's as if the user typed one, zero, two, four as individual letters or characters. It is not the integer 1024, and so you can't directly work with it by saying int 1,000, or rather int x equals argv one minus 24. 

Intuitively, you might think of that as, OK, well it's 1,024 minus 24, so x is equal to 1,000. But in fact, that's not the case, because argv one is a string. The string 1024. Now there is a function that can be used to convert strings to integers. I won't spoil it for you now, but I'm sure Zamyla will be happy to tell you about it in the walkthrough for a future problem. But you can also find problems like-- excuse me, functions that would do this in reference 50, if you go to the reference guide you can find a function that will make this conversion for you. But again, in the walkthrough for a future problem, Zamyla will be happy to tell you what function it is that will convert the string 1024 to the integer 1024. 

All right, so moving on. We've covered our argv zero, we've covered argv one. What's in argv two? CS50. That one's probably pretty self-explanatory. What's in argv three? Well again, we don't really know, right? We have an array of size three, that's how many elements the user typed at the command-line, so if we go to argv three, we're now overstepping the bounds of our array. The compiler will let us do this, there's no intuitive problem with it, but in terms of actually what's going to happen, we don't really know. It depends on what is located at the memory where argv three would be expected to be. And so we could end up getting away scot free. More likely than not, particularly when you're working with argv as opposed to any other array that's in our program, we're probably going to suffer a segmentation fault. So again, be sure not to overstep the bounds of your arrays, particularly argv, given its high degree of importance in your programs. 

I'm Doug Lloyd. This is CS50. 