What do you think happens if we try and dereference a pointer whose value is null? Recall that the null pointer points to nothing. So if you try and dereference nothing or go to an address nothing, what do you think happens? Well if you guessed segmentation fault, you'd be right. If you try and dereference a null pointer, you suffer a segmentation fault. But wait, didn't I tell you, that if you're not going to set your value of your pointer to something meaningful, you should set to null? I did and actually the segmentation fault is kind of a good behavior. 

Have you ever declared a variable and not assigned its value immediately? So you just say int x; you don't actually assign it to anything and then later on in your code, you print out the value of x, having still not assigned it to anything. Frequently you'll get zero, but sometimes you might get some random number, and you have no idea where it came from. Similarly can things happen with pointers. When you declare a pointer int*pk for example, and you don't assign it to a value, you get four bytes for memory. Whatever four bytes of memory the system can find that have some meaningful value. And there might have been something already there that is no longer needed by another function, so you just have whatever data was there. 

What if you tried to do dereference some address that you don't- there were already bytes and information in there, that's now in your pointer. If you try and dereference that pointer, you might be messing with some memory that you didn't intend to mess with it all. And in fact you could do something really devastating, like break another program, or break another function, or do something malicious that you didn't intend to do at all. And so that's why it's actually a good idea to set your pointers to null if you don't set them to something meaningful. It's probably better at the end of the day for your program to crash then for it to do something that screws up another program or another function. That behavior is probably even less ideal than just crashing. And so that's why it's actually a good habit to get into to set your pointers to null if you don't set them to a meaningful value immediately, a value that you know and that you can safely the dereference. 

So let's come back now and take a look at the overall syntax of the situation. If I say int *p;, what have I just done? What I've done is this. I know the value of p is an address because all pointers are just addresses. I can dereference p using the * operator. In this context here, at the very top recall the * is part of the type. Int * is the data type. But I can dereference p using the * operator, and if I do so, if I go to that address, what will I find at that address? I will find an integer. So int*p is basically saying, p is an address. I can dereference p and if I do, I will find an integer at that memory location. 

OK so I said there was another annoying thing with stars and here's where that annoying thing with stars is. Have you ever tried to declare multiple variables of the same type on the same line of code? So for a second, pretend that the line, the code I actually have there in green isn't there and it just says int x,y,z;. What that would do is actually create three integer variables for you, one called x, one called y, and one called z. It's a way to do it without having to split onto three lines. 

Here's where stars get annoying again though, because the * is actually part of both the type name and part of the variable name. And so if I say int *px,py,pz, what I actually get is a pointer to an integer called px and two integers, py and pz. And that's probably not what we want, that's not good. 

So if I want to create multiple pointers on the same line, of the same type, and stars, what I actually need to do is say int *pa,*pb,*pc. Now having just said that and now telling you this, you probably will never do this. And it's probably a good thing honestly, because you might inadvertently omit a star, something like that. It's probably best to maybe declare pointers on individual lines, but it's just another one of those annoying syntax things with stars that make pointers so difficult to work with. Because it's just this syntactic mess you have to work through. With practice it does really become second nature. I still make mistakes with it still after programming for 10 years, so don't be upset if something happens to you, it's pretty common honestly. It's really kind of a flaw of the syntax. 

OK so I kind of promised that we would revisit the concept of how large is a string. Well if I told you that a string, we've really kind of been lying to you the whole time. There's no data type called string, and in fact I mentioned this in one of our earliest videos on data types, that string was a data type that was created for you in CS50.h. You have to #include CS50.h in order to use it. 

Well string is really just an alias for something called the char *, a pointer to a character. Well pointers, recall, are just addresses. So what is the size in bytes of a string? Well it's four or eight. And the reason I say four or eight is because it actually depends on the system, If you're using CS50 ide, char * is the size of a char * is eight, it's a 64-bit system. Every address in memory is 64 bits long. If you're using CS50 appliance or using any 32-bit machine, and you've heard that term 32-bit machine, what is a 32-bit machine? Well it just means that every address in memory is 32 bits long. And so 32 bits is four bytes. So a char * is four or eight bytes depending on your system. And indeed any data types, and a pointer to any data type, since all pointers are just addresses, are four or eight bytes. So let's revisit this diagram and let's conclude this video with a little exercise here. So here's the diagram we left off with at the very beginning of the video. So what happens now if I say *pk=35? So what does it mean when I say, *pk=35? Take a second. *pk. In context here, * is dereference operator. So when the dereference operator is used, we go to the address pointed to by pk, and we change what we find. So *pk=35 effectively does this to the picture. So it's basically syntactically identical to of having said k=35. 

One more. If I say int m, I create a new variable called m. A new box, it's a green box because it's going to hold an integer, and it's labeled m. If I say m=4, I put an integer into that box. If say pk=&m, how does this diagram change? Pk=&m, do you recall what the & operator does or is called? Remember that & some variable name is the address of a variable name. So what we're saying is pk gets the address of m. And so effectively what happens the diagram is that pk no longer points to k, but points to m. 

Again pointers are very tricky to work with and they take a lot of practice, but because of their ability to allow you to pass data between functions and actually have those changes take effect, getting your head around is really important. It probably is the most complicated topic we discuss in CS50, but the value that you get from using pointers far outweighs the complications that come from learning them. So I wish you the best of luck learning about pointers. I'm Doug Lloyd, this is CS50. 