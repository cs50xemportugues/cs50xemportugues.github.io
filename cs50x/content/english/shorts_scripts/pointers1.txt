Pointers, here we are. This is probably going to be the most difficult topic that we talk about in CS50. And if you've read anything about pointers before you might be a little bit intimidating going into this video. It's true the pointers do allow you the ability to perhaps screw up pretty badly when you're working with variables, and data, and causing your program to crash. But they're actually really useful and they allow us a really great way to pass data back and forth between functions, that we're otherwise unable to do. 

And so what we really want to do here is train you to have good pointer discipline, so that you can use pointers effectively to make your programs that much better. As I said pointers give us a different way to pass data between functions. Now if you recall from an earlier video, when we were talking about variable scope, I mentioned that all the data that we pass between functions in C is passed by value. And I may not have used that term, what I meant there was that we are passing copies of data. When we pass a variable to a function, we're not actually passing the variable to the function, right? We're passing a copy of that data to the function. The function does what it will and it calculates some value, and maybe we use that value when it gives it back. 

There was one exception to this rule of passing by value, and we'll come back to what that is a little later on in this video. If we use pointers instead of using variables, or instead of using the variables themselves or copies of the variables, we can now pass the variables around between functions in a different way. This means that if we make a change in one function, that change will actually take effect in a different function. Again, this is something that we couldn't do previously, and if you've ever tried to swap the value of two variables in a function, you've noticed this problem sort of creeping up, right? 

If we want to swap X and Y, and we pass them to a function called swap, inside of the function swap the variables do exchange values. One becomes two, two becomes one, but we don't actually change anything in the original function, in the caller. Because we can't, we're only working with copies of them. With pointers though, we can actually pass X and Y to a function. That function can do something with them. And those variables values can actually change. So that's quite a change in our ability to work with data. 

Before we dive into pointers, I think it's worth taking a few minutes to go back to basics here. And have a look at how computer memory works because these two subjects are going to actually be pretty interrelated. As you probably know, on your computer system you have a hard drive or perhaps a solid state drive, some sort of file storage location. It's usually somewhere in the neighborhood of 250 gigabytes to maybe a couple of terabytes now. And it's where all of your files ultimately live, even when your computer is shut off, you can turn it back on and you'll find your files are there again when you reboot your system. But disk drives, like a hard disk drive, an HDD, or a solid state drive, an SSD, are just storage space. 

We can't actually do anything with the data that is in hard disk, or in a solid state drive. In order to actually change data or move it around, we have to move it to RAM, random access memory. Now RAM, you have a lot less of in your computer. You may have somewhere in the neighborhood of 512 megabytes if you have an older computer, to maybe two, four, eight, 16, possibly even a little more, gigabytes of RAM. So that's much smaller, but that's where all of the volatile data exists. That's where we can change things. But when we turn our computer off, all of the data in RAM is destroyed. 

So that's why we need to have hard disk for the more permanent location of it, so that it exists- it would be really bad if every time we turned our computer off, every file in our system was obliterated. So we work inside of RAM. And every time we're talking about memory, pretty much, in CS50, we're talking about RAM, not hard disk. 

So when we move things into memory, it takes up a certain amount of space. All of the data types that we've been working with take up different amounts of space in RAM. So every time you create an integer variable, four bytes of memory are set aside in RAM so you can work with that integer. You can declare the integer, change it, assign it to a value 10 incremented by one, so on and so on. All that needs to happen in RAM, and you get four bytes to work with for every integer that you create. 

Every character you create gets one byte. That's just how much space is needed to store a character. Every float, a real number, gets four bytes unless it's a double precision floating point number, which allows you to have more precise or more digits after the decimal point without losing precision, which take up eight bytes of memory. Long longs, really big integers, also take up eight bytes of memory. How many bytes of memory do strings take up? Well let's put a pin in that question for now, but we'll come back to it. 
