Hi, so let's talk about operators in C. So, we've already seen one, in fact, equals the assignment operator. It allows us to just put a value into a variable. That's the assignment operator, single equal sign. In order to manipulate and work with values and variables in C, we have a number of operators at our disposal that we can use. Let's take a look at some of the common ones starting with arithmetic operators. As you might expect, we can do pretty basic math operations in C. We can add, subtract, multiply, and divide numbers using plus, minus, star, and slash, respectively. Here's a couple of lines of code in which we do that. So, we have int x equals y plus 1. Let's assume that somewhere up above this line of code we had said int y equals 10. What's the value of x after I execute this first line of code? Did you say 11? You'd right. Why is that? Well, y was 10. Some I'm saying int x equals 10 plus 1. 10 plus 1 is 11. So, the value 11 gets stored in the variable x. Not too bad, right? 

How about this next line of code? x equals x times 5. Well, before we executed this line of code, x was 11. So, what is the value of x after this line of code? Take a second. So, x equals x times 5. x was 11. So, x equals 11 times 5. Or 55. So if you said 55, you'd be right. 

Now, it may be a little confusing, but with the way that assignment works in C is the value on the right gets assigned to the value on the left. So, first we evaluate x times 5. So, 11 times 5 is 55. And then we store that value in x. The 11 that was there before is now overwritten. So x's value is now 55. Hopefully that's fairly straightforward. 

There's another operator that you've probably not necessarily heard called this, but you've certainly worked with in the past if you remember your days of long division way back in grade school. It's called the modulus operator. What modulus does is it gives you the remainder when you divide two numbers together. So, if I say 13 divided by 4, what's the remainder? And that value would be calculated by the modulus operator. 

So, I have a line of code here, int m equals 13 mod 4. And I say here in a comment that m's value is now 1. Why do I say that? Well, do the long division out in your head, if you bear with me for a second. So, I have 4 divided by 13. 4 goes into 13 three times with a remainder of 1. So, basically, all the modulus operator does is it tells you when you divide, you get the remainder. You might think that's actually not a terribly useful thing, but you'd be surprised, actually, by how frequently that modulus operator can come in handy. 

There's a couple of problems we'll do CS50 that deal with it. It's also good for doing things like random number. So, for example if you've ever heard of a random number generator, that's going to give you a number from 0 to some huge number. But maybe you only really need a number from 0 to 20. If you use the modulus operator on that giant number that gets generated by the random number generator, you're going to take whatever huge value it is, divide it by 20, and get the remainder. The remainder can only be a value from 0 to 19. So, you use modulus operator to take this huge number and whittle it down into something a little more meaningful. I'm pretty sure you'll be able to use both of those at some point in the future in CS50. 

So, C also gives us a way to apply an arithmetic operator to a single variable in a little more shorthand way. So, in the previous slide, we saw x equals x times 5. That worked. x times 5 then gets stored back in x. There's a shorter way to do it, thought, and it's the syntax x times equals 5. It's the same exact thing as saying x equals x times 5. It's just a slightly shorter way to do it. And when you see some distribution code or you see some sample code that does things like this, just be familiar with what the syntax means. You certainly don't have to use it, but if you do, it might make your code look a little slicker. And know that you can also use any of the different operators we've already seen before instead of times. You could say x plus equals 5, minus equals 5, times, divide, and mod. All of those work. 

There's also something that's so common in C that we've decided to refine that even further. Incrementing a variable by 1 or decrementing a variable by 1 is such a common thing-- especially when we talk about loops a little later on-- that we've decided instead of saying something like x plus equals 1, or x equals x plus 1, we've even short handed that to x plus plus. So, x equals x plus 1, x plus equals 1, and x plus plus all do the same thing. They all increment x by 1. But that incrementing and decrementing by 1 is so common that we have plus plus and minus minus that allow us to shorthand that even further. 

So, let's switch gears for second and talk about Boolean expressions. All which are also kind of fall into the overall category of operators. But Boolean expressions, unlike arithmetic operators, are used for comparing values. So, again, all Boolean expressions in C evaluate to one of two possible values, recall. True or false. That's the only two values that Boolean variable can take on. We can use the results of a Boolean expression in a lot of ways in programming. In fact, you'll be doing this quite a lot. 

For example, we might decide, well, if some condition is true, maybe I'll take this branch down my code. A conditional, so to speak. We'll learn about those soon too. Or maybe, as long as this is true, I want to keep doing this over and over and over. A loop. In both cases, know that we're using a Boolean expression, a true or false, to decide whether or not to take a particular path. Sometimes when we're working with Boolean expressions, we will use variables of type Bool. You might have declared a Bool typed variable, and you'll use in your Boolean expression. But you don't always have to do. As it turns out, in C, every non-0 value is the same as saying true. If you had declared a variable of type Boolean, and assigned it the value true, that's the same as declaring an integer and assigning it the value 1, 2, 3, or really any value whatsoever other than 0. Because in C, every non-0 value is true. 0, on the other hand, is false. This might come in handy later on to know, but just something to keep in mind. We don't always have to use Boolean type variables when we are working with Boolean expressions. 

There are two main types of Boolean expressions that we'll work with. Logical operators and relational operators. The language there is not terribly important. It's really just how I'm grouping them. And you'll certainly, I think, quickly realize what a relational operator is, based on what they are when we talk about them in a second. But don't worry about necessarily memorizing the term logical operator or relational operator. I'm just using it to group them in a logical way. 

So, let's take a look at the three logical operators that we'll see quite a bit in programming in CS50 and in programming more generally. Logical AND is true, if and only if both operands are true. Otherwise false. Where does that mean? So, let's say that I am at a point in my code where I have two variables, x and y. And I want to decide whether to do something in my code based on if x is true and y is true. I only want to do it if both of them are true, otherwise I don't want to go down that path because it's not going to help me. What I can say is if x & & y. That will be a logical Boolean expression comparing x and y and taking a certain path based on what their values are. So, if x is true and y is true based on this truth table here, only then will we go down that path. If x, & & y. It's only true-- the and is only true if x is true and y is true. If either one is false, as we see the truth table, then both x and y are not true. And so, x & & y is false. 

Logical OR is true if and only if at least one operand is true. Otherwise false. So logical AND required both x and y to be true. Logical OR requires x to be true or y to be true or both x and y to be true. So, again, we kind of find ourselves in a situation where we're going to our code, and we reached a fork in the road. And we want to go down a particular path if x is true or y is true, but not necessarily if both are true. But possibly if both are true. So if x is true and y is true, we'll go down that path. x is true. One of them is true, right? If x is true and y is true. If x is true, and y is false, one of them is still true. So, x or y is still true. If x is false, and y is true, one of them is still true, right? y is true, in this case. So, it's true that x or y is true. Only if x is false and y is false do we not go down that path, because neither x nor y is true. Now, if you're looking at the screen right now and wondering what that symbol is for logical OR, it's called the vertical bar. And if you looking at your keyboard for a minute, as I'm doing now, it's usually just above the Enter key, on most keyboards, on the same key as the backslash. It's also usually right next to the square brackets. So, it might be a key that you haven't typed very much in the past. But, if you're ever doing logical comparisons, as we'll be doing a lot in the course, it's going to be useful to find that key and use it. So, it's usually on the same key as backslash just above Enter. 

The final logical operator is NOT. And NOT's pretty straightforward. It inverts the value of its operand. If x is true, then not x is false. If x is false, then not x is true. Sometimes you'll hear this symbol pronounced as bang or exclamation or not. It's pretty much all the same thing. In case you hear that spoken and you're not sure what that means, it's just the exclamation point, but sometimes it's called a couple different things. All right, so that takes care of logical operators. So, let's talk about relational operators. Again, if you're familiar with this arithmetic back in grade school, you're probably familiar with how these work already. These behave exactly as you'd expect. So less than it's true, in this example, if x is less than y. So, if x is 4 and y is 6, x is less than y. That's true. Less than or equal to works pretty similarly. If x is 4, and y is 4, then x is less than or equal to y. Greater than. x is greater than y. And greater than or equal to, x is greater than or equal to y. If it's true, then you'll pass that expression, and you'll go down that path on the road. If you have an if x is greater than y, and x is, in fact, is greater than y, you'll do whatever is subject to that condition. 

Notice that we don't have a single character for less than or equal to, as you might be familiar with from math textbooks. So, we have the less than symbol, followed by an equal sign. That's how we represent less than or equal to. And similarly, do we do that for greater than or equal to. 

The final two relational operators that are important are testing for equality and inequality. So, if x equals equals y, is true if x and y's value is the same. If x is 10, and y is 10, then x equals equals y is true. If x is 10 and y is 11, x equals equals y is not true. We can also test for inequality using exclamation point or bang or NOT, again. If x is not equal to y, if that's the test we're using here, we'd be good to go. So, if x is not equal to y, we'll go down that path. 

Be really careful here. It's a really common mistake-- and one I certainly made quite a lot when I was getting started-- to accidentally mistake the assignment operator, single equals, for the equality comparison operator, double equals. It'll lead to some weird behavior in your code, and usually the compiler will warn you about it when you try and compile your code, but sometimes you might be able to sneak it by. It's not necessarily a good thing that you sneak it by, though. Just so if you are doing an inequality test, if you're checking whether two different variables have the same value inside of them, make sure to use equals equals, and not single equals. And that way your program will have the behavior you intend. I'm Doug Lloyd and this is CS50. 