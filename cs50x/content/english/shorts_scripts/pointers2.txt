So back to this idea of memory as a big array of byte-sized cells. That's really all it is, it's just a huge array of cells, just like any other array that you're familiar with and see, except every element is one byte wide. And just like an array, every element has an address. Every element of an array has an index, and we can use that index to do so-called random access on the array. We don't have to start at the beginning of the array, iterate through every single element thereof, to find what we're looking for. We can just say, I want to get to the 15th element or the 100th element. And you can just pass in that number and get the value you're looking for. 

Similarly every location in memory has an address. So your memory might look something like this. Here's a very small chunk of memory, this is 20 bytes of memory. The first 20 bytes because my addresses there at the bottom are 0, 1, 2, 3, and so on all the way up to 19. And when I declare variables and when I start to work with them, the system is going to set aside some space for me in this memory to work with my variables. So I might say, char c equals capital H. And what's going to happen? Well the system is going to set aside for me one byte. In this case it chose byte number four, the byte at address four, and it's going to store the letter capital H in there for me. If I then say int speed limit equals 65, it's going to set aside four bytes of memory for me. And it's going to treat those four bytes as a single unit because what we're working with is an integer here. And it's going to store 65 in there. 

Now already I'm kind of telling you a bit of a lie, right, because we know that computers work in binary. They don't understand necessarily what a capital H is or what a 65 is, they only understand binary, zeros and ones. And so actually what we're storing in there is not the letter H and the number 65, but rather the binary representations thereof, which look a little something like this. And in particular in the context of the integer variable, it's not going to just spit it into, it's not going to treat it as one four byte chunk necessarily, it's actually going to treat it as four one byte chunks, which might look something like this. And even this isn't entirely true either, because of something called an endianness, which we're not going to get into now, but if you're curious about, you can read up on little and big endianness. But for the sake of this argument, for the sake of this video, let's just assume that is, in fact, how the number 65 would be represented in memory on every system, although it's not entirely true. 

But let's actually just get rid of all binary entirely, and just think about as H and 65, it's a lot easier to think about it like that as a human being. All right, so it also seems maybe a little random that I've- my system didn't give me bytes 5, 6, 7, and 8 to store the integer. There's a reason for that, too, which we won't get into right now, but suffice it to say that what the computer is doing here is probably a good move on its part. To not give me memory that's necessarily back to back. Although it's going to do it now if I want to get another string, called surname, and I want to put Lloyd in there. I'm going to need to fit one character, each letter of that's going to require one character, one byte of memory. So if I could put Lloyd into my array like this I'm pretty good to go, right? What's missing? 

Remember that every string we work with in C ends with backslash zero, and we can't omit that here, either. We need to set aside one byte of memory to hold that so we know when our string has ended. So again this arrangement of the way things appear in memory might be a little random, but it actually is how most systems are designed. To line them up on multiples of four, for reasons again that we don't need to get into right now. But this, so suffice it to say that after these three lines of code, this is what memory might look like. If I need memory locations 4, 8, and 12 to hold my data, this is what my memory might look like. 

And just be particularly pedantic here, when we're talking about memory addresses we usually do so using hexadecimal notations. So why don't we convert all of these from decimal to hexadecimal notation just because that's generally how we refer to memory. So instead of being 0 through 19, what we have is zero x zero through zero x1 three. Those are the 20 bytes of memory that we have or we're looking at in this image right here. 

So all of that being said, let's step away from memory for a second and back to pointers. Here is the most important thing to remember as we start working with pointers. A pointer is nothing more than an address. I'll say it again because it's that important, a pointer is nothing more than an address. Pointers are addresses to locations in memory where variables live. Knowing that it becomes hopefully a little bit easier to work with them. Another thing I like to do is to have sort of diagrams visually representing what's happening with various lines of code. And we'll do this a couple of times in pointers, and when we talk about dynamic memory allocation as well. Because I think that these diagrams can be particularly helpful. 

So if I say for example, int k in my code, what is happening? Well what's basically happening is I'm getting memory set aside for me, but I don't even like to think about it like that, I like to think about it like a box. I have a box and it's colored green because I can put integers in green boxes. If it was a character I might have a blue box. But I always say, if I'm creating a box that can hold integers that box is colored green. And I take a permanent marker and I write k on the side of it. So I have a box called k, into which I can put integers. So when I say int k, that's what happens in my head. If I say k equals five, what am I doing? Well, I'm putting five in the box, right. This is pretty straightforward, if I say int k, create a box called k. If I say k equals 5, put five into the box. Hopefully that's not too much of a leap. Here's where things go a little interesting though. If I say int*pk, well even if I don't know what this necessarily means, it's clearly got something to do with an integer. So I'm going to color this box green-ish, I know it's got something to do with an integer, but it's not an integer itself, because it's an int star. There's something slightly different about it. So an integer's involved, but otherwise it's not too different from what we were talking about. It's a box, its got a label, it's wearing a label pk, and it's capable of holding int stars, whatever those are. They have something to do with integers, clearly. Here's the last line though. If I say pk=&k, whoa, what just happened, right? So this random number, seemingly random number, gets thrown into the box there. All that is, is pk gets the address of k. So I'm sticking where k lives in memory, its address, the address of its bytes. All I'm doing is I'm saying that value is what I'm going to put inside of my box called pk. And because these things are pointers, and because looking at a string like zero x eight zero c seven four eight two zero is probably not very meaningful. When we generally visualize pointers, we actually do so as pointers. Pk gives us the information we need to find k in memory. So basically pk has an arrow in it. And if we walk the length of that arrow, imagine it's something you can walk on, if we walk along the length of the arrow, at the very tip of that arrow, we will find the location in memory where k lives. And that's really important because once we know where k lives, we can start to work with the data inside of that memory location. Though we're getting a teeny bit ahead of ourselves for now. 
