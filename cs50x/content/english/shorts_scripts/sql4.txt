So here's the thing that's cool about databases, though-- we don't have to just have two tables. And in particular, we don't have to have just one table that stores every relevant piece of information about a user. If we wanted to store, in addition to what we have there, information like their address and their date of birth and their social security number or whatever else we wanted to keep about them, this table could get bigger and bigger and bigger and bigger to the point where it becomes almost annoying to have to use it. But we can use relationships between different tables. And that's where the term relational comes into play for a relational database. We can set up our tables within our databases carefully enough that we can use relationships between them to pull information from where we need it without all that information having to be located in the same table in the first place. So, for example, here is our database as we last left it, with three rows in each of the users and the moms tables. Now let's imagine a hypothetical situation where we want to pair a user's full name, which is currently only stored in the users table, with their mother's name, which is only stored in the mother table. They're not on the same table right now. So we can't use the same sort of select query that we used before. We have to use what's called a select join query. It looks pretty similar to the select query before. But we're adding one extra piece of information, which is what tables we're joining together. So I want to select a specific set of columns from one table, joining another table onto it just temporarily. It doesn't really merge them. But it creates this sort of hypothetical table that does merge them. On predicate, where predicate is-- basically, we're trying to find where the two tables overlap so that we can create this merged table just temporarily for purposes of this query, and then have them separate again.

So, for example, I might have a query that looks like this-- SELECT users.fullname, comma, moms.mother FROM users joining the moms table onto it temporarily ON-- which is akin to WHERE-- users.username equals moms.username. And this syntax is also a little unfamiliar, right? I'm now prepending some of my column names with table names. The reason I'm doing this is particularly because of the last line there, where in each of those two tables I had a column called username. I need to disambiguate between them. So I need to specify what table and what column. That's all that's happening here, is I'm being very explicit about which column I want by specifying not only the column name, but also the table name. So here is what would happen if I executed this select query. Here are our two tables at the outset. This is all of the information that I'm trying to get to start with. I'm going to join these two tables together where where users.username equals moms.username. Newman does not appear in both tables. So I'm not going to even come close to extracting that piece of information. Kramer does not appear in both tables, so that one's out too. But jerry and gcostanza both appear in both tables. And so that is sort of the overlap point. And you can think about this as if we have our users table, which is like one circle over here, and our moms table, which is one circle over here. When we're joining, it's sort of like if it's a Venn diagram. We're trying to figure out what those two tables have in common and using that as, like, our anchor point for the join tables. So that's what we did here. We found where the two tables have data in common.

And based on that, we create this hypothetical table called users & moms that contains all of the information that appears in both of those tables. But notice that the second column there sort of indicates the overlap. This column refers to data that is in both users.username and moms.username. So that's what we're extracting here. But remember that this query, we didn't want everything. It wasn't SELECT * FROM users JOIN moms WHERE users.username equals moms.username. Username We just want the full name and the mother's name. And so that's what we extract. And so that really long query just results in us getting this set of information-- users.fullname and moms.mother for every row in both tables where the username happens to be the same. All right. So that was a bit more complicated. You probably won't do too many joins. Fortunately, the last two operations are a little bit easier. So update is the third of the four major operations. This is what we use to modify information in the table or change it or update information. The skeleton looks like this-- UPDATE table SET column equals value-- so we're updating some column to have a new piece of data in it-- WHERE predicates. We're trying to figure out which row we want to update, and then we're updating that column. So, for example, I want to UPDATE users SET password equals yadayada WHERE idnum equals 10. You can probably guess what's going to happen here. We're going to find the row whose ID number is 10, and we're going update the password there from "fusilli" to "yadayada." Pretty straightforward. And the fourth and final operation that we do in SQL most commonly is to delete, which strikes or completely removes information from a table. The basic framework looks something like this-- DELETE from some table WHERE predicate, or, again, where some condition is satisfied. So, for example, you might want to DELETE from our users table WHERE the user name equals 'newman.'

Now, if we did that, and this was our table to start with, you can probably guess what's going to happen. After that query executes, the row whose username is newman is no longer in our table. Now, all of the operations that we just showed are really easy to do in the graphical interface of phpMyAdmin, which, again, comes with most implementations of SQL that you might download. Here's the catch, though-- phpMyAdmin, despite being very user-friendly to use, requires manual intervention. You're going to have to log in and click on some buttons to delete information or update it or change it. And we don't want to do that. We're a webmaster, right? We want things to happen automatically for us. We want programs that we write to make those changes for us. So we don't want to go into phpMyAdmin and make those changes. We have to write code that does it for us. Fortunately, SQL integrates really nicely with a lot of modern programming languages such as Python or PHP that have functions that you can use to connect to your database. And then the programming language has other functions that will query the database for you and make those changes.

Now, we're going to leave off for now exactly how those languages do that. We'll save that for a video on those languages themselves. But know that that is something that you can do to avoid having to do any sort of manual intervention when you want to update or do any sort of operation at all on your databases.

My name is Doug Lloyd. This is CS50.