
valgrind
--------

*   It turns out that, after we’re done with memory that we’ve allocated with `malloc`, we should call `free` (as in `free(t)`), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again.
*   If we kept running our program and allocating memory with `malloc`, but never freed the memory after we were done using it, we would have a **memory leak**, which will slow down our computer and use up more and more memory until our computer runs out.
*   `valgrind` is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with `help50 valgrind ./copy` and see, from the error message, that line 10, we allocated memory that we never freed (or “lost”).
*   So at the end, we can add a line `free(t)`, which won’t change how our program runs, but no errors from valgrind.
*   Let’s take a look at `memory.c`:
    
        // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare
        
        #include <stdlib.h>
        
        void f(void)
        {
            int *x = malloc(10 * sizeof(int));
            x[10] = 0;
        }
        
        int main(void)
        {
            f();
            return 0;
        }
        
    
    *   This is an example from valgrind’s documentation (valgrind is a real tool, while help50 was written specifically to help us in this course).
    *   The function `f` allocates enough memory for 10 integers, and stores the address in a pointer called `x`. Then we try to set the 11th value of `x` with `x[10]` to `0`, which goes past the array of memory we’ve allocated for our program. This is called **buffer overflow**, where we go past the boundaries of our buffer, or array, and into unknown memory.
*   valgrind will also tell us there’s an “Invalid write of size 4” for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes).
*   And this whole time, the CS50 Library has been freeing memory it’s allocated in `get_string`, when our program finishes!

Swap
----

*   We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can’t do that without a third cup to pour one of the drink into first.
*   Now, let’s say we wanted to swap the values of two integers.
    
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
        
    
    *   With a third variable to use as temporary storage space, we can do this pretty easily, by putting `a` into `tmp`, and then `b` to `a`, and finally the original value of `a`, now in `tmp`, into `b`.
*   But, if we tried to use that function in a program, we don’t see any changes:
    
        #include <stdio.h>
        
        void swap(int a, int b);
        
        int main(void)
        {
            int x = 1;
            int y = 2;
        
            printf("x is %i, y is %i\n", x, y);
            swap(x, y);
            printf("x is %i, y is %i\n", x, y);
        }
        
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
        
    
    *   It turns out that the `swap` function gets its own variables, `a` and `b` when they are passed in, that are copies of `x` and `y`, and so changing those values don’t change `x` and `y` in the `main` function.
