
Examples
--------

*   We can blur an image with:
    
        from PIL import Image, ImageFilter
        
        before = Image.open("bridge.bmp")
        after = before.filter(ImageFilter.BLUR)
        after.save("out.bmp")
        
    
    *   In Python, we include other libraries with `import`, and here we’ll `import` the `Image` and `ImageFilter` names from the `PIL` library.
    *   It turns out, if we look for documention for the `PIL` library, we can use the next three lines of code to open an image called `bridge.bmp`, run a blur filter on it, and save it to a file called `out.bmp`.
    *   And we can run this with `python blur.py` after saving to a file called `blur.py`.
*   We can implement a dictionary with:
    
        words = set()
        
        def check(word):
            if word.lower() in words:
                return True
            else:
                return False
        
        def load(dictionary):
            file = open(dictionary, "r")
            for line in file:
                words.add(line.rstrip("\n"))
            file.close()
            return True
        
        def size():
            return len(words)
        
        def unload():
            return True
        
    
    *   First, we create a new set called `words`. Then, for `check`, we can just ask \` `if word.lower() in words`. For `load`, we open the file and use `words.add` to add each line to our set. For `size`, we can use `len` to count the number of elements in our set, and finally, for `unload`, we don’t have to do anything!
*   It turns out, even though implementing a program in Python is simpler for us, the running time of our program in Python is slower than our program in C since our interpreter has to do more work for us. So, depending on our goals, we’ll also have to consider the tradeoff of human time of writing a program that’s more efficient, versus the running time of the program.
*   In Python, we can too include the CS50 library, but our syntax will be:
    
        from cs50 import get_string
        
    
    *   Notice that we specify the functions we want to use.
*   Now we can get strings from a user:
    
        from cs50 import get_string
        
        s = get_string("What's your name?:\n")
        print("hello, " + s)
        
    
*   We can substitute expressions into our format strings, too:
    
        from cs50 import get_int
        
        age = get_int("What's your age?\n")
        print(f"You are at least {age * 365} days old.")
        
    
*   And we can demonstrate conditions:
    
        from cs50 import get_int
        
        x = get_int("x: ")
        y = get_int("y: ")
        
        if x < y:
            print("x is less than y")
        elif x > y:
            print("x is greater than y")
        else:
            print("x is equal to y")
        
    
*   To check conditions, we can say:
    
        from cs50 import get_string
        
        s = get_string("Do you agree?\n")
        
        if s == "Y" or s == "y":
            print("Agreed.")
        elif s == "N" or s == "n":
            print("Not agreed.")
        
    
    *   Python doesn’t have chars, so we can check them as strings directly.
    *   We can also say `if s in ["Y", "y"]:`, or `if s.lower() in ["y"]:`. It turns out that strings in Python are like structs in C, where we have not only variables but functions that we can call. For example, given a string `s`, we can call its `lower` function with `s.lower()` to get the lowercase version of the string.
*   We can improve versions of `cough`, too:
    
        print("cough")
        print("cough")
        print("cough")
        
    
    *   We don’t need to declare a `main` function, so we just write the same line of code three times.
*   But we can do better:
    
        for i in range(3):
            cough()
        
        def cough():
            print("cough")
        
    
    *   Notice that we don’t need to specify the return type of a new function, which we can define with `def`.
    *   But this causes an error when we try to run it: `NameError: name 'cough' is not defined`. It turns out that we need to define our function before we use it, so we can either move our definition of `cough` to the top, or create a main function:
        
            def main():
                for i in range(3):
                    cough()
            
            def cough():
                print("cough")
            
            main()
            
        
    *   Now, by the time we actually call our `main` function, the `cough` function will have been read by our interpreter.
*   Our functions can take inputs, too:
    
        def main():
            cough(3)
        
        def cough(n):
            for i in range(n):
                print("cough")
        
        main()
        
    