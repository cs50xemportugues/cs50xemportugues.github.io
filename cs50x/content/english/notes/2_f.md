
Command-line arguments
----------------------

*   We’ve used programs like `make` and `clang`, which take in extra words after their name in the command line. It turns out that programs of our own, can also take in **command-line arguments**.
*   In `argv.c`, we change what our `main` function looks like:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(int argc, string argv[])
        {
            if (argc == 2)
            {
                printf("hello, %s\n", argv[1]);
            }
            else
            {
                printf("hello, world\n");
            }
        }
        
    
    *   `argc` and `argv` are two variables that our `main` function will now get, when our program is run from the command line. `argc` is the argument count, or number of arguments, and `argv` is an array of strings that are the arguments. And the first argument, `argv[0]`, is the name of our program (the first word typed, like `./hello`). In this example, we check if we have two arguments, and print out the second one if so.
    *   For example, if we run `./argv David`, we’ll get `hello, David` printed, since we typed in `David` as the second word in our command.
*   It turns out that we can indicate errors in our program by returning a value from our `main` function (as implied by the `int` before our `main` function). By default, our `main` function returns `0` to indicate nothing went wrong, but we can write a program to return a different value:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(int argc, string argv[])
        {
            if (argc != 2)
            {
                printf("missing command-line argument\n");
                return 1;
            }
            printf("hello, %s\n", argv[1]);
            return 0;
        }
        
    
    *   The return value of `main` in our program is called an exit code.
*   As we write more complex programs, error codes like this can help us determine what went wrong, even if it’s not visible or meaningful to the user

Readability
-----------

*   Now that we know how to work with strings in our programs, we can analyze paragraphs of text for their level of readability, based on factors like how long and complicated the words and sentences are.

Encryption
----------

*   If we wanted to send a message to someone, we might want to **encrypt**, or somehow scramble that message so that it would be hard for others to read. The original message, or input to our algorithm, is called **plaintext**, and the encrypted message, or output, is called **ciphertext**.
*   A message like `HI!` could be converted to ASCII, `72 73 33`. But anyone would be able to convert that back to letters.
*   An encryption algorithm generally requires another input, in addition to the plaintext. A **key** is needed, and sometimes it is simply a number, that is kept secret. With the key, plaintext can be converted, via some algorith, to ciphertext, and vice versa.
*   For example, if we wanted to send a message like `I L O V E Y O U`, we can first convert it to ASCII: `73 76 79 86 69 89 79 85`. Then, we can encrypt it with a key of just `1` and a simple algorithm, where we just add the key to each value: `74 77 80 87 70 90 80 86`. Then, someone converting that ASCII back to text will see `J M P W F Z P V`. To decrypt this, someone will need to know the key.
*   We’ll apply these concepts in our problem set!