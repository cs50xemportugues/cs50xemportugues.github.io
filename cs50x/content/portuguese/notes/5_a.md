Lecture 5
=========

*   [Pointers](#ponteiros)
*   [Redimensionando matrizes](#redimensionando-matrizes)
*   [Estruturas de dados](#estruturas-de-dados)
*   [Listas Encadeadas](#listas-encadeadas)
*   [Mais estruturas de dados](#mais-estruturas-de-dados)

Ponteiros
--------

*   Na última vez, aprendemos sobre ponteiros, `malloc` e outras ferramentas úteis para trabalhar com memória.
*   Vamos revisar este trecho de código:
    
        int main(void)
        {
            int *x;
            int *y;
        
            x = malloc(sizeof(int));
        
            *x = 42;
            *y = 13;
        }
        
    
    *   Aqui, as duas primeiras linhas de código em nossa função `main` estão declarando dois ponteiros, `x` e `y`. Em seguida, alocamos memória suficiente para um `int` com `malloc` e armazenamos o endereço retornado pelo `malloc` em `x`.
    *   Com `*x = 42;`, vamos para o endereço apontado por `x` e armazenamos o valor `42` nesse local.
    *   A última linha, no entanto, contém um bug porque não sabemos qual é o valor de `y`, uma vez que nunca atribuímos um valor a ele. Em vez disso, podemos escrever:
        
            y = x;
            *y = 13;
            
        
        *   E isso fará com que `y` aponte para o mesmo local que `x` e, em seguida, defina aquele valor para `13`.
*   Damos uma olhada em um pequeno clipe, [Pointer Fun with Binky](https://www.youtube.com/watch?v=3uLKjb973HU), que também explica esse trecho de código de forma animada!

Redimensionando matrizes
-------------------

*   Na segunda semana, aprendemos sobre matrizes, onde podemos armazenar o mesmo tipo de valor em uma lista, lado a lado. Mas precisamos declarar o tamanho das matrizes quando as criamos e, quando queremos aumentar o tamanho da matriz, a memória ao seu redor pode ser ocupada por outros dados.
*   Uma solução pode ser alocar mais memória em uma área maior que esteja livre e mover nossa matriz para lá, onde ela terá mais espaço. Mas precisaremos copiar nossa matriz, o que se torna uma operação com tempo de execução de _O_(_n_), pois precisamos copiar cada um dos _n_ elementos em uma matriz.
*   Podemos escrever um programa como o seguinte para fazer isso em código:
    
        #include <stdio.h>
        #include <stdlib.h>
        
        int main(void)
        {
            // Aqui, alocamos memória suficiente para armazenar três inteiros, e nossa variável
            // lista apontará para o primeiro inteiro.
            int *lista = malloc(3 * sizeof(int));
            // Devemos verificar se alocamos memória corretamente, já que o malloc pode
            // falhar em nos fornecer memória livre suficiente.
            if (lista == NULL)
            {
                return 1;
            }
        
            // Com essa sintaxe, o compilador fará a aritmética de ponteiros para nós e
            // calculará o byte na memória que lista[0], lista[1] e lista[2] mapeiam,
            // já que os inteiros têm tamanho de 4 bytes.
            lista[0] = 1;
            lista[1] = 2;
            lista[2] = 3;
        
            // Agora, se quisermos redimensionar nossa matriz para conter 4 inteiros, tentaremos alocar
            // memória suficiente para eles e temporariamente usaremos tmp para apontar para o primeiro:
            int *tmp = malloc(4 * sizeof(int));
            if (tmp == NULL)
            {
                return 1;
            }
        
            // Agora, copiamos os inteiros da matriz antiga para a nova matriz ...
            for (int i = 0; i < 3; i++)
            {
                tmp[i] = lista[i];
            }
        
            // ... e adicionamos o quarto inteiro:
            tmp[3] = 4;
        
            // Devemos liberar a memória original alocada para lista, é por isso que precisamos de uma
            // variável temporária para apontar para a nova matriz ...
            free(lista);
        
            // ... e agora podemos definir nossa variável lista para apontar para a nova matriz que o
            // tmp aponta:
            lista = tmp;
        
            // Agora, podemos imprimir a nova matriz:
            for (int i = 0; i < 4; i++)
            {
                printf("%i\n", lista[i]);
            }
        
            // Finalmente, liberamos a memória da nova matriz.
            free(lista);
        }
        
    
*   Acontece que existe uma função útil chamada `realloc`, que permite realocar alguma memória:
    
        #include <stdio.h>
        #include <stdlib.h>
        
        int main(void)
        {
            int *lista = malloc(3 * sizeof(int));
            if (lista == NULL)
            {
                return 1;
            }
        
            lista[0] = 1;
            lista[1] = 2;
            lista[2] = 3;
        
            // Aqui, passamos para realloc nossa matriz original, para qual lista aponta, e ela irá
            // retornar um novo endereço para uma nova matriz, com os dados antigos copiados:
            int *tmp = realloc(lista, 4 * sizeof(int));
            if (tmp == NULL)
            {
                return 1;
            }
            // Agora, tudo o que precisamos fazer é lembrar a localização da nova matriz:
            lista = tmp;
        
            lista[3] = 4;
        
            for (int i = 0; i < 4; i++)
            {
                printf("%i\n", lista[i]);
            }
        
            free(lista);
        }
        
    '