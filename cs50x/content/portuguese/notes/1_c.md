String
------

*   Mas depois de executarmos nosso programa, vemos `hello, world$`, com o novo prompt na mesma linha que a saída. Acontece que precisamos especificar precisamente que precisamos de uma nova linha após nosso programa, então podemos atualizar nosso código para incluir um caractere de nova linha especial, `\n`:
    
        #include <stdio.h>
        
        int main(void)
        {
            printf("hello, world\n");
        }
        
    
    *   Agora precisamos lembrar de recompilar nosso programa com `clang hello.c` antes de podermos executar essa nova versão.
*   A linha 2 de nosso programa está intencionalmente em branco, pois queremos iniciar uma nova seção de código, assim como iniciar novos parágrafos em ensaios. Não é estritamente necessário para que nosso programa seja executado corretamente, mas ajuda os humanos a lerem programas mais longos com mais facilidade.
*   Podemos alterar o nome de nosso programa de `a.out` para outra coisa também. Podemos passar **argumentos de linha de comando**, ou opções adicionais, para programas no terminal, dependendo do que o programa está escrito para entender. Por exemplo, podemos digitar `clang -o hello hello.c`, e `-o hello` está dizendo ao programa `clang` para salvar a saída compilada apenas como `hello`. Em seguida, podemos simplesmente executar `./hello`.
*   Em nosso prompt de comando, podemos executar outros comandos, como `ls` (listar), que mostra os arquivos em nossa pasta atual:
    
        $ ls
        a.out* hello* hello.c
        
    
    *   O asterisco, `*`, indica que esses arquivos são executáveis, ou que podem ser executados pelo nosso computador.
*   Podemos usar o comando `rm` (remover) para excluir um arquivo:
    
        $ rm a.out
        rm: remove regular file 'a.out'?
        
    
    *   Podemos digitar `y` ou `yes` para confirmar e usar `ls` novamente para ver que ele desapareceu permanentemente.
*   Agora, vamos tentar obter entrada do usuário, como fizemos no Scratch quando queríamos dizer "hello, David":  
    ![captura de tela dos blocos "perguntar qual é o seu nome? e esperar", "dizer junte olá, resposta"](https://cs50.harvard.edu/x/2020/notes/1/ask_say_join.png)
    
        string answer = get_string("Qual é o seu nome?\n");
        printf("hello, %s\n", answer);
        
    
    *   Primeiro, precisamos de uma **string**, ou seja, um pedaço de texto (especificamente, zero ou mais caracteres em sequência entre aspas duplas, como `""`, `"ba"` ou “bananas”), que podemos pedir ao usuário usando a função `get_string`. Passamos o prompt, ou o que queremos perguntar ao usuário, para a função com `"Qual é o seu nome?\n"` dentro dos parênteses. À esquerda, queremos criar uma variável, `answer`, cujo valor será o que o usuário digitar. (O sinal de igual `=` está definindo o valor da direita para a esquerda.) Por fim, o tipo de variável que queremos é `string`, então especificamos isso à esquerda de `answer`.
    *   Em seguida, dentro da função `printf`, queremos o valor de `answer` naquilo que imprimimos. Usamos um espaço reservado para nossa variável de string, `%s`, dentro da frase que queremos imprimir, como `"hello, %s\n"`, e em seguida, damos a `printf` outro argumento, ou opção, para informar que queremos que a variável `answer` seja substituída.
*   Se cometemos um erro, como escrever `printf("hello, world"\n);` com o `\n` fora das aspas duplas para nossa string, veremos erros do nosso compilador:
    
        $ clang -o hello hello.c
        hello.c:5:26: error: expected ')'
            printf("hello, world"\n);
                                 ^
        hello.c:5:11: note: to match this '('
            printf("hello, world"\n);
                  ^
        1 error generated.
        
    
    *   A primeira linha do erro nos diz para olhar para `hello.c`, linha 5, coluna 26, onde o compilador esperava um parêntese de fechamento, em vez de uma barra invertida.
*   Para simplificar as coisas (pelo menos no início), incluiremos uma biblioteca, ou conjunto de código, do CS50. A biblioteca fornece-nos o tipo de variável `string`, a função `get_string` e muito mais. Só temos que escrever uma linha no topo para `include` o arquivo `cs50.h`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, name\n");
        }
        
    
*   Então vamos criar um novo arquivo, `string.c`, com este código:
    
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, %s\n", name);
        }
        
    
*   Agora, se tentarmos compilar esse código, obtemos várias linhas de erros. Às vezes, um erro significa que o compilador passa a interpretar código correto incorretamente, gerando mais erros do que realmente existem. Portanto, começamos com nosso primeiro erro:
    
        $ clang -o string string.c
        string.c:5:5: error: use of undeclared identifier 'string'; did you mean 'stdin'?
          string name = get_string("Qual é o seu nome?\n");
          ^~~~~~
          stdin
        /usr/include/stdio.h:135:25: note: 'stdin' declared here
        extern struct _IO_FILE *stdin;          /* Fluxo de entrada padrão.  */
        
    
    *   Não queríamos dizer `stdin` (entrada padrão) em vez de `string`, portanto, essa mensagem de erro não foi útil. Na verdade, precisamos importar outro arquivo que defina o tipo `string` (na verdade, uma rodinha de treinamento do CS50, como descobriremos nas próximas semanas).
*   Portanto, podemos incluir outro arquivo, `cs50.h`, que também inclui a função `get_string`, entre outras.
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, %s\n", name);
        }
        
    
*   Agora, quando tentamos compilar nosso programa, temos apenas um erro:
    
        $ clang -o string string.c
        /tmp/string-aca94d.o: In function `main':
        string.c:(.text+0x19): undefined reference to `get_string'
        clang-7: error: comando do vinculador falhou com o código de saída 1 (use -v para ver a invocação)
        
    
    *   Acontece que também precisamos dizer ao compilador para adicionar nosso arquivo especial da biblioteca CS50, com `clang -o string string.c -lcs50`, com `-l` para "link".
*   Podemos até abstrair isso e simplesmente digitar `make string`. Vemos que, por padrão no CS50 Sandbox, `make` usa `clang` para compilar nosso código de `string.c` em `string`, com todos os argumentos necessários, ou flags, passados.
'