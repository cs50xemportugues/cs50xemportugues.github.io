Estruturas de dados
---------------

*   **Estruturas de dados** são construções de programação que nos permitem armazenar informações em diferentes layouts na memória do nosso computador.
*   Para construir uma estrutura de dados, precisamos de algumas ferramentas que vimos anteriormente:
    *   `struct` para criar tipos de dados personalizados
    *   `.` para acessar propriedades em uma estrutura
    *   `*` para ir para um endereço na memória apontado por um ponteiro

Listas Encadeadas
------------

*   Com uma **lista encadeada**, podemos armazenar uma lista de valores que pode ser facilmente expandida, armazenando valores em diferentes partes da memória:  
    ![grade representando a memória, com três caixas rotuladas com caixas vazias entre elas, cada uma rotulada por 1 0x123, 2 0x456 e 3 0x789](https://cs50.harvard.edu/x/2020/notes/5/linked_list.png)
    *   Isso é diferente de uma matriz, pois nossos valores não estão mais próximos um do outro na memória.
*   Podemos ligar nossa lista alocando, para cada elemento, memória suficiente para o valor que queremos armazenar e o endereço do próximo elemento:  
    ![três caixas, cada uma dividida em duas e rotulada (1 0x123 e 0x456), (2 0x456 e 0x789) e (3 0x789 e NULL)](https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png)
    *   A propósito, `NUL` refere-se a `\0`, um caractere que termina uma string, e `NULL` refere-se a um endereço de todos os zeros, ou um ponteiro nulo que podemos pensar como apontando para nenhum lugar.
*   Ao contrário do que podemos fazer com matrizes, não podemos mais acessar elementos em uma lista encadeada aleatoriamente. Por exemplo, não podemos mais acessar o quinto elemento da lista calculando onde ele está, em tempo constante. (Uma vez que sabemos que as matrizes armazenam elementos lado a lado, podemos adicionar 1, ou 4, ou o tamanho do nosso elemento, para calcular endereços.) Em vez disso, precisamos seguir o ponteiro de cada elemento, um de cada vez. E precisamos alocar o dobro de memória do que precisávamos antes para cada elemento.
*   No código, podemos criar nossa própria struct chamada `node` (como um nó de um gráfico em matemática), e precisamos armazenar tanto um `int` como um ponteiro para o próximo `node` chamado `next`:
    
        typedef struct node
        {
            int number;
            struct node *next;
        }
        node;
        
    
    *   Começamos essa struct com `typedef struct node` para que possamos nos referir a um `node` dentro de nossa struct.
*   Podemos construir uma lista encadeada no código a partir de nossa struct. Primeiro, vamos querer lembrar de uma lista vazia, para que possamos usar o ponteiro nulo: `node *list = NULL;`.
*   Para adicionar um elemento, primeiro precisaremos alocar algum espaço na memória para um nó e definir seus valores:
    
        node *n = malloc(sizeof(node));
        // Queremos ter certeza de que malloc teve sucesso em obter memória para nós:
        if (n != NULL)
        {
            // Isto é equivalente a (*n).number, onde primeiro vamos para o nó apontado
            // por n e, em seguida, definimos a propriedade number. Em C, também podemos
            // usar esta notação de seta:
            n->number = 2;
            // Em seguida, precisamos armazenar um ponteiro para o próximo nó em nossa lista, mas o
            // novo nó não vai apontar para nada (por enquanto):
            n->next = NULL;
        }
        
    
*   Agora nossa lista pode apontar para esse nó: `list = n;`:  
    ![uma caixa rotulada lista com seta para fora apontando para duas caixas conectadas, uma com 2 e outra vazia](https://cs50.harvard.edu/x/2020/notes/5/list_with_one_node.png)
*   Para adicionar à lista, criaremos um novo nó da mesma maneira, talvez com o valor 4. Mas agora precisamos atualizar o ponteiro em nosso primeiro nó para apontar para ele.
*   Como nosso ponteiro `list` aponta apenas para o primeiro nó (e não podemos ter certeza de que a lista tem apenas um nó), precisamos “seguir as migalhas” e seguir o ponteiro `next` de cada nó:
    
        // Crie um ponteiro temporário para o que list está apontando
        node *tmp = list;
        // Enquanto o nó tiver um próximo ponteiro ...
        while (tmp->next != NULL)
        {
            // ... defina o temporário para o próximo nó
            tmp = tmp->next;
        }
        // Agora, tmp aponta para o último nó em nossa lista e podemos atualizar seu próximo
        // ponteiro para apontar para nosso novo nó.
        
    
*   Se quisermos inserir um nó no início de nossa lista encadeada, precisaremos atualizar cuidadosamente nosso nó para apontar para o seguinte, antes de atualizar a lista. Caso contrário, perderemos o resto de nossa lista:
    
        // Aqui, estamos inserindo um nó no início da lista, então queremos que seu
        // próximo ponteiro aponte para a lista original, antes de apontar a lista para
        // o n.
        n->next = list;
        list = n;
        
    
*   E para inserir um nó no meio de nossa lista, podemos percorrer a lista, seguindo cada elemento um de cada vez, comparando seus valores e mudando os ponteiros `next` com cuidado também.
*   Com alguns voluntários no palco, simulamos uma lista, com cada voluntário atuando como a variável `list` ou um nó. À medida que inserimos nós na lista, precisamos de um ponteiro temporário para seguir a lista e garantir que não percamos nenhuma parte dela. Nossa lista encadeada aponta apenas para o primeiro nó em nossa lista, portanto, só podemos olhar um nó de cada vez, mas podemos alocar dinamicamente mais memória à medida que precisamos expandir nossa lista.
*   Agora, mesmo que a nossa lista encadeada esteja ordenada, o tempo de execução de pesquisá-la será _O_(_n_), já que precisamos seguir cada nó para verificar seus valores e não sabemos onde estará o meio da nossa lista.
*   Podemos combinar todos os trechos de código em um programa completo:
    
        #include <stdio.h>
        #include <stdlib.h>
        
        // Representa um nó
        typedef struct node
        {
            int number;
            struct node *next;
        }
        node;
        
        int main(void)
        {
            // Lista de tamanho 0, inicialmente não apontando para nada
            node *list = NULL;
        
            // Adicionar número à lista
            node *n = malloc(sizeof(node));
            if (n == NULL)
            {
                return 1;
            }
            n->number = 1;
            n->next = NULL;
            // Criamos nosso primeiro nó, armazenamos o valor 1 nele e deixamos o próximo
            // ponteiro apontar para nada. Em seguida, nossa variável de lista pode apontar para ele.
            list = n;
        
            // Adicionar número à lista
            n = malloc(sizeof(node));
            if (n == NULL)
            {
                return 1;
            }
            n->number = 2;
            n->next = NULL;
            // Agora, nós vamos ao nosso primeiro nó para o qual a lista aponta e definimos o próximo ponteiro
            // sobre ele para apontar para o nosso novo nó, adicionando-o ao final da lista:
            list->next = n;
        
            // Adicionar número à lista
            n = malloc(sizeof(node));
            if (n == NULL)
            {
                return 1;
            }
            n->number = 3;
            n->next = NULL;
            // Podemos seguir vários nós com esta sintaxe, usando o ponteiro próximo
            // repetidamente, para adicionar nosso terceiro novo nó ao final da lista:
            list->next->next = n;
            // Normalmente, porém, gostaríamos de ter um loop e uma variável temporária para adicionar
            // um novo nó à nossa lista.
        
            // Imprimir lista
            // Aqui podemos percorrer todos os nós em nossa lista com uma variável temporária
            // Primeiro, temos um ponteiro temporário, tmp, que aponta para a
            // lista. Em seguida, nossa condição para continuar é que tmp não seja NULO e
            // finalmente, atualizamos