Palestra 2
=========

*   [Compilação](#compilacao)
*   [Depuração](#depuracao)
*   [help50 e printf](#help50-e-printf)
*   [debug50](#debug50)
*   [check50 e style50](#check50-e-style50)
*   [Tipos de dados](#tipos-de-dados)
*   [Memória](#memoria)
*   [Arrays](#arrays)
*   [Strings](#strings)
*   [Argumentos da linha de comando](#argumentos-da-linha-de-comando)
*   [Legibilidade](#legibilidade)
*   [Criptografia](#criptografia)

Compilação
---------
*   Na última vez, aprendemos a escrever nosso primeiro programa em C. Aprendemos a sintaxe para a função `main` em nosso programa, a função `printf` para imprimir no terminal, como criar strings com aspas duplas e como incluir `stdio.h` para a função `printf`.
*   Em seguida, compilamos com `clang hello.c` para poder executar `./a.out` (nome padrão) e então `clang -o hello hello.c` (passando um argumento da linha de comando para o nome de saída) para poder executar `./hello`.
*   Se quiséssemos usar a biblioteca do CS50, através do `#include <cs50.h>`, para strings e a função `get_string`, também teríamos que adicionar uma flag: `clang -o hello hello.c -lcs50`. A flag `-l` vincula o arquivo `cs50`, que já está instalado no Sandbox do CS50, e inclui protótipos ou definições de strings e `get_string` (entre outras) que nosso programa pode usar e referenciar.
*   Escrevemos nosso código-fonte em C, mas precisamos compilá-lo para código de máquina, em binário, antes que nossos computadores possam executá-lo.
    *   `clang` é o compilador e `make` é uma ferramenta que nos ajuda a executar o `clang` sem ter que indicar todas as opções manualmente.
*   "Compilar" o código-fonte em código de máquina é, na verdade, composto de etapas menores:
    *   pré-processamento
    *   compilação
    *   montagem
    *   linkagem
*   **Pré-processamento** envolve a análise de linhas que começam com um `#`, como `#include`, antes de tudo. Por exemplo, `#include <cs50.h>` dirá ao `clang` para procurar esse arquivo de cabeçalho primeiro, pois ele contém conteúdo que queremos incluir em nosso programa. Em seguida, o `clang` substituirá essencialmente o conteúdo desses arquivos de cabeçalho em nosso programa.
*   Por exemplo …

        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Nome: ");
            printf("olá, %s\n", name);
        }
        
    
*   … será pré-processado para:
    
        string get_string(string prompt);
        int printf(const char *format, ...);
        
        int main(void)
        {
            string name = get_string("Nome: ");
            printf("olá, %s\n", name);
        }
        
    
*   **Compilação** pega nosso código-fonte, em C, e o converte para código assembly, que se parece com isso:
    
        ...
        main:                         # @main
            .cfi_startproc
        # BB#0:
            pushq    %rbp
        .Ltmp0:
            .cfi_def_cfa_offset 16
        .Ltmp1:
            .cfi_offset %rbp, -16
            movq    %rsp, %rbp
        .Ltmp2:
            .cfi_def_cfa_register %rbp
            subq    $16, %rsp
            xorl    %eax, %eax
            movl    %eax, %edi
            movabsq    $.L.str, %rsi
            movb    $0, %al
            callq    get_string
            movabsq    $.L.str.1, %rdi
            movq    %rax, -8(%rbp)
            movq    -8(%rbp), %rsi
            movb    $0, %al
            callq    printf
            ...
        
    
    *   Essas instruções são de nível mais baixo e estão mais próximas das instruções binárias que a CPU de um computador pode entender diretamente. Elas geralmente operam em bytes em si, em vez de abstrações como nomes de variáveis.
*   O próximo passo é levar o código assembly e traduzi-lo para instruções em binário **montando**-o. As instruções em binário são chamadas de **código de máquina**, que a CPU de um computador pode executar diretamente.
*   A última etapa é a **linkagem**, onde o conteúdo das bibliotecas previamente compiladas que queremos vincular, como `cs50.c`, são combinadas com o binário de nosso programa. Assim, acabamos com um único arquivo binário, `a.out` ou `hello`, que é a versão compilada de `hello.c`, `cs50.c` e `printf.c`.

Depuração
---------

*   Bugs são erros em programas que não pretendíamos cometer. E a depuração é o processo de encontrar e corrigir bugs.

help50 e printf
-----------------

*   Digamos que escrevemos este programa, `buggy0.c`:
    
        int main(void)
        {
            printf("hello, world\n");
        }
        

    *   Vemos um erro (em vermelho), quando tentamos `make` neste programa, que estamos `declarando implicitamente a função da biblioteca 'printf'`. Não entendemos muito bem isso, então podemos executar `help50 make buggy0`, que nos dirá, no final, que talvez tenhamos esquecido de escrever `#include <stdio.h>`, que contém `printf`.
*   Podemos tentar novamente com `buggy1.c`:
    
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, %s\n", name);
        }
        

    *   Vemos muitos erros e até mesmo o primeiro não parece fazer muito sentido. Então podemos executar novamente `help50 make buggy1`, que nos dará a dica de que precisamos de `cs50.h` já que `string` não está definida.
*   Para limpar a janela do terminal (para que possamos ver apenas a saída do que queremos executar em seguida), podemos pressionar `control + L` ou digitar `clear` como um comando na janela do terminal.
*   Vamos dar uma olhada em `buggy2.c`:
    
        #include <stdio.h>
        
        int main(void)
        {
            for (int i = 0; i <= 10; i++)
            {
                printf("#\n");
            }
        }
        

    *   Hmm, pretendíamos ver apenas 10 `#`s, mas há 11. Se não soubéssemos qual é o problema (já que nosso programa está compilando sem erros e agora temos um erro lógico), poderíamos adicionar outra linha de impressão para nos ajudar:
    
            #include <stdio.h>
            
            int main(void)
            {
                for (int i = 0; i <= 10; i++)
                {
                    printf("i agora é %i: ", i);
                    printf("#\n");
                }
            }
            
        
    *   Agora, vemos que `i` começou em 0 e continuou até chegar a 10, mas deveríamos pará-lo quando estiver em 10, com `i < 10` em vez de `i <= 10`.

debug50
-------

*   Hoje também daremos uma olhada no CS50 IDE, que é como o CS50 Sandbox, mas com mais recursos. É um ambiente de desenvolvimento online, com um editor de código e uma janela do terminal, mas também ferramentas para depurar e colaborar:
    ![janela do navegador com CS50 IDE, editor de código na parte superior com buggy2.c, janela do terminal na parte inferior](https://cs50.harvard.edu/x/2020/notes/2/cs50_ide.png)
*   No CS50 IDE, teremos outra ferramenta, `debug50`, para nos ajudar a depurar programas.
*   Vamos abrir `buggy2.c` e tentar `make buggy2`. Mas salvamos `buggy2.c` em uma pasta chamada `src2`, então precisamos executar `cd src2` para mudar nosso diretório para o correto. E o terminal do CS50 IDE nos lembrará em qual diretório estamos, com um prompt como `~/src/ $`. (O `~` indica o diretório padrão, ou diretório pessoal).
*   Em vez de usar `printf`, também podemos depurar nosso programa de forma interativa. Podemos adicionar um _ponto de interrupção_, ou um indicador para uma linha de código onde o depurador deve pausar nosso programa. Por exemplo, podemos clicar à esquerda da linha 5 de nosso código, e um círculo vermelho aparecerá:
    ![editor de código com ícone vermelho ao lado da linha 5 do código](https://cs50.harvard.edu/x/2020/notes/2/breakpoint.png)
*   Agora, se executarmos `debug50 ./buggy2`, veremos o painel do depurador abrir à direita:
    ![painel do depurador com controles e variáveis](https://cs50.harvard.edu/x/2020/notes/2/debugger_panel.png)
*   Vemos que a variável que criamos, `i`, está na seção `Variáveis locais` e vemos que tem um valor de `0`.
*   Nosso ponto de interrupção pausou nosso programa após a linha 5, logo antes da linha 7, já que é a primeira linha de código que pode ser executada. Para continuar, temos alguns controles no painel do depurador. O triângulo azul continuará nosso programa até chegarmos a outro ponto de interrupção ou ao final do programa. A seta curva à direita dele irá "pular" a linha, executando-a e pausando nosso programa novamente imediatamente depois.
*   Então, usaremos a seta curva para executar a próxima linha e ver o que muda. Estamos na linha `printf` e, pressionando a seta curva novamente, vemos um único `#` impresso em nossa janela do terminal. Com mais um clique na seta, vemos o valor de `i` à direita mudar para `1`. E podemos continuar clicando na seta para acompanhar a execução do nosso programa, uma linha de cada vez.
*   Para sair do depurador, podemos pressionar `control + C` para parar o programa.
*   Podemos economizar muito tempo no futuro investindo um pouco agora para aprender como usar o `debug50`!

check50 e style50
-------------------

*   Podemos executar um comando como `check50 cs50/problems/hello`, onde `check50` é um programa que segue instruções identificadas pelo argumento `cs50/problems/hello` para fazer o upload, executar e testar nosso programa nos servidores do CS50. Isso verificará se o nosso programa está correto.
    *   Ao escrever software no mundo real, os desenvolvedores geralmente escreverão seus próprios testes para garantir que seu código funcione como esperado, especialmente à medida que mais recursos são adicionados ao mesmo código.
*   `style50` é outro programa que verificará nosso código em busca de problemas estéticos, como espaços em branco, de forma a tornar nosso código mais legível e sustentável. Por exemplo, podemos estar com uma indentação faltando. E o [Guia de Estilo](https://cs50.readthedocs.io/style/c/) incluirá mais explicações sobre o que esperamos.
*   Podemos até usar a depuração com pato de borracha, um método em que explicamos o que estamos tentando fazer para um pato de borracha, de forma que percebemos o que estamos tentando fazer e o que devemos corrigir.
*   Também queremos escrever nosso código com um bom design, em que não apenas resolvamos o problema corretamente, mas também de forma adequada, em que façamos escolhas razoáveis para o funcionamento do nosso programa e façamos trocas entre tempo, custo de desenvolvimento e memória.

Tipos de Dados
----------

*   Em C, temos diferentes tipos de variáveis que podemos usar para armazenar dados:
    *   bool 1 byte
    *   char 1 byte
    *   int 4 bytes
    *   float 4 bytes
    *   long 8 bytes
    *   double 8 bytes
    *   string ? bytes
*   Cada um desses tipos ocupa um certo número de bytes por variável que criamos, e os tamanhos acima são os que o sandbox, IDE e provavelmente o seu computador usam para cada tipo em C.

Memória
------

*   Dentro de nossos computadores, temos chips chamados de RAM (memória de acesso aleatório), que armazenam dados para uso a curto prazo. Podemos salvar um programa ou arquivo em nosso disco rígido (ou SSD) para armazenamento a longo prazo, mas quando o abrimos, ele é copiado primeiro para a RAM. Embora a RAM seja muito menor e temporária (até que a energia seja desligada), ela é muito mais rápida.
*   Podemos pensar em bytes, armazenados na RAM, como se estivessem em uma grade:  
    ![chip do computador com grade sobreposta](https://cs50.harvard.edu/x/2020/notes/2/ram.png)
    *   Na realidade, existem milhões ou bilhões de bytes por chip.
*   Em C, quando criamos uma variável do tipo `char`, que terá tamanho de um byte, ela será armazenada fisicamente em uma dessas caixas na RAM. Um inteiro, com 4 bytes, ocupará quatro dessas caixas.
*   E cada uma dessas caixas é rotulada com algum número, ou endereço, de 0, a 1, a 2, e assim por diante.

Arrays
------

*   Digamos que queremos armazenar três variáveis:
    
        #include <stdio.h>
        
        int main(void)
        {
            char c1 = 'H';
            char c2 = 'I';
            char c3 = '!';
            printf("%c %c %c\n", c1, c2, c3);
        }
        
    
    *   Observe que usamos aspas simples para indicar um caractere literal e aspas duplas para vários caracteres juntos em uma string.
    *   Podemos compilar e executar isso para ver `H I !`.
*   E sabemos que caracteres são apenas números, então se alterarmos o formato da string para `printf("%i %i %i\n", c1, c2, c3);`, podemos ver os valores numéricos de cada caractere impressos: `72 73 33`.
    *   Podemos converter explicitamente, ou fazer um cast, cada caractere para um int antes de usá-lo, usando `(int) c1`, mas nosso compilador pode fazer isso implicitamente para nós.
*   Na memória, podemos ter três caixas, rotuladas `c1`, `c2` e `c3`, representando cada uma um byte binário com os valores de cada variável.
*   Vamos olhar para o `scores0.c`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Notas
            int nota1 = 72;
            int nota2 = 73;
            int nota3 = 33;
        
            // Imprime a média
            printf("Média: %i\n", (nota1 + nota2 + nota3) / 3);
        }
        
    
    *   Podemos imprimir a média de três números, mas agora precisamos criar uma variável para cada nota que queremos incluir, e não podemos usá-las facilmente depois.
*   Acontece que, na memória, podemos armazenar variáveis uma depois da outra, em sequência. E em C, uma lista de variáveis armazenadas, uma depois da outra, em um pedaço contíguo de memória, é chamada de **array**.
*   Por exemplo, podemos usar `int notas[3];` para declarar um array de 3 números inteiros.
*   E podemos atribuir e usar variáveis em um array da seguinte forma:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Notas
            int notas[3];
            notas[0] = 72;
            notas[1] = 73;
            notas[2] = 33;
        
            // Imprime a média
            printf("Média: %i\n", (notas[0] + notas[1] + notas[2]) / 3);
        }
        
    
    *   Observe que os arrays são indexados em zero, o que significa que o primeiro elemento ou valor tem o índice 0.
*   E repetimos o valor 3, que representa o comprimento do nosso array, em dois lugares diferentes. Portanto, podemos usar uma constante, ou valor fixo, para indicar que ela deve ser sempre a mesma em ambos os lugares:
    
        #include <cs50.h>
        #include <stdio.h>
        
        const int N = 3;
        
        int main(void)
        {
            // Notas
            int notas[N];
            notas[0] = 72;
            notas[1] = 73;
            notas[2] = 33;
        
            // Imprime a média
            printf("Média: %i\n", (notas[0] + notas[1] + notas[2]) / N);
        }
        
    
    *   Podemos usar a palavra-chave `const` para informar ao compilador que o valor de `N` nunca deve ser alterado pelo nosso programa. E por convenção, vamos colocar nossa declaração da variável fora da função `main` e capitalizar seu nome, o que não é necessário para o compilador, mas mostra para outras pessoas que essa variável é uma constante e torna fácil de ver desde o início.
*   Com um array, podemos coletar nossas notas em um loop e acessá-las posteriormente também em um loop:
    
        #include <cs50.h>
        #include <stdio.h>
        
        float media(int comprimento, int array[]);
        
        int main(void)
        {
            // Obtenha o número de notas
            int n = get_int("Notas:  ");
        
            // Obtenha as notas
            int notas[n];
            for (int i = 0; i < n; i++)
            {
                notas[i] = get_int("Nota %i: ", i + 1);
            }
        
            // Imprime a média
            printf("Média: %.1f\n", media(n, notas));
        }
        
        float media(int comprimento, int array[])
        {
            int soma = 0;
            for (int i = 0; i < comprimento; i++)
            {
                soma += array[i];
            }
            return (float) soma / (float) comprimento;
        }
        
    
    *   Primeiro, perguntaremos ao usuário quantas notas ele tem, criaremos um array com espaço suficiente para o número de notas que ele tem usando `int`s e usaremos um loop para coletar todas as notas.
    *   Em seguida, escreveremos uma função auxiliar, `media`, para retornar um `float`, ou um valor decimal. Passaremos o comprimento e um array de `int`s (que pode ter qualquer tamanho) e usaremos outro loop dentro de nossa função auxiliar para somar os valores em uma soma. Usamos `(float)` para fazer um cast tanto na soma quanto no comprimento para floats, para que o resultado da divisão seja também um float.
    *   Por fim, quando imprimimos o resultado que obtemos, usamos `%.1f` para mostrar apenas um lugar após a vírgula.
*   Na memória, nosso array agora está armazenado assim, onde cada valor ocupa não apenas um, mas quatro bytes:  
    ![grid with 72 labeled nota1, 73 labeled nota2, 33 labeled nota3, each of which takes up four boxes, and many empty boxes following](https://cs50.harvard.edu/x/2020/notes/2/memory_with_array.png)

Strings
-------

*   As strings são na verdade apenas arrays de caracteres. Se tivermos uma string `s`, cada caracter pode ser acessado com `s[0]`, `s[1]`, e assim por diante.
*   E acontece que uma string termina com um caracter especial, ‘\\0’, ou um byte com todos os bits definidos como 0. Esse caracter é chamado de caracter nulo, ou caracter de terminação nula. Portanto, na verdade precisamos de quatro bytes para armazenar a nossa string "OI!":  
    ![grade com H rotulado de s[0], I rotulado de s[1], ! rotulado de s[2], \0 rotulado de s[3], cada um ocupando uma caixa, e muitas caixas vazias a seguir](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png)
*   Agora vamos ver como quatro strings em um array podem se parecer:
    
        string nomes[4];
        nomes[0] = "EMMA";
        nomes[1] = "RODRIGO";
        nomes[2] = "BRIAN";
        nomes[3] = "DAVID";
        
        printf("%s\n", nomes[0]);
        printf("%c%c%c%c\n", nomes[0][0], nomes[0][1], nomes[0][2], nomes[0][3]);
        
    
    *   Podemos imprimir o primeiro valor em `nomes` como uma string, ou podemos obter a primeira string e obter cada caracter individual nessa string usando `[]` novamente. (Podemos pensar nisso como `(nomes[0])[0]`, embora não precisemos dos parênteses.)
    *   E embora saibamos que o primeiro nome tinha quatro caracteres, `printf` provavelmente usou um loop para examinar cada caracter na string, imprimindo-os um de cada vez até chegar ao caracter nulo que marca o final da string. E na verdade, podemos imprimir `nomes[0][4]` como um `int` com `%i` e ver um `0` sendo impresso.
*   Podemos visualizar cada caracter com seu próprio rótulo na memória:  
    ![grade com E rotulado de nomes[0][0], M rotulado de nomes[0][1], e assim por diante, até nomes[3][5] com um \0, cada um ocupando uma caixa, e caixas vazias a seguir](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png)
*   Podemos tentar experimentar com `string0.c`:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Entrada:  ");
            printf("Saída: ");
            for (int i = 0; i < strlen(s); i++)
            {
                printf("%c", s[i]);
            }
            printf("\n");
        }
        
    
    *   Podemos usar a condição `s[i] != '\0'`, onde podemos verificar o caractere atual e apenas imprimi-lo se ele não for o caracter nulo.
    *   Também podemos usar o tamanho da string, mas primeiro, precisamos de uma nova biblioteca, `string.h`, para `strlen`, que nos diz o tamanho de uma string.
*   Podemos melhorar o design do nosso programa. `string0` foi um pouco ineficiente, já que verificamos o tamanho da string depois que cada caracter é impresso, em nossa condição. Mas como o tamanho da string não muda, podemos verificar o tamanho da string uma vez:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Entrada: ");
            printf("Saída:\n");
            for (int i = 0, n = strlen(s); i < n; i++)
            {
                printf("%c\n", s[i]);
            }
        }
        
    
    *   Agora, no início do nosso loop, inicializamos tanto uma variável `i` quanto uma variável `n` e lembramos o tamanho da nossa string em `n`. Em seguida, podemos verificar os valores a cada vez, sem precisar calcular o tamanho da string de fato.
    *   E precisamos usar um pouco mais de memória para `n`, mas isso nos economiza algum tempo em não ter que verificar o tamanho da string a cada vez.
*   Agora podemos combinar o que vimos para escrever um programa que pode capitalizar letras:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Antes: ");
            printf("Depois:  ");
            for (int i = 0, n = strlen(s); i < n; i++)
            {
                if (s[i] >= 'a' && s[i] <= 'z')
                {
                    printf("%c", s[i] - 32);
                }
                else
                {
                    printf("%c", s[i]);
                }
            }
            printf("\n");
        }
        
    
    *   Primeiro, obtemos uma string `s`. Em seguida, para cada caracter na string, se for minúsculo (seu valor estiver entre o de `a` e `z`), o convertemos para maiúsculo. Caso contrário, apenas o imprimimos.
    *   Podemos converter uma letra minúscula para seu equivalente em maiúscula, subtraindo a diferença entre seus valores ASCII. (Sabemos que letras minúsculas têm um valor ASCII maior do que letras maiúsculas, e a diferença é convenientemente a mesma entre as mesmas letras, então podemos subtrair essa diferença para obter uma letra maiúscula a partir de uma letra minúscula.)
*   Podemos usar as [**man pages**](https://man.cs50.io/), ou manual do programador, para encontrar funções de biblioteca que podemos usar para realizar a mesma coisa:
    
        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Antes: ");
            printf("Depois:  ");
            for (int i = 0, n = strlen(s); i < n; i++)
            {
                printf("%c", toupper(s[i]));
            }
            printf("\n");
        }
        
    
    *   Ao pesquisar nas man pages, vemos que `toupper()` é uma função, entre outras, de uma biblioteca chamada `ctype`, que podemos usar.

Argumentos de linha de comando
----------------------

*   Já utilizamos programas como `make` e `clang`, os quais recebem palavras adicionais após o seu nome na linha de comando. Acontece que nossos próprios programas também podem receber **argumentos de linha de comando**.
*   No arquivo `argv.c`, alteramos a aparência da nossa função `main`:

        #include <cs50.h>
        #include <stdio.h>
        
        int main(int argc, string argv[])
        {
            if (argc == 2)
            {
                printf("olá, %s\n", argv[1]);
            }
            else
            {
                printf("olá, mundo\n");
            }
        }
        
    
    *   `argc` e `argv` são duas variáveis que a nossa função `main` receberá quando o nosso programa for executado na linha de comando. `argc` é a contagem de argumentos, ou seja, o número de argumentos, e `argv` é um array de strings que são os argumentos. E o primeiro argumento, `argv[0]`, é o nome do nosso programa (a primeira palavra digitada, como `./hello`). Neste exemplo, verificamos se temos dois argumentos e imprimimos o segundo, se for o caso.
    *   Por exemplo, se executarmos `./argv David`, receberemos `olá, David` impresso, já que digitamos `David` como a segunda palavra no nosso comando.
*   Acontece que podemos indicar erros no nosso programa retornando um valor da nossa função `main` (como emplica o `int` antes da nossa função `main`). Por padrão, nossa função `main` retorna `0` para indicar que nada deu errado, mas podemos escrever um programa para retornar um valor diferente:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(int argc, string argv[])
        {
            if (argc != 2)
            {
                printf("faltando argumento de linha de comando\n");
                return 1;
            }
            printf("olá, %s\n", argv[1]);
            return 0;
        }
        
    
    *   O valor de retorno do `main` no nosso programa é chamado de código de saída.
*   À medida que escrevemos programas mais complexos, códigos de erro como esse podem nos ajudar a determinar o que deu errado, mesmo que não seja visível ou significativo para o usuário.

Legibilidade
-----------

*   Agora que sabemos como trabalhar com strings nos nossos programas, podemos analisar parágrafos de texto em relação ao seu nível de legibilidade, com base em fatores como o quanto as palavras e as frases são longas e complicadas.

Criptografia
----------

*   Se quisermos enviar uma mensagem para alguém, podemos querer **criptografar**, ou de alguma forma embaralhar essa mensagem para que seja difícil para outras pessoas lerem. A mensagem original, ou entrada para o nosso algoritmo, é chamada de **texto simples**, e a mensagem criptografada, ou saída, é chamada de **texto cifrado**.
*   Uma mensagem como `OI!` pode ser convertida para ASCII, `72 73 33`. Mas qualquer pessoa conseguiria converter isso de volta para letras.
*   Um algoritmo de criptografia geralmente requer uma entrada adicional, além do texto simples. Uma **chave** é necessária e, às vezes, é simplesmente um número que é mantido em segredo. Com a chave, o texto simples pode ser convertido, por meio de algum algoritmo, para texto cifrado e vice-versa.
*   Por exemplo, se quisermos enviar uma mensagem como `EU AMO VOCÊ`, podemos primeiro convertê-la para ASCII: `73 76 79 86 69 89 79 85`. Em seguida, podemos criptografá-la com uma chave de apenas `1` e um algoritmo simples, onde apenas adicionamos a chave a cada valor: `74 77 80 87 70 90 80 86`. Então, alguém que converta esse ASCII de volta para texto verá `J M P W F Z P V`. Para descriptografar isso, alguém precisará saber a chave.
*   Aplicaremos esses conceitos no nosso conjunto de problemas!

