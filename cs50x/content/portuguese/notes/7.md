Aula 7
=========

*   [Planilhas](#planilhas)
*   [SQL](#sql)
*   [IMDb](#imdb)
*   [Múltiplas tabelas](#multiple-tables)
*   [Problemas](#problems)

Planilhas
------------

*   A maioria de nós está familiarizada com planilhas, linhas de dados, em que cada coluna em uma linha tem um dado diferente que se relaciona de alguma forma.
*   Um banco de dados é um aplicativo que pode armazenar dados, e podemos pensar no Google Sheets como um desses aplicativos.
*   Por exemplo, criamos um formulário do Google para perguntar aos alunos seu programa de TV favorito e o gênero do mesmo. Procuramos pelas respostas e vemos que a planilha tem três colunas: "Timestamp", "title" e "genres":  
    ![imagem de planilha do Google Sheets com a linha 1 tendo células "Timestamp", "title" e "genres", com a linha 2 tendo células "10/28/2019 15:03:45", "Dynasty", "Drama, Family", e assim por diante](https://cs50.harvard.edu/x/2020/notes/7/spreadsheet.png)
*   Podemos baixar um arquivo CSV da planilha com "Arquivo > Download", carregá-lo em nosso IDE e ver que é um arquivo de texto com valores separados por vírgula que correspondem aos dados da planilha.
*   Escreveremos `favorites.py`:
    
        import csv
        
        with open("CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv", "r") as file:
            reader = csv.DictReader(file)
        
            for row in reader:
                print(row["title"])
        
    
    *   Apenas abriremos o arquivo e garantiremos que podemos obter o título de cada linha.
*   Agora podemos usar um dicionário para contar o número de vezes que vimos cada título, em que as chaves são os títulos e os valores para cada chave são um número inteiro, rastreando quantas vezes vimos esse título:
    
        import csv
        
        counts = {}
        
        with open("CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv", "r") as file:
            reader = csv.DictReader(file)
        
            for row in reader:
                title = row["title"]
                if title in counts:
                    counts[title] += 1
                else:
                    counts[title] = 1
        
        for title, count in counts.items():
            print(title, count, sep=" | ")
        
    
    *   Em cada linha, podemos obter o `title` com `row["title"]`.
    *   Aqui, se já tivermos visto o título antes (ele está em `counts`), podemos simplesmente adicionar 1 ao valor. Caso contrário, precisamos definir o valor inicial como 1.
    *   Por fim, podemos imprimir as chaves e valores do nosso dicionário com um separador para que seja um pouco mais fácil de ler.
*   Podemos alterar a maneira como iteramos para `for title, count in sorted(counts.items()):`, e veremos nosso dicionário ordenado pelas chaves, em ordem alfabética.
*   Mas podemos ordenar por pares chave-valor no dicionário com:
    
        def f(item):
          return item[1]
        
        for title, count in sorted(counts.items(), key=f, reverse=True):
        
    
    *   Definimos uma função, `f`, que apenas retorna o valor do `item` no dicionário com `item[1]`. A função `sorted`, por sua vez, pode usar isso como a chave para ordenar os itens do dicionário. E também passaremos `reverse=True` para classificar do maior para o menor, em vez do menor para o maior.
*   Na verdade, podemos definir nossa função na mesma linha, com esta sintaxe:
    
        for title, count in sorted(counts.items(), key=lambda item: item[1], reverse=True):
        
    
    *   Passamos uma função lambda, ou anônima, como a chave, que recebe o `item` e retorna `item[1]`.
*   Por fim, podemos transformar todos os títulos em minúsculas com `title = row["title"].lower()`, para que nossas contagens sejam um pouco mais precisas, mesmo se os nomes não forem digitados da mesma forma exata.

SQL
---

*   Vamos olhar para um novo programa na nossa janela do terminal, `sqlite3`, um programa de linha de comando que nos permite usar outra linguagem, SQL (pronuncia-se como "sequel").
*   Vamos executar alguns comandos para criar um novo banco de dados chamado `favorites.db` e importar nosso arquivo CSV para uma tabela chamada "favorites":
    
        ~/ $ sqlite3 favorites.db
        Versão SQLite 3.22.0 2018-01-22 18:45:57
        Digite ".help" para obter dicas de uso.
        sqlite> .mode csv
        sqlite> .import "CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv" favorites
        
    
*   Vemos um `favorites.db` em nosso IDE depois de executar isso, e agora podemos usar o SQL para interagir com nossos dados:
    
        sqlite> SELECT title FROM favorites;
        title
        Dynasty
        The Office
        Blindspot
        24
        Friends
        psych
        Veep
        Survivor
        ...
        
    
*   Podemos até classificar nossos resultados:
    
        sqlite> SELECT title FROM favorites ORDER BY title;
        title
        /
        24
        9009
        Adventure Time
        Airplane Repo
        Always Sunny
        Ancient Aliens
        ...
        
    
*   E obter a contagem de quantas vezes cada título aparece:
    
        sqlite> SELECT title, COUNT(title) FROM favorites GROUP BY title;
        title | COUNT(title)
        / | 1
        24 | 1
        9009 | 1
        Adventure Time | 1
        Airplane Repo | 1
        Always Sunny | 1
        Ancient Aliens | 1
        ...
        
    
*   Podemos até definir a contagem de cada título para uma nova variável, `n`, e ordenar nossos resultados por essa contagem, em ordem decrescente. Em seguida, podemos ver os 10 principais resultados com `LIMIT 10`:
    
        sqlite> SELECT title, COUNT(title) AS n FROM favorites GROUP BY title ORDER BY n DESC LIMIT 10;
        title | n
        The Office | 30
        Friends | 20
        Game of Thrones | 20
        Breaking Bad | 14
        Black Mirror | 9
        Rick and Morty | 9
        Brooklyn Nine-Nine | 5
        Game of thrones | 5
        No | 5
        Prison Break | 5
        
    
*   O SQL é uma linguagem que nos permite trabalhar com um banco de dados relacional, uma aplicação que nos permite armazenar dados e trabalhar com eles de forma mais rápida do que com um CSV.
*   Com o comando `.schema`, podemos ver como o formato para a tabela dos nossos dados é criado:
    
        sqlite> .schema
        CREATE TABLE favorites(
          "Timestamp" TEXT,
          "title" TEXT,
          "genres" TEXT
        );
        
    
*   Acontece que, ao trabalhar com dados, só precisamos de quatro operações:
    *   `CREATE` (criar)
    *   `READ` (ler)
    *   `UPDATE` (atualizar)
    *   `DELETE` (excluir)
*   No SQL, os comandos para realizar cada uma dessas operações são:
    *   `INSERT` (inserir)
    *   `SELECT` (selecionar)
    *   `UPDATE` (atualizar)
    *   `DELETE` (excluir)
*   Primeiro, precisaremos inserir uma tabela com o comando `CREATE TABLE table (column type, ...);`.
*   O SQL também possui seus próprios tipos de dados para otimizar a quantidade de espaço usado para armazenar dados:
    *   `BLOB`, para "binary large object", dados binários brutos que podem representar arquivos
    *   `INTEGER`
        *   `smallint`
        *   `integer`
        *   `bigint`
    *   `NUMERIC`
        *   `boolean`
        *   `date`
        *   `datetime`
        *   `numeric(scale,precision)`, que resolve a imprecisão de ponto flutuante usando quantos bits forem necessários, para cada dígito antes e depois do ponto decimal
        *   `time`
        *   `timestamp`
    *   `REAL`
        *   `real`, para valores de ponto flutuante
        *   `double precision`, com mais bits
    *   `TEXT`
        *   `char(n)`, para um número exato de caracteres
        *   `varchar(n)`, para um número variável de caracteres, até um limite específico
        *   `text`
*   O SQLite é um aplicativo de banco de dados que suporta SQL, e existem muitas empresas com aplicativos de servidor que suportam SQL, incluindo Oracle Database, MySQL, PostgreSQL, MariaDB e Microsoft Access.
*   Depois de inserir valores, podemos usar funções para realizar cálculos também:
    *   `AVG` (média)
    *   `COUNT` (contagem)
    *   `DISTINCT`, para obter valores distintos sem duplicatas
    *   `MAX` (máximo)
    *   `MIN` (mínimo)
    *   ...
*   Também existem outras operações que podemos combinar conforme necessário:
    *   `WHERE`, para corresponder a uma condição rigorosa
    *   `LIKE`, para corresponder a substrings em texto
    *   `LIMIT` (limite)
    *   `GROUP BY`, para agrupar por
    *   `ORDER BY`, para ordenar por
    *   `JOIN`, para combinar dados de várias tabelas
*   Podemos atualizar os dados com `UPDATE table SET column=value WHERE condition;`, que pode incluir 0, 1 ou mais linhas dependendo da nossa condição. Por exemplo, podemos dizer `UPDATE favorites SET title = "The Office" WHERE title LIKE "%office"`, e isso definirá todas as linhas com o título contendo "office" como "The Office" para torná-las consistentes.
*   E podemos remover as linhas correspondentes com `DELETE FROM table WHERE condition;`, como em `DELETE FROM favorites WHERE title = "Friends";`.
*   Podemos até excluir a tabela inteira com outro comando, `DROP`.

IMDb
----

*   O IMDb, ou "Internet Movie Database", tem conjuntos de dados [disponíveis para download](https://www.imdb.com/interfaces/) como arquivos de valores separados por tabulação (TSV).
*   Por exemplo, podemos baixar `title.basics.tsv.gz`, que conterá dados básicos sobre os títulos:
    *   `tconst`, um identificador único para cada título, como `tt4786824`
    *   `titleType`, o tipo de título, como `tvSeries`
    *   `primaryTitle`, o título principal usado, como `The Crown`
    *   `startYear`, o ano de lançamento do título, como `2016`
    *   `genres`, uma lista separada por vírgulas de gêneros, como `Drama,History`
*   Vamos dar uma olhada em `title.basics.tsv` depois de descompactá-lo e vemos que as primeiras linhas são realmente os cabeçalhos que esperávamos e cada linha possui valores separados por tabulação. Mas o arquivo tem mais de 6 milhões de linhas, então mesmo a busca por um valor leva um momento.
*   Vamos baixar o arquivo para o nosso IDE com `wget` e, em seguida, descompactá-lo com `gunzip`. Mas nosso IDE não tem espaço suficiente, então vamos usar o terminal do nosso Mac em vez disso.
*   Vamos escrever `import.py` para ler o arquivo:
    
        import csv
        
        # Abre arquivo TSV para leitura
        with open("title.basics.tsv", "r") as titles:
        
            # Como o arquivo é um arquivo TSV, podemos usar o leitor de CSV e alterar
            # o separador para uma tabulação.
            reader = csv.DictReader(titles, delimiter="\t")
        
            # Abre novo arquivo CSV para escrita
            with open("shows0.csv", "w") as shows:
        
                # Cria escritor
                writer = csv.writer(shows)
        
                # Escreve o cabeçalho das colunas que queremos
                writer.writerow(["tconst", "primaryTitle", "startYear", "genres"])
        
                # Percorre o arquivo TSV
                for row in reader:
        
                    # Se for uma série de TV para adultos
                    if row["titleType"] == "tvSeries" and row["isAdult"] == "0":
        
                        # Escreve a linha
                        writer.writerow([row["tconst"], row["primaryTitle"], row["startYear"], row["genres"]])
        
    
*   Agora, podemos abrir `shows0.csv` e ver um conjunto menor de dados. Mas acontece que, para algumas linhas, `startYear` tem um valor de `\N`, e esse é um valor especial do IMDb quando eles querem representar valores ausentes. Portanto, podemos filtrar esses valores e converter o `startYear` em um número inteiro para filtrar por programas após 1970:
    
        ...
        # Se o ano não estiver ausente (precisamos escapar a barra invertida também)
        if row["startYear"] != "\\N":
        
            # Se a partir de 1970
            if int(row["startYear"]) >= 1970:
        
                # Escreve a linha
                writer.writerow([row["tconst"], row["primaryTitle"], row["startYear"], row["genres"]])
        
    
*   Podemos escrever um programa para pesquisar por um título específico:
    
        import csv
        
        # Solicita ao usuário o título
        title = input("Título: ")
        
        # Abre arquivo CSV
        with open("shows2.csv", "r") as input:
        
            # Cria DictReader
            reader = csv.DictReader(input)
        
            # Percorre o arquivo CSV
            for row in reader:
        
                # Procura pelo título
                if title.lower() == row["primaryTitle"].lower():
                    print(row["primaryTitle"], row["startYear"], row["genres"], sep=" | ")
        
    
    *   Podemos executar esse programa e ver nossos resultados, mas podemos ver como o SQL pode fazer um trabalho melhor.
*   Em Python, podemos nos conectar a um banco de dados SQL e ler nosso arquivo nele uma vez, para que possamos fazer muitas consultas sem escrever novos programas e sem ter que ler o arquivo inteiro a cada vez.
*   Vamos fazer isso mais facilmente com a biblioteca CS50:
    
        import cs50
        import csv
        
        # Cria o banco de dados abrindo e fechando primeiro um arquivo vazio
        open(f"shows3.db", "w").close()
        db = cs50.SQL("sqlite:///shows3.db")
        
        # Cria uma tabela chamada `shows`, e especifica as colunas desejadas,
        # todas serão do tipo texto, exceto `startYear`
        db.execute("CREATE TABLE shows (tconst TEXT, primaryTitle TEXT, startYear NUMERIC, genres TEXT)")
        
        # Abre arquivo TSV
        # https://datasets.imdbws.com/title.basics.tsv.gz
        with open("title.basics.tsv", "r") as titles:
        
            # Cria DictReader
            reader = csv.DictReader(titles, delimiter="\t")
        
            # Percorre o arquivo TSV
            for row in reader:
        
                # Se for uma série de TV para adultos
                if row["titleType"] == "tvSeries" and row["isAdult"] == "0":
        
                    # Se o ano não estiver ausente
                    if row["startYear"] != "\\N":
        
                        # Se a partir de 1970
                        startYear = int(row["startYear"])
                        if startYear >= 1970:
        
                            # Insere o programa substituindo os valores em cada espaço reservado(?)
                            db.execute("INSERT INTO shows (tconst, primaryTitle, startYear, genres) VALUES(?, ?, ?, ?)",
                                       row["tconst"], row["primaryTitle"], startYear, genres)
        
    
*   Agora podemos executar `sqlite3 shows3.db` e executar comandos como antes, como `SELECT * FROM shows LIMIT 10;`.
*   Com `SELECT COUNT(*) FROM shows;` podemos ver que existem mais de 150.000 programas em nossa tabela, e com `SELECT COUNT(*) FROM shows WHERE startYear = 2019;`, vemos que houve mais de 6000 este ano.

Várias tabelas
--------------

*   Mas cada uma das linhas terá apenas uma coluna para gêneros, e os valores serão múltiplos gêneros juntos. Portanto, podemos voltar para nosso programa de importação e adicionar outra tabela:
    
        import cs50
        import csv
        
        # Criar o banco de dados
        open(f"shows4.db", "w").close()
        db = cs50.SQL("sqlite:///shows4.db")
        
        # Criar as tabelas
        db.execute("CREATE TABLE shows (id INT, title TEXT, year NUMERIC, PRIMARY KEY(id))")
        
        # A tabela `genres` terá uma coluna chamada `show_id` que faz referência
        # à tabela `shows` acima
        db.execute("CREATE TABLE genres (show_id INT, genre TEXT, FOREIGN KEY(show_id) REFERENCES shows(id))")
        
        # Abrir o arquivo TSV
        # https://datasets.imdbws.com/title.basics.tsv.gz
        with open("title.basics.tsv", "r") as titles:
        
            # Criar o DictReader
            reader = csv.DictReader(titles, delimiter="\t")
        
            # Percorrer o arquivo TSV
            for row in reader:
        
                # Se for uma série de TV não para adultos
                if row["titleType"] == "tvSeries" and row["isAdult"] == "0":
        
                    # Se tiver um ano definido
                    if row["startYear"] != "\\N":
        
                        # Se for a partir de 1970
                        startYear = int(row["startYear"])
                        if startYear >= 1970:
        
                            # Remover o prefixo de tconst
                            id = int(row["tconst"][2:])
        
                            # Inserir o show
                            db.execute("INSERT INTO shows (id, title, year) VALUES(?, ?, ?)", id, row["primaryTitle"], startYear)
        
                            # Inserir os gêneros
                            if row["genres"] != "\\N":
                                for genre in row["genres"].split(","):
                                    db.execute("INSERT INTO genres (show_id, genre) VALUES(?, ?)", id, genre)
        
    
    *   Agora, nossa tabela `shows` não possui mais uma coluna `genres`, mas em vez disso, temos uma tabela `genres` em que cada linha representa um show e um gênero associado. Agora, um show específico pode ter vários gêneros que podemos pesquisar, e podemos obter outros dados sobre o show na tabela `shows` usando seu ID.'

*   Na verdade, podemos combinar ambas as tabelas com `SELECT * FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") AND year = 2019;`. Estamos filtrando nossa tabela `shows` pelos IDs em que o ID na tabela `genres` tem um valor de "Comedy" para a coluna `genre`, e tem o valor de 2019 para a coluna `year`.
*   Nossas tabelas têm a seguinte aparência:  
    ![tabela rotulada shows com entradas id, title e year, e tabela rotulada genres com show_id e genre e seta de show_id para id](https://cs50.harvard.edu/x/2020/notes/7/shows_table_genres_table.png)
    *   Como o ID na tabela `genre` vem da tabela `shows`, o chamamos de `show_id`. E a seta indica que um único ID do show pode ter várias linhas correspondentes na tabela `genres`.
*   Vemos que alguns conjuntos de dados do IMDb, como `title.principals.tsv`, possuem apenas IDs para certas colunas que teremos que procurar em outras tabelas.
*   Ao ler as descrições de cada tabela, podemos ver que todos os dados podem ser usados para construir essas tabelas:  
    ![tabela rotulada people, shows, genres, ratings, stars, writers com setas indicando IDs entre tabelas](https://cs50.harvard.edu/x/2020/notes/7/imdb_tables.png)
    *   Observe que, por exemplo, o nome de uma pessoa também poderia ser copiado para as tabelas `stars` ou `writers`, mas em vez disso, apenas o `person_id` é usado para vincular aos dados na tabela `people`. Dessa forma, só precisamos atualizar o nome em um único local se precisarmos fazer uma alteração.
*   Vamos abrir um banco de dados, `shows.db`, com essas tabelas para analisar mais exemplos.
*   Vamos baixar um programa chamado [DB Browser for SQLite](https://sqlitebrowser.org/dl/), que terá uma interface gráfica do usuário para navegar por nossas tabelas e dados. Podemos usar a guia "Execute SQL" para executar SQL diretamente no programa também.
*   Podemos executar `SELECT * FROM shows JOIN genres ON show.id = genres.show_id;` para combinar duas tabelas correspondendo os IDs nas colunas que especificamos. Em seguida, receberemos uma tabela mais ampla, com colunas de cada uma dessas duas tabelas.
*   Podemos pegar o ID de uma pessoa e encontrá-la em shows com `SELECT * FROM stars WHERE person_id = 1122;`, mas podemos fazer uma consulta dentro da nossa consulta com `SELECT show_id FROM stars WHERE person_id = (SELECT id FROM people WHERE name = "Ellen DeGeneres");`.
*   Isso nos retorna o `show_id`, então para obter os dados do show podemos executar: `SELECT * FROM shows WHERE id IN (...);` com `...` sendo a consulta acima.
*   Podemos obter os mesmos resultados com:

        SELECT title FROM
        people JOIN stars ON people.id = stars.person_id JOIN
        shows ON stars.show_id = shows.id
        WHERE name = "Ellen DeGeneres"
        
    
    *   Unimos a tabela `people` com a tabela `stars`, e depois com a tabela `shows` especificando as colunas que devem corresponder entre as tabelas, e em seguida selecionando apenas o `title` com um filtro no nome.
    *   Mas agora podemos selecionar outros campos de nossas tabelas combinadas também.
*   Acontece que podemos especificar colunas de nossas tabelas para serem tipos especiais, como:
    *   `PRIMARY KEY`, usado como identificador principal para uma linha
    *   `FOREIGN KEY`, que aponta para uma linha em outra tabela
    *   `UNIQUE`, que significa que deve ser único nesta tabela
    *   `INDEX`, que solicita ao nosso banco de dados para criar um índice para consultar mais rapidamente com base nesta coluna. Um índice é uma estrutura de dados como uma árvore, que nos ajuda a pesquisar por valores.
*   Podemos criar um índice com `CREATE INDEX person_index ON stars (person_id);`. Em seguida, a coluna `person_id` terá um índice chamado `person_index`. Com os índices corretos, nossa consulta de junção é várias vezes mais rápida.

Problemas
--------

*   Um problema com bancos de dados são as **condições de corrida**, onde o tempo de duas ações ou eventos causa um comportamento inesperado.
*   Por exemplo, considere dois colegas de quarto e uma geladeira compartilhada em sua república. O primeiro colega de quarto chega em casa e vê que não há leite na geladeira. Então o primeiro colega de quarto sai para a loja comprar leite, e enquanto ele está na loja, o segundo colega de quarto chega em casa, vê que não há leite e sai para outra loja comprar leite. Mais tarde, haverá duas garrafas de leite na geladeira. Deixando um bilhete, podemos resolver esse problema. Podemos até trancar a geladeira para que nosso colega de quarto não consiga verificar se há leite até que tenhamos voltado.
*   Isso pode acontecer em nosso banco de dados se tivermos algo assim:

        linhas = db.execute("SELECT likes FROM posts WHERE id=?", id);
        likes = linhas[0]["likes"]
        db.execute("UPDATE posts SET likes = ?", likes + 1);

    *   Primeiro, estamos obtendo o número de curtidas em um post com um determinado ID. Em seguida, definimos o número de curtidas como esse número mais um.
    *   Mas agora, se tivermos dois servidores web diferentes tentando adicionar uma curtida, eles podem definir o valor como o mesmo em vez de realmente adicionar uma a cada vez. Por exemplo, se houver 2 curtidas, ambos os servidores verificarão o número de curtidas, verão que há 2 e definirão o valor como 3. Uma das curtidas será perdida.
*   Para resolver isso, podemos usar transações, onde um conjunto de ações é garantido para acontecer juntas.
*   Outro problema no SQL é chamado de **ataque de injeção de SQL**, onde um adversário pode executar seus próprios comandos em nosso banco de dados.
*   Por exemplo, alguém pode tentar digitar `malan@harvard.edu'--` como seu e-mail. Se tivermos uma consulta SQL que seja uma string formatada (sem escapar ou substituir caracteres perigosos da entrada), como `f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"`, então a consulta acabará sendo `f"SELECT * FROM users WHERE username = 'malan@harvard.edu'--' AND password = '{password}'"`, que na verdade selecionará a linha onde `username = 'malan@harvard.edu'` e transformará o restante da linha em um comentário. Para evitar isso, devemos usar espaços reservados `?` para que nossa biblioteca SQL escape automaticamente as entradas do usuário.'

