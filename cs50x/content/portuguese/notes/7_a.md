Aula 7
=========

*   [Planilhas](#planilhas)
*   [SQL](#sql)
*   [IMDb](#imdb)
*   [Múltiplas tabelas](#multiple-tables)
*   [Problemas](#problems)

Planilhas
------------

*   A maioria de nós está familiarizada com planilhas, linhas de dados, em que cada coluna em uma linha tem um dado diferente que se relaciona de alguma forma.
*   Um banco de dados é um aplicativo que pode armazenar dados, e podemos pensar no Google Sheets como um desses aplicativos.
*   Por exemplo, criamos um formulário do Google para perguntar aos alunos seu programa de TV favorito e o gênero do mesmo. Procuramos pelas respostas e vemos que a planilha tem três colunas: "Timestamp", "title" e "genres":  
    ![imagem de planilha do Google Sheets com a linha 1 tendo células "Timestamp", "title" e "genres", com a linha 2 tendo células "10/28/2019 15:03:45", "Dynasty", "Drama, Family", e assim por diante](https://cs50.harvard.edu/x/2020/notes/7/spreadsheet.png)
*   Podemos baixar um arquivo CSV da planilha com "Arquivo > Download", carregá-lo em nosso IDE e ver que é um arquivo de texto com valores separados por vírgula que correspondem aos dados da planilha.
*   Escreveremos `favorites.py`:
    
        import csv
        
        with open("CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv", "r") as file:
            reader = csv.DictReader(file)
        
            for row in reader:
                print(row["title"])
        
    
    *   Apenas abriremos o arquivo e garantiremos que podemos obter o título de cada linha.
*   Agora podemos usar um dicionário para contar o número de vezes que vimos cada título, em que as chaves são os títulos e os valores para cada chave são um número inteiro, rastreando quantas vezes vimos esse título:
    
        import csv
        
        counts = {}
        
        with open("CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv", "r") as file:
            reader = csv.DictReader(file)
        
            for row in reader:
                title = row["title"]
                if title in counts:
                    counts[title] += 1
                else:
                    counts[title] = 1
        
        for title, count in counts.items():
            print(title, count, sep=" | ")
        
    
    *   Em cada linha, podemos obter o `title` com `row["title"]`.
    *   Aqui, se já tivermos visto o título antes (ele está em `counts`), podemos simplesmente adicionar 1 ao valor. Caso contrário, precisamos definir o valor inicial como 1.
    *   Por fim, podemos imprimir as chaves e valores do nosso dicionário com um separador para que seja um pouco mais fácil de ler.
*   Podemos alterar a maneira como iteramos para `for title, count in sorted(counts.items()):`, e veremos nosso dicionário ordenado pelas chaves, em ordem alfabética.
*   Mas podemos ordenar por pares chave-valor no dicionário com:
    
        def f(item):
          return item[1]
        
        for title, count in sorted(counts.items(), key=f, reverse=True):
        
    
    *   Definimos uma função, `f`, que apenas retorna o valor do `item` no dicionário com `item[1]`. A função `sorted`, por sua vez, pode usar isso como a chave para ordenar os itens do dicionário. E também passaremos `reverse=True` para classificar do maior para o menor, em vez do menor para o maior.
*   Na verdade, podemos definir nossa função na mesma linha, com esta sintaxe:
    
        for title, count in sorted(counts.items(), key=lambda item: item[1], reverse=True):
        
    
    *   Passamos uma função lambda, ou anônima, como a chave, que recebe o `item` e retorna `item[1]`.
*   Por fim, podemos transformar todos os títulos em minúsculas com `title = row["title"].lower()`, para que nossas contagens sejam um pouco mais precisas, mesmo se os nomes não forem digitados da mesma forma exata.