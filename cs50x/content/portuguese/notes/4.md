Aula 4
=========

*   [Hexadecimal](#hexadecimal)
*   [Ponteiros](#ponteiros)
*   [string](#string)
*   [Comparar e copiar](#comparar-e-copiar)
*   [valgrind](#valgrind)
*   [Swap](#swap)
*   [Layout de memória](#layout-de-memória)
*   [get\_int](#get_int)
*   [Arquivos](#arquivos)
*   [JPEG](#jpeg)

Hexadecimal
-----------

*   Na semana 0, aprendemos binário, um sistema de contagem com 0s e 1s.
*   Na semana 2, falamos sobre memória e como cada byte possui um endereço, ou identificador, para que possamos nos referir aonde nossas variáveis estão realmente armazenadas.
*   Acontece que, por convenção, os endereços de memória utilizam o sistema de contagem **hexadecimal**, no qual existem 16 dígitos, de 0 a 9 e A-F.
*   Lembre-se de que, em binário, cada dígito representava uma potência de 2:
    
        128 64 32 16  8  4  2  1
          1  1  1  1  1  1  1  1
        
    
    *   Com 8 bits, podemos contar até 255.
*   Acontece que, em hexadecimal, podemos contar perfeitamente até 8 bits binários com apenas 2 dígitos:
    
        16^1 16^0
           F    F
        
    
    *   Aqui, o `F` tem o valor de 15 em decimal, e cada lugar é uma potência de 16, então o primeiro `F` é igual a 16^1 \* 15 = 240, mais o segundo `F` com o valor de 16^0 \* 15 = 15, resultando em um total de 255.
*   E `0A` é o mesmo que 10 em decimal, e `0F` o mesmo que 15. `10` em hexadecimal seria 16, e nós diríamos "um zero em hexadecimal" em vez de "dez", se quiséssemos evitar confusão.
*   O sistema de cor RGB também convencionalmente utiliza hexadecimal para descrever a quantidade de cada cor. Por exemplo, `000000` em hexadecimal significa 0 de vermelho, verde e azul, resultando na cor preta. E `FF0000` seria 255, ou o máximo possível, de vermelho. Com valores diferentes para cada cor, podemos representar milhões de cores diferentes.
*   Na escrita, também podemos indicar que um valor está em hexadecimal prefixando-o com `0x`, como em `0x10`, onde o valor é igual a 16 em decimal, ao invés de 10.

Ponteiros
--------

*   Podemos criar um valor `n` e imprimi-lo:
    
        #include <stdio.h>
        
        int main(void)
        {
            int n = 50;
            printf("%i\n", n);
        }
        
    
*   Na memória do nosso computador, agora existem 4 bytes em algum lugar que possuem o valor binário de 50, rotulados como `n`:  
    ![grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno n embaixo](https://cs50.harvard.edu/x/2020/notes/4/n.png)
*   Acontece que, dos bilhões de bytes na memória, esses bytes para a variável `n` começam em algum endereço único que pode se parecer com `0x12345678`.
*   Em C, na verdade podemos ver o endereço com o operador `&`, que significa "obter o endereço desta variável":
    
        #include <stdio.h>
        
        int main(void)
        {
            int n = 50;
            printf("%p\n", &n);
        }
        
    
    *   E no CS50 IDE, podemos ver um endereço como `0x7ffe00b3adbc`, onde este é um local específico na memória do servidor.
*   O endereço de uma variável é chamado de **ponteiro**, que podemos pensar como um valor que "aponta" para uma localização na memória. O operador `*` permite que "vamos para" a localização apontada por um ponteiro.
*   Por exemplo, podemos imprimir `*&n`, onde "vamos para" o endereço de `n`, e isso imprimirá o valor de `n`, `50`, já que esse é o valor no endereço de `n`:
    
        #include <stdio.h>
        
        int main(void)
        {
            int n = 50;
            printf("%i\n", *&n);
        }
        
    
*   Também precisamos usar o operador `*` (de uma forma infelizmente confusa) para declarar uma variável que queremos que seja um ponteiro:
    
        #include <stdio.h>
        
        int main(void)
        {
           int n = 50;
           int *p = &n;
           printf("%p\n", p);
        }
        
    
    *   Aqui, usamos `int *p` para declarar uma variável, `p`, que possui o tipo `*`, um ponteiro, para um valor do tipo `int`, um inteiro. Em seguida, podemos imprimir seu valor (algo como `0x12345678`), ou imprimir o valor em seu local com `printf("%i\n", *p);`.
*   Na memória do nosso computador, as variáveis poderiam ser assim:  
    ![grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno 0x12345678 embaixo, e oito caixas juntas contendo 0x12345678 com um pequeno p embaixo](https://cs50.harvard.edu/x/2020/notes/4/p.png)
    *   Temos um ponteiro, `p`, com o endereço de alguma variável.
*   Podemos abstrair o valor real dos endereços agora, já que eles serão diferentes conforme declaramos variáveis em nossos programas, e simplismente pensar em `p` como "apontando para" algum valor:  
    ![uma caixa contendo p apontando para uma caixa menor contendo 50](https://cs50.harvard.edu/x/2020/notes/4/pointing.png)
*   Digamos que temos uma caixa de correio rotulada como "123", com o número "50" dentro dela. A caixa de correio seria `int n`, já que armazena um inteiro. Poderíamos ter outra caixa de correio com o endereço "456", dentro da qual está o valor "123", que é o endereço de nossa outra caixa de correio. Isso seria `int *p`, já que é um ponteiro para um inteiro.
*   Com a capacidade de usar ponteiros, podemos criar diferentes estruturas de dados, ou diferentes maneiras de organizar os dados na memória que veremos na próxima semana.
*   Muitos sistemas de computador modernos são "64 bits", o que significa que eles usam 64 bits para endereçar a memória, então um ponteiro será de 8 bytes, o dobro de um inteiro de 4 bytes.

string
------

*   Podemos ter uma variável `string s` para um nome como `EMMA` e ser capaz de acessar cada caractere com `s[0]` e assim por diante:
    ![caixas lado a lado, contendo: E rotulado como s[0], M rotulado como s[1], M rotulado como s[2], A rotulado como s[3], \0 rotulado como s[4]](https://cs50.harvard.edu/x/2020/notes/4/s_array.png)
*   Mas acontece que cada caractere é armazenado na memória em um byte com algum endereço, e `s` é na verdade apenas um ponteiro com o endereço do primeiro caractere:
    ![caixa contendo 0x123 rotulado como s, caixas lado a lado contendo E rotulado como 0x123, M rotulado como 0x124, M rotulado como 0x125, A rotulado como 0x126, \0 rotulado como 0x127](https://cs50.harvard.edu/x/2020/notes/4/s_pointer.png)
*   E como `s` é apenas um ponteiro para o início, apenas o `\0` indica o fim da string.
*   Na verdade, a Biblioteca CS50 define uma `string` com `typedef char *string`, o que significa apenas que queremos nomear um novo tipo, `string`, como um `char *`, ou um ponteiro para um caractere.
*   Vamos imprimir uma string:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string s = "EMMA";
            printf("%s\n", s);
        }
        
    
*   Isso é familiar, mas podemos apenas dizer:
    
        #include <stdio.h>
        
        int main(void)
        {
            char *s = "EMMA";
            printf("%s\n", s);
        }
        
    
    *   Isso também imprimirá `EMMA`.
*   Com `printf("%p\n", s);`, podemos imprimir `s` como seu valor como um ponteiro, como `0x42ab52`. (`printf` sabe acessar o endereço e imprimir a string inteira quando usamos `%s` e passamos `s`, mesmo `s` apontando apenas para o primeiro caractere.)
*   Também podemos tentar `printf("%p\n", &s[0]);`, que é o endereço do primeiro caractere de `s` e é exatamente o mesmo que imprimir `s`. E imprimir `&s[1]`, `&s[2]` e `&s[3]` nos dá os endereços que são os próximos caracteres na memória após `&s[0]`, como `0x42ab53`, `0x42ab54` e `0x42ab55`, exatamente um byte após o outro.
*   E finalmente, se tentarmos `printf("%c\n", *s);`, obtemos um único caractere `E`, pois estamos acessando o endereço armazenado em `s`, que é o primeiro caractere da string.
*   Na verdade, `s[0]`, `s[1]` e `s[2]` mapeiam diretamente para `*s`, `*(s+1)` e `*(s+2)`, já que cada um dos próximos caracteres está no endereço do próximo byte.

Compare e copie
----------------

*   Vamos olhar para `compare0`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Obter dois inteiros
            int i = get_int("i: ");
            int j = get_int("j: ");
        
            // Comparar inteiros
            if (i == j)
            {
                printf("Iguais\n");
            }
            else
            {
                printf("Diferentes\n");
            }
        }
        
    
    *   Podemos compilar e executar isso, e nosso programa funciona como esperado, com os mesmos valores dos dois inteiros nos dando "Iguais" e valores diferentes "Diferentes".
*   Em `compare1`, vemos que os mesmos valores de string fazem com que nosso programa imprima "Diferentes":
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Obter duas strings
            string s = get_string("s: ");
            string t = get_string("t: ");
        
            // Comparar endereços das strings
            if (s == t)
            {
                printf("Iguais\n");
            }
            else
            {
                printf("Diferentes\n");
            }
        }
        
    
    *   Com base no que sabemos agora sobre strings, isso faz sentido porque cada variável "string" está apontando para uma localização diferente na memória, onde o primeiro caractere de cada string está armazenado. Portanto, mesmo que os valores das strings sejam os mesmos, isso sempre imprimirá "Diferentes".
    *   Por exemplo, nossa primeira string pode estar no endereço 0x123, nossa segunda pode estar no 0x456, e `s` será `0x123` e `t` será `0x456`, então esses valores serão diferentes.
    *   E `get_string`, durante todo esse tempo, estava retornando apenas um `char *`, ou seja, um ponteiro para o primeiro caractere de uma string do usuário.
*   Agora vamos tentar copiar uma string:
    
        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        
        int main(void)
        {
            string s = get_string("s: ");
        
            string t = s;
        
            t[0] = toupper(t[0]);
        
            // Imprimir string duas vezes
            printf("s: %s\n", s);
            printf("t: %s\n", t);
        }
        
    
    *   Obtemos uma string `s` e copiamos o valor de `s` para `t`. Em seguida, capitalizamos a primeira letra em `t`.
    *   Mas quando executamos nosso programa, vemos que tanto `s` quanto `t` estão agora capitalizados.
    *   Como definimos `s` e `t` com os mesmos valores, eles são na verdade ponteiros para o mesmo caractere, então capitalizamos o mesmo caractere!
*   Para realmente fazer uma cópia de uma string, temos que fazer um pouco mais de trabalho:
    
        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            char *s = get_string("s: ");
        
            char *t = malloc(strlen(s) + 1);
        
            for (int i = 0, n = strlen(s); i < n + 1; i++)
            {
                t[i] = s[i];
            }
        
            t[0] = toupper(t[0]);
        
            printf("s: %s\n", s);
            printf("t: %s\n", t);
        }
        
    
    *   Criamos uma nova variável, `t`, do tipo `char *`, com `char *t`. Agora, queremos apontá-la para um novo bloco de memória grande o suficiente para armazenar a cópia da string. Com `malloc`, podemos alocar algum número de bytes na memória (que não estejam sendo usados para armazenar outros valores) e passamos o número de bytes que queremos. Já conhecemos o comprimento de `s`, então adicionamos 1 para o caractere nulo terminador. Portanto, nossa última linha de código é `char *t = malloc(strlen(s) + 1);`.
    *   Em seguida, copiamos cada caractere, um de cada vez, e agora podemos capitalizar apenas a primeira letra de `t`. E usamos `i < n + 1`, pois queremos ir até `n`, para garantir que copiamos o caractere terminador da string.
    *   Na verdade, podemos usar também a função de biblioteca `strcpy` com `strcpy(t, s)` em vez do nosso loop, para copiar a string `s` para `t`. Para ficar claro, o conceito de "string" vem da linguagem C e é bem suportado; as únicas "rodinhas de treinamento" do CS50 são o tipo `string` em vez de `char *` e a função `get_string`.
*   Se não copiarmos o caractere nulo terminador, `\0`, e tentarmos imprimir nossa string `t`, `printf` continuará e imprimirá os valores desconhecidos ou lixo que temos na memória, até chegar a um `\0` ou travar completamente, pois nosso programa pode acabar tentando ler memória que não pertence a ele!

valgrind
--------

*   Descobre-se que, após terminarmos de usar a memória alocada com `malloc`, devemos chamar `free` (como em `free(t)`), que informa ao computador que aqueles bytes não são mais úteis para nosso programa, então esses bytes na memória podem ser reutilizados novamente.
*   Se continuarmos executando nosso programa e alocando memória com `malloc`, mas nunca liberando a memória após terminarmos de usá-la, teremos um **vazamento de memória**, que deixará nosso computador mais lento e consumirá cada vez mais memória até que nosso computador fique sem memória.
*   `valgrind` é uma ferramenta de linha de comando que podemos usar para executar nosso programa e verificar se ele tem vazamentos de memória. Podemos executar o valgrind em nosso programa acima com `help50 valgrind ./copy` e ver, a partir da mensagem de erro, que na linha 10 alocamos memória que nunca foi liberada (ou "perdida").
*   Então, no final, podemos adicionar uma linha `free(t)`, que não alterará o funcionamento do nosso programa, mas eliminará os erros do valgrind.
*   Vamos dar uma olhada no arquivo `memory.c`:

        // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare
        
        #include <stdlib.h>
        
        void f(void)
        {
            int *x = malloc(10 * sizeof(int));
            x[10] = 0;
        }
        
        int main(void)
        {
            f();
            return 0;
        }
        
    
    *   Este é um exemplo da documentação do valgrind (valgrind é uma ferramenta real, enquanto o help50 foi escrito especificamente para nos ajudar neste curso).
    *   A função `f` aloca memória suficiente para 10 inteiros e armazena o endereço em um ponteiro chamado `x`. Em seguida, tentamos definir o valor do 11º elemento de `x` com `x[10]` como `0`, o que ultrapassa o tamanho do array de memória alocado para nosso programa. Isso é chamado de **buffer overflow**, onde ultrapassamos os limites do buffer ou array e acessamos a memória desconhecida.
*   O valgrind também nos informará que existe uma "Escrita inválida de tamanho 4" na linha 8, onde de fato estamos tentando alterar o valor de um inteiro (de tamanho 4 bytes).
*   E durante todo esse tempo, a Biblioteca CS50 tem liberado a memória alocada em `get_string` quando nosso programa termina!

Swap
----

*   Temos duas bebidas de cores diferentes, roxo e verde, cada uma em um copo. Queremos trocar as bebidas entre os dois copos, mas não podemos fazer isso sem um terceiro copo para despejar uma das bebidas primeiro.
*   Agora, digamos que queiramos trocar os valores de dois inteiros.
    
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
        
    
    *   Com uma terceira variável para usar como espaço de armazenamento temporário, podemos fazer isso facilmente, colocando `a` em `tmp`, depois `b` em `a` e, finalmente, o valor original de `a`, agora em `tmp`, em `b`.
*   Mas, se tentarmos usar essa função em um programa, não veremos nenhuma mudança:
    
        #include <stdio.h>
        
        void swap(int a, int b);
        
        int main(void)
        {
            int x = 1;
            int y = 2;
        
            printf("x é %i, y é %i\n", x, y);
            swap(x, y);
            printf("x é %i, y é %i\n", x, y);
        }
        
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
        
    
    *   Acontece que a função `swap` recebe suas próprias variáveis, `a` e `b`, quando são passadas, que são cópias de `x` e `y`, portanto, alterar esses valores não altera `x` e `y` na função `main`.

Layout de Memória
-------------

*   Dentro da memória do nosso computador, os diferentes tipos de dados que precisam ser armazenados para o nosso programa são organizados em diferentes seções:
    ![Grade com seções, de cima para baixo: código de máquina, globais, heap (com seta apontando para baixo), stack (com seta apontando para cima)](https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png)
    *   A seção _código de máquina_ é o código binário do nosso programa compilado. Quando executamos nosso programa, esse código é carregado no "topo" da memória.
    *   _Globais_ são variáveis globais que declaramos em nosso programa ou outras variáveis compartilhadas que todo o nosso programa pode acessar.
    *   A seção _heap_ é uma área vazia onde o `malloc` pode obter memória livre para o nosso programa usar.
    *   A seção _stack_ é usada pelas funções em nosso programa conforme elas são chamadas. Por exemplo, nossa função `main` está na parte inferior da stack e possui as variáveis locais `x` e `y`. A função `swap`, quando chamada, tem seu próprio quadro, ou "fatia", de memória que está no topo do quadro de `main`, com as variáveis locais `a`, `b` e `tmp`:
        ![Seção da stack com (a, b, tmp) acima de (x, y)](https://cs50.harvard.edu/x/2020/notes/4/stack.png)
        *   Uma vez que a função `swap` retorna, a memória que ela estava usando é liberada para a próxima chamada de função, e perdemos qualquer coisa que fizemos, exceto os valores de retorno, e nosso programa volta para a função que chamou `swap`.
        *   Portanto, ao passar os endereços de `x` e `y` de `main` para `swap`, podemos alterar os valores de `x` e `y`: ![Seção da stack com (a, b, tmp) acima de (x, y), e a apontando para x e b apontando para y](https://cs50.harvard.edu/x/2020/notes/4/pointers.png)
*   Ao passar o endereço de `x` e `y`, nossa função `swap` pode realmente funcionar:

    #include <stdio.h>
    
    void swap(int *a, int *b);
    
    int main(void)
    {
        int x = 1;
        int y = 2;
    
        printf("x é %i, y é %i\n", x, y);
        swap(&x, &y);
        printf("x é %i, y é %i\n", x, y);
    }
    
    void swap(int *a, int *b)
    {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
    

    *   Os endereços de `x` e `y` são passados de `main` para `swap`, e usamos a sintaxe `int *a` para declarar que nossa função `swap` recebe ponteiros. Salvamos o valor de `x` em `tmp` seguindo o ponteiro `a`, então pegamos o valor de `y` seguindo o ponteiro `b` e armazenamos isso no local para onde `a` está apontando (`x`). Por fim, armazenamos o valor de `tmp` no local apontado por `b` (`y`), e estamos prontos.
*   Se chamarmos `malloc` muitas vezes, teremos um **estouro do heap**, onde ultrapassamos o tamanho do heap. Ou, se tivermos muitas funções sendo chamadas, teremos um **estouro da stack**, onde nossa stack tem muitos quadros de memória alocados também. E esses dois tipos de estouro geralmente são conhecidos como estouros de buffer, após os quais nosso programa (ou computador inteiro) pode travar.

get\_int
--------

*   Podemos implementar `get_int` nós mesmos com uma função da biblioteca C, `scanf`:

    #include <stdio.h>
    
    int main(void)
    {
        int x;
        printf("x: ");
        scanf("%i", &x);
        printf("x: %i\n", x);
    }
    

    *   `scanf` recebe um formato, `%i`, então a entrada é "escaneada" para esse formato e o endereço na memória onde queremos que essa entrada vá. Mas `scanf` não possui muita verificação de erros, então talvez não obtenhamos um número inteiro.
*   Podemos tentar obter uma string da mesma maneira:

    #include <stdio.h>
    
    int main(void)
    {
        char *s = NULL;
        printf("s: ");
        scanf("%s", s);
        printf("s: %s\n", s);
    }
    

    *   Mas na verdade não alocamos nenhuma memória para `s` (`s` é `NULL`, ou não está apontando para nada), então talvez queiramos chamar `char s[5]` para alocar um array de 5 caracteres para nossa string. Em seguida, `s` será tratado como um ponteiro em `scanf` e `printf`.
    *   Agora, se o usuário digitar uma string com comprimento igual ou menor que 4, nosso programa funcionará com segurança. Mas se o usuário digitar uma string mais longa, `scanf` pode estar tentando escrever além do final de nosso array em memória desconhecida, causando o travamento de nosso programa.

Arquivos
-----

*   Com a capacidade de usar ponteiros, também podemos abrir arquivos:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            // Abre o arquivo
            FILE *file = fopen("agenda.csv", "a");
        
            // Obtém strings do usuário
            char *nome = get_string("Nome: ");
            char *numero = get_string("Número: ");
        
            // Escreve as strings no arquivo
            fprintf(file, "%s,%s\n", nome, numero);
        
            // Fecha o arquivo
            fclose(file);
        }
        
    
    *   `fopen` é uma nova função que podemos usar para abrir um arquivo. Ela retornará um ponteiro para um novo tipo, `FILE`, que podemos ler e escrever. O primeiro argumento é o nome do arquivo e o segundo argumento é o modo que queremos abrir o arquivo (`r` para ler, `w` para escrever e `a` para acrescentar, ou adicionar).
    *   Depois de obtermos algumas strings, podemos usar `fprintf` para escrever no arquivo.
    *   Por fim, fechamos o arquivo com `fclose`.
*   Agora podemos criar nossos próprios arquivos CSV, arquivos de valores separados por vírgula (como uma mini-planilha), de forma programática.

JPEG
====

*   Também podemos criar um programa que abre um arquivo e nos informa se é um arquivo JPEG (imagem):
    
        #include <stdio.h>
        
        int main(int argc, char *argv[])
        {
            // Verifica o uso
            if (argc != 2)
            {
                return 1;
            }
        
            // Abre o arquivo
            FILE *file = fopen(argv[1], "r");
            if (!file)
            {
                return 1;
            }
        
            // Lê os primeiros três bytes
            unsigned char bytes[3];
            fread(bytes, 3, 1, file);
        
            // Verifica os primeiros três bytes
            if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
            {
                printf("Talvez\n");
            }
            else
            {
                printf("Não\n");
            }
        
            // Fecha o arquivo
            fclose(file);
        }
        
    
    *   Agora, se executarmos esse programa com `./jpeg brian.jpg`, nosso programa tentará abrir o arquivo especificado (verificando se realmente obtivemos um arquivo não nulo) e ler os primeiros três bytes do arquivo com `fread`.
    *   Podemos comparar os primeiros três bytes (em hexadecimal) com os três bytes necessários para iniciar um arquivo JPEG. Se forem iguais, então nosso arquivo provavelmente é um arquivo JPEG (embora outros tipos de arquivos ainda possam começar com esses bytes). Mas, se eles não forem iguais, sabemos que definitivamente não é um arquivo JPEG.
*   Podemos usar essas habilidades para ler e escrever arquivos, em particular imagens, e modificá-los alterando os bytes neles, no conjunto de problemas desta semana!

