*   Na verdade, podemos combinar ambas as tabelas com `SELECT * FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") AND year = 2019;`. Estamos filtrando nossa tabela `shows` pelos IDs em que o ID na tabela `genres` tem um valor de "Comedy" para a coluna `genre`, e tem o valor de 2019 para a coluna `year`.
*   Nossas tabelas têm a seguinte aparência:  
    ![tabela rotulada shows com entradas id, title e year, e tabela rotulada genres com show_id e genre e seta de show_id para id](https://cs50.harvard.edu/x/2020/notes/7/shows_table_genres_table.png)
    *   Como o ID na tabela `genre` vem da tabela `shows`, o chamamos de `show_id`. E a seta indica que um único ID do show pode ter várias linhas correspondentes na tabela `genres`.
*   Vemos que alguns conjuntos de dados do IMDb, como `title.principals.tsv`, possuem apenas IDs para certas colunas que teremos que procurar em outras tabelas.
*   Ao ler as descrições de cada tabela, podemos ver que todos os dados podem ser usados para construir essas tabelas:  
    ![tabela rotulada people, shows, genres, ratings, stars, writers com setas indicando IDs entre tabelas](https://cs50.harvard.edu/x/2020/notes/7/imdb_tables.png)
    *   Observe que, por exemplo, o nome de uma pessoa também poderia ser copiado para as tabelas `stars` ou `writers`, mas em vez disso, apenas o `person_id` é usado para vincular aos dados na tabela `people`. Dessa forma, só precisamos atualizar o nome em um único local se precisarmos fazer uma alteração.
*   Vamos abrir um banco de dados, `shows.db`, com essas tabelas para analisar mais exemplos.
*   Vamos baixar um programa chamado [DB Browser for SQLite](https://sqlitebrowser.org/dl/), que terá uma interface gráfica do usuário para navegar por nossas tabelas e dados. Podemos usar a guia "Execute SQL" para executar SQL diretamente no programa também.
*   Podemos executar `SELECT * FROM shows JOIN genres ON show.id = genres.show_id;` para combinar duas tabelas correspondendo os IDs nas colunas que especificamos. Em seguida, receberemos uma tabela mais ampla, com colunas de cada uma dessas duas tabelas.
*   Podemos pegar o ID de uma pessoa e encontrá-la em shows com `SELECT * FROM stars WHERE person_id = 1122;`, mas podemos fazer uma consulta dentro da nossa consulta com `SELECT show_id FROM stars WHERE person_id = (SELECT id FROM people WHERE name = "Ellen DeGeneres");`.
*   Isso nos retorna o `show_id`, então para obter os dados do show podemos executar: `SELECT * FROM shows WHERE id IN (...);` com `...` sendo a consulta acima.
*   Podemos obter os mesmos resultados com:

        SELECT title FROM
        people JOIN stars ON people.id = stars.person_id JOIN
        shows ON stars.show_id = shows.id
        WHERE name = "Ellen DeGeneres"
        
    
    *   Unimos a tabela `people` com a tabela `stars`, e depois com a tabela `shows` especificando as colunas que devem corresponder entre as tabelas, e em seguida selecionando apenas o `title` com um filtro no nome.
    *   Mas agora podemos selecionar outros campos de nossas tabelas combinadas também.
*   Acontece que podemos especificar colunas de nossas tabelas para serem tipos especiais, como:
    *   `PRIMARY KEY`, usado como identificador principal para uma linha
    *   `FOREIGN KEY`, que aponta para uma linha em outra tabela
    *   `UNIQUE`, que significa que deve ser único nesta tabela
    *   `INDEX`, que solicita ao nosso banco de dados para criar um índice para consultar mais rapidamente com base nesta coluna. Um índice é uma estrutura de dados como uma árvore, que nos ajuda a pesquisar por valores.
*   Podemos criar um índice com `CREATE INDEX person_index ON stars (person_id);`. Em seguida, a coluna `person_id` terá um índice chamado `person_index`. Com os índices corretos, nossa consulta de junção é várias vezes mais rápida.