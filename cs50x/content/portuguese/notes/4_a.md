Aula 4
=========

*   [Hexadecimal](#hexadecimal)
*   [Ponteiros](#ponteiros)
*   [string](#string)
*   [Comparar e copiar](#comparar-e-copiar)
*   [valgrind](#valgrind)
*   [Swap](#swap)
*   [Layout de memória](#layout-de-memória)
*   [get\_int](#get_int)
*   [Arquivos](#arquivos)
*   [JPEG](#jpeg)

Hexadecimal
-----------

*   Na semana 0, aprendemos binário, um sistema de contagem com 0s e 1s.
*   Na semana 2, falamos sobre memória e como cada byte possui um endereço, ou identificador, para que possamos nos referir aonde nossas variáveis estão realmente armazenadas.
*   Acontece que, por convenção, os endereços de memória utilizam o sistema de contagem **hexadecimal**, no qual existem 16 dígitos, de 0 a 9 e A-F.
*   Lembre-se de que, em binário, cada dígito representava uma potência de 2:
    
        128 64 32 16  8  4  2  1
          1  1  1  1  1  1  1  1
        
    
    *   Com 8 bits, podemos contar até 255.
*   Acontece que, em hexadecimal, podemos contar perfeitamente até 8 bits binários com apenas 2 dígitos:
    
        16^1 16^0
           F    F
        
    
    *   Aqui, o `F` tem o valor de 15 em decimal, e cada lugar é uma potência de 16, então o primeiro `F` é igual a 16^1 \* 15 = 240, mais o segundo `F` com o valor de 16^0 \* 15 = 15, resultando em um total de 255.
*   E `0A` é o mesmo que 10 em decimal, e `0F` o mesmo que 15. `10` em hexadecimal seria 16, e nós diríamos "um zero em hexadecimal" em vez de "dez", se quiséssemos evitar confusão.
*   O sistema de cor RGB também convencionalmente utiliza hexadecimal para descrever a quantidade de cada cor. Por exemplo, `000000` em hexadecimal significa 0 de vermelho, verde e azul, resultando na cor preta. E `FF0000` seria 255, ou o máximo possível, de vermelho. Com valores diferentes para cada cor, podemos representar milhões de cores diferentes.
*   Na escrita, também podemos indicar que um valor está em hexadecimal prefixando-o com `0x`, como em `0x10`, onde o valor é igual a 16 em decimal, ao invés de 10.

Ponteiros
--------

*   Podemos criar um valor `n` e imprimi-lo:
    
        #include <stdio.h>
        
        int main(void)
        {
            int n = 50;
            printf("%i\n", n);
        }
        
    
*   Na memória do nosso computador, agora existem 4 bytes em algum lugar que possuem o valor binário de 50, rotulados como `n`:  
    ![grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno n embaixo](https://cs50.harvard.edu/x/2020/notes/4/n.png)
*   Acontece que, dos bilhões de bytes na memória, esses bytes para a variável `n` começam em algum endereço único que pode se parecer com `0x12345678`.
*   Em C, na verdade podemos ver o endereço com o operador `&`, que significa "obter o endereço desta variável":
    
        #include <stdio.h>
        
        int main(void)
        {
            int n = 50;
            printf("%p\n", &n);
        }
        
    
    *   E no CS50 IDE, podemos ver um endereço como `0x7ffe00b3adbc`, onde este é um local específico na memória do servidor.
*   O endereço de uma variável é chamado de **ponteiro**, que podemos pensar como um valor que "aponta" para uma localização na memória. O operador `*` permite que "vamos para" a localização apontada por um ponteiro.
*   Por exemplo, podemos imprimir `*&n`, onde "vamos para" o endereço de `n`, e isso imprimirá o valor de `n`, `50`, já que esse é o valor no endereço de `n`:
    
        #include <stdio.h>
        
        int main(void)
        {
            int n = 50;
            printf("%i\n", *&n);
        }
        
    
*   Também precisamos usar o operador `*` (de uma forma infelizmente confusa) para declarar uma variável que queremos que seja um ponteiro:
    
        #include <stdio.h>
        
        int main(void)
        {
           int n = 50;
           int *p = &n;
           printf("%p\n", p);
        }
        
    
    *   Aqui, usamos `int *p` para declarar uma variável, `p`, que possui o tipo `*`, um ponteiro, para um valor do tipo `int`, um inteiro. Em seguida, podemos imprimir seu valor (algo como `0x12345678`), ou imprimir o valor em seu local com `printf("%i\n", *p);`.
*   Na memória do nosso computador, as variáveis poderiam ser assim:  
    ![grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno 0x12345678 embaixo, e oito caixas juntas contendo 0x12345678 com um pequeno p embaixo](https://cs50.harvard.edu/x/2020/notes/4/p.png)
    *   Temos um ponteiro, `p`, com o endereço de alguma variável.
*   Podemos abstrair o valor real dos endereços agora, já que eles serão diferentes conforme declaramos variáveis em nossos programas, e simplismente pensar em `p` como "apontando para" algum valor:  
    ![uma caixa contendo p apontando para uma caixa menor contendo 50](https://cs50.harvard.edu/x/2020/notes/4/pointing.png)
*   Digamos que temos uma caixa de correio rotulada como "123", com o número "50" dentro dela. A caixa de correio seria `int n`, já que armazena um inteiro. Poderíamos ter outra caixa de correio com o endereço "456", dentro da qual está o valor "123", que é o endereço de nossa outra caixa de correio. Isso seria `int *p`, já que é um ponteiro para um inteiro.
*   Com a capacidade de usar ponteiros, podemos criar diferentes estruturas de dados, ou diferentes maneiras de organizar os dados na memória que veremos na próxima semana.
*   Muitos sistemas de computador modernos são "64 bits", o que significa que eles usam 64 bits para endereçar a memória, então um ponteiro será de 8 bytes, o dobro de um inteiro de 4 bytes.