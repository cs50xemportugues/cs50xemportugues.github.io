Ordenação por seleção
--------------

* Podemos adotar uma abordagem diferente com o mesmo conjunto de números:

        6 3 8 5 2 7 4 1
        

* Primeiro, vamos analisar cada número e lembrar o menor número que encontramos. Em seguida, podemos trocá-lo com o primeiro número da nossa lista, já que sabemos que é o menor:

        6 3 8 5 2 7 4 1
        –             –
        1 3 8 5 2 7 4 6
        

* Agora sabemos que pelo menos o primeiro elemento da nossa lista está no lugar certo, então podemos procurar o menor elemento entre os restantes e trocá-lo com o próximo elemento não ordenado (agora o segundo elemento):

        1 3 8 5 2 7 4 6
          –     –
        1 2 8 5 3 7 4 6
        

* Podemos repetir esse processo várias vezes, até obtermos uma lista ordenada.
* Esse algoritmo é chamado de **ordenação por seleção** e poderíamos escrever um pseudocódigo assim:

        Para i de 0 a n–1
            Encontre o item mais pequeno entre o i-ésimo item e o último item
            Troque o item mais pequeno pelo i-ésimo item
        
    
* Com notação _O_ grande, ainda temos uma complexidade de tempo de execução de _O_(_n_2), pois estamos olhando aproximadamente para todos os _n_ elementos para encontrar o menor e fazendo _n_ passagens para ordenar todos os elementos.
* Mais formalmente, podemos usar algumas fórmulas para mostrar que o maior fator é realmente _n_2:

        n + (n – 1) + (n – 2) + ... + 1
        n(n + 1)/2
        (n^2 + n)/2
        n^2/2 + n/2
        O(n^2)
        
    
* Portanto, descobrimos que a ordenação por seleção é fundamentalmente igual à ordenação por bolha em termos de tempo de execução:
    *   _O_(_n_2)
        *   ordenação por bolha, ordenação por seleção
    *   _O_(_n_ log _n_)
    *   _O_(_n_)
        *   busca linear
    *   _O_(log _n_)
        *   busca binária
    *   _O_(1)
* O melhor caso, Ω, também é _n_2.
* Podemos voltar à ordenação por bolha e alterar seu algoritmo para algo assim, o que nos permitirá parar cedo se todos os elementos estiverem ordenados:

        Repita até não haver trocas
            Para i de 0 a n–2
                Se o i-ésimo e o (i+1)-ésimo elementos estiverem fora de ordem
                    Troque-os
        
    
    * Agora, só precisamos analisar cada elemento uma vez, então o melhor caso agora é Ω(_n_):
        *   Ω(_n_2)
            *   ordenação por seleção
        *   Ω(_n_ log _n_)
        *   Ω(_n_)
            *   ordenação por bolha
        *   Ω(log _n_)
        *   Ω(1)
            *   busca linear, busca binária
* Podemos ver uma visualização online [comparando algoritmos de ordenação](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html) com animações que mostram como os elementos se movem dentro dos arrays tanto para a ordenação por bolha quanto para a ordenação por seleção.