Lição 0
=======

*   [Bem-vindo](#bem-vindo)
*   [O que é ciência da computação?](#o-que-é-ciência-da-computação)
*   [Binário](#binário)
*   [Representação de dados](#representação-de-dados)
*   [Algoritmos](#algoritmos)
*   [Pseudocódigo](#pseudocódigo)
*   [Scratch](#scratch)

<h2 id="bem-vindo">Bem-vindo</h2>

*   Quando David estava no primeiro ano, ele estava muito intimidado para fazer qualquer curso de ciência da computação. Quando ele era estudante de segundo ano, ele encontrou coragem para fazer o equivalente ao CS50, mas apenas como aprovação/reprovação.
*   Na verdade, dois terços dos estudantes do CS50 nunca fizeram um curso de ciência da computação antes.
*   E, o que é mais importante:
    
    > o que realmente importa neste curso não é tanto onde você termina em relação aos seus colegas, mas onde você termina em relação a si mesmo quando começou.


<h2 id="o-que-é-ciência-da-computação">O que é ciência da computação?</h2>


*   A ciência da computação é fundamentalmente a resolução de problemas.
*   Podemos pensar na resolução de problemas como o processo de receber algum input (detalhes sobre nosso problema) e gerar algum output (a solução para nosso problema). A "caixa preta" no meio é a ciência da computação.  
    ![palavra "input", seta para dentro da caixa, seta para fora da caixa, palavra "output"](/static/portuguese/cs50x/notes/0/entrada_saida.png)
*   Precisamos de uma forma de representar inputs, de modo que possamos armazenar e trabalhar com informações de forma padronizada.


<h2 id="binário">Binário</h2>

*   Um computador, no nível mais baixo, armazena dados em binário, um sistema numérico que consiste em apenas dois dígitos, 0 e 1.
*   Quando aprendemos a contar, podemos ter usado um dedo para representar uma coisa. Esse sistema é chamado de sistema unary. Quando aprendemos a escrever números com os dígitos de 0 a 9, aprendemos a usar o sistema decimal.
*   Por exemplo, sabemos que o seguinte representa cento e vinte e três.

```
1 2 3
```

*   O `3` está na coluna das unidades, o `2` está na coluna das dezenas e o `1` está na coluna das centenas.
*   Portanto, `123` é 100×1 + 10×2 + 1×3 = 100 + 20 + 3 = 123.
*   Cada lugar para um dígito representa uma potência de dez, já que há dez dígitos possíveis para cada lugar.
*   Em binário, com apenas dois dígitos, temos potências de dois para cada valor de lugar:
    
<pre>
4 2 1
<b>0 0 0</b>
</pre>

*   Isso ainda equivaleria a 0.
*   Agora, se alterarmos o valor binário para, digamos, `0 1 1`, o valor decimal seria 3.

<pre>
4 2 1
<b>0 1 1</b>
</pre>

*   Se quiséssemos representar 8, precisaríamos de outro dígito:

<pre>
8 4 2 1
</pre>

*   E o binário faz sentido para computadores porque os alimentamos com eletricidade, que pode estar ligada ou desligada, então cada bit só precisa estar ligado ou desligado. Em um computador, existem milhões ou bilhões de interruptores chamados transistores que podem armazenar eletricidade e representar um bit estando "ligado" ou "desligado".
*   Com bits suficientes, ou dígitos binários, os computadores podem contar qualquer número.
*   8 bits formam um **byte**.

<h2 id="representação-de-dados">Representação de dados</h2>

* Para representar letras, tudo o que precisamos fazer é decidir como os números são mapeados para letras. Alguns humanos, muitos anos atrás, decidiram coletivamente um mapeamento padrão chamado [ASCII](https://en.wikipedia.org/wiki/ASCII). A letra "A", por exemplo, é o número 65, e "B" é 66, e assim por diante. O mapeamento também inclui pontuação e outros símbolos. Outros caracteres, como letras com acentos e emojis, fazem parte de um padrão chamado [Unicode](https://en.wikipedia.org/wiki/Unicode), que usa mais bits do que ASCII para acomodar todos esses caracteres.
     * Quando recebemos um emoji, nosso computador está recebendo na verdade um número decimal como `128514` (`11111011000000010` em binário, se você puder ler isso mais facilmente) que ele, em seguida, mapeia para a imagem do emoji.
* Uma imagem, também, é composta por muitos pequenos pontos quadrados, ou pixels, cada um dos quais pode ser representado em binário com um sistema chamado RGB, com valores para luz vermelha, verde e azul em cada pixel. Misturando diferentes quantidades de cada cor, podemos representar milhões de cores ​​:  
    ![quadrado vermelho etiquetado com 72, quadrado verde etiquetado com 73, quadrado azul etiquetado com 33](/static/portuguese/cs50x/notes/0/rgb.png)
     * Os valores de vermelho, verde e azul são combinados para obter uma cor amarelo claro:  
         ![quadrado amarelo claro](/static/portuguese/cs50x/notes/0/rgb_combinado.png)
* Podemos ver isso em um emoji se dermos zoom o suficiente: ![emoji ampliado de risos com lágrimas com quadrados de pixels distinguíveis](/static/portuguese/cs50x/notes/0/emoji_ampliado.png)
* E programas de computador sabem, com base no contexto do seu código, se os números binários devem ser interpretados como números, ou letras, ou pixels.
* E vídeos são apenas muitas e muitas imagens exibidas uma após a outra, a uma certa quantidade de quadros por segundo. Música, também, pode ser representada pelas notas sendo tocadas, sua duração e seu volume.

<h2 id="algoritmos">Algoritmos</h2>

*   Agora podemos representar entradas e saídas. A caixa preta mostrada anteriormente contém _algoritmos_, instruções passo a passo para resolver um problema:
    ![caixa com a palavra "algoritmos"](/static/portuguese/cs50x/notes/0/algoritmos.png)
*   Digamos que queremos encontrar um amigo, Mike Smith, em uma lista telefônica.
    *   Poderíamos começar passando pelas páginas do livro uma de cada vez, até encontrarmos Mike Smith ou chegarmos ao final do livro.
    *   Também poderíamos virar duas páginas de cada vez, mas se formos longe demais, teremos que voltar uma página.
    *   Mas uma maneira ainda mais eficiente seria abrir a lista telefônica no meio, decidir se Mike estará na metade esquerda ou direita do livro (porque o livro está em ordem alfabética) e imediatamente descartar metade do problema. Podemos repetir isso, dividindo o problema pela metade a cada vez. Com 1024 páginas no início, precisaríamos apenas de 10 etapas de divisão pela metade antes de termos apenas uma página restante para verificar.
*   Na verdade, podemos representar a eficiência de cada um desses algoritmos com um gráfico:
    ![gráfico com: "tamanho do problema" como eixo x; "tempo para resolver" como eixo y; linha reta vermelha e íngreme do início até o topo do gráfico rotulada como "n"; linha reta amarela e menos íngreme do início até o topo do gráfico rotulada como "n/2"; linha curva verde que fica cada vez menos íngreme do início até a direita do gráfico rotulada como "log n"](/static/portuguese/cs50x/notes/0/tempo_de_execucao.png)
    *   Nossa primeira solução, uma página de cada vez, é semelhante à linha vermelha: nosso tempo de resolução aumenta linearmente à medida que o tamanho do problema aumenta.
    *   A segunda solução, duas páginas de cada vez, é semelhante à linha amarela: nossa inclinação é menos íngreme, mas ainda linear.
    *   Nossa solução final é semelhante à linha verde: logarítmica, pois nosso tempo de resolução aumenta cada vez mais lentamente à medida que o tamanho do problema aumenta. Em outras palavras, se a lista telefônica passasse de 1000 para 2000 páginas, precisaríamos de mais uma etapa para encontrar Mike. Se o tamanho dobrasse novamente, de 2000 para 4000 páginas, ainda precisaríamos de apenas mais uma etapa.

<h2 id="pseudocódigo">Pseudocódigo</h2>

*   Podemos escrever _pseudocódigo_, uma sintaxe informal que é apenas uma versão mais específica do inglês (ou outra língua humana) que representa nosso algoritmo:
    ```
    1  Pegar lista telefônica
    2  Abrir na metade da lista telefônica
    3  Olhar a página
    4  Se Smith está na página
    5      Ligar para Mike
    6  Senão, se Smith está antes no livro
    7      Abrir na metade esquerda do livro telefônico
    8      Voltar para a linha 3
    9  Senão, se Smith está depois no livro
    10     Abrir na metade direita do livro telefônico
    11     Voltar para a linha 3
    12 Senão
    13     Sair
    ```

*   Algumas dessas linhas começam com verbos, ou ações. Começaremos a chamar essas _funções_:
    <pre>
    1  <b>Pegar</b> lista telefônica
    2  <b>Abrir na</b> metade da lista telefônica
    3  <b>Olhar</b> a página
    4  Se Smith está na página  
    5      <b>Ligar</b> para Mike
    6  Senão, se Smith está antes no livro
    7      <b>Abrir na</b> metade esquerda do livro telefônico
    8      Voltar para a linha 3
    9  Senão, se Smith está depois no livro
    10     <b>Abrir na</b> metade direita do livro telefônico
    11     Voltar para a linha 3
    12 Senão
    13     <b>Sair</b>
    </pre>
  
*   Também temos bifurcações que levam a diferentes caminhos, como em uma estrada, que chamaremos de _condições_:
    <pre>
    1  Pegar lista telefônica
    2  Abrir na metade da lista telefônica
    3  Olhar a página
    4  <b>Se</b> Smith está na página
    5      Ligar para Mike
    6  <b>Senão, se</b> Smith está antes no livro
    7      Abrir na metade esquerda do livro telefônico
    8      Voltar para a linha 3
    9  <b>Senão, se</b> Smith está depois no livro
    10     Abrir na metade direita do livro telefônico
    11     Voltar para a linha 3
    12 <b>Senão</b>
    13     Sair
    </pre>

*   E as perguntas que decidem para onde vamos são chamadas de _expressões booleanas_, que eventualmente resultam em um valor verdadeiro ou falso:
    <pre>
    1  Pegar lista telefônica
    2  Abrir na metade da lista telefônica
    3  Olhar a página
    4  Se <b>Smith está na página</b>
    5      Ligar para Mike
    6  Senão, se <b>Smith está antes no livro</b>
    7      Abrir na metade esquerda do livro telefônico
    8      Voltar para a linha 3
    9  Senão, se <b>Smith está depois no livro</b>
    10     Abrir na metade direita do livro telefônico
    11     Voltar para a linha 3
    12 Senão
    13     Sair
    </pre>

*   Por fim, temos palavras que levam a ciclos, onde podemos repetir partes do nosso programa, chamados de _loops_:
    <pre>
    1  Pegar lista telefônica
    2  Abrir na metade da lista telefônica
    3  Olhar a página
    4  Se Smith está na página
    5      Ligar para Mike
    6  Senão, se Smith está antes no livro
    7      Abrir na metade esquerda do livro telefônico
    8      <b>Voltar para a linha 3</b>
    9  Senão, se Smith está depois no livro
    10     Abrir na metade direita do livro telefônico
    11     <b>Voltar para a linha 3</b>
    12 Senão
    13     Sair
    </pre>


<h2 id="scratch">Scratch</h2>

*   Podemos escrever programas com os blocos de construção que acabamos de descobrir:
    *   funções
    *   condições
    *   expressões booleanas
    *   loops
*   Usaremos uma linguagem de programação gráfica chamada [Scratch](https://scratch.mit.edu/), onde arrastamos e soltamos blocos que contêm instruções.
*   Mais adiante em nosso curso, passaremos para linguagens de programação textuais como C, Python e JavaScript. Todas essas linguagens, incluindo o Scratch, possuem recursos mais poderosos como:
    *   variáveis
        *   a capacidade de armazenar valores e alterá-los
    *   threads
        *   a capacidade do nosso programa de fazer várias coisas ao mesmo tempo
    *   eventos
        *   a capacidade de responder a mudanças em nosso programa ou entradas
    *   ...
*   O ambiente de programação para o Scratch se parece com isso:  
    ![captura de tela do Scratch](/static/portuguese/cs50x/notes/0/scratch.png)
    *   À esquerda, temos peças de quebra-cabeça que representam funções, variáveis ou outros conceitos, que podemos arrastar e soltar em nossa área de instruções no centro.
    *   À direita, temos um palco que será mostrado pelo nosso programa para um humano, onde podemos adicionar ou alterar planos de fundo, personagens (chamados de sprites no Scratch) e muito mais.
*   Podemos arrastar alguns blocos para fazer o Scratch dizer "olá, mundo":  
    ![captura de tela do olá, mundo](/static/portuguese/cs50x/notes/0/ola_mundo.png)
    *   O bloco "quando a bandeira verde for clicada" é o início do nosso programa, e abaixo dele encaixamos um bloco "dizer" e digitamos "olá, mundo".
*   Também podemos arrastar o bloco "perguntar e esperar", com uma pergunta como "Qual é o seu nome?", e combiná-lo com um bloco "dizer" para a resposta:  
    ![captura de tela de pergunta e resposta](/static/portuguese/cs50x/notes/0/resposta.png)
*   Mas não esperamos depois de dizer "Olá" com o primeiro bloco, então podemos usar o bloco "dizer () por () segundos":  
    ![captura de tela dos blocos com dizer durante 2 segundos](/static/portuguese/cs50x/notes/0/esperar.png)
*   Podemos usar o bloco "unir" para combinar duas frases para que o Scratch possa dizer "olá, David":  
    ![captura de tela de juntar](/static/portuguese/cs50x/notes/0/junte.png)
    *   Note que podemos aninhar instruções e variáveis.
*   Na verdade, o bloco "dizer" em si é como um algoritmo, onde fornecemos uma entrada de "olá, mundo" e ele produz a saída do Scratch (o gato) "dizendo" essa frase:  
    ![dizer como algoritmo com "olá, mundo" como entrada e gato como saída](/static/portuguese/cs50x/notes/0/algoritmo_diga.png)
*   O bloco "perguntar" também recebe uma entrada (a pergunta que queremos fazer) e produz a saída do bloco "resposta":  
    ![perguntar como algoritmo com "Qual é o seu nome?" como entrada e bloco de resposta como saída](/static/portuguese/cs50x/notes/0/algoritmo_pergunte.png)
*   Podemos então usar o bloco "resposta" juntamente com nosso próprio texto, "olá, ", como duas entradas para o algoritmo de junção ...  
    ![junção como algoritmo com "olá, " e "resposta" como entrada e "olá, David!" como saída](/static/portuguese/cs50x/notes/0/algoritmo_junte.png)
*   ... o qual passamos como entrada novamente para o bloco "dizer":  
    ![dizer como algoritmo com "olá, David!" como entrada e gato como saída](/static/portuguese/cs50x/notes/0/diga_novamente.png)
*   Podemos tentar fazer o Scratch (o nome do gato) dizer miau:  
    ![blocos rotulados como "para sempre" com "tocar som Miau até terminar" aninhados dentro](/static/portuguese/cs50x/notes/0/sempre_miau.png)
    *   Mas quando clicamos na bandeira verde, ouvimos o som do miau repetidamente imediatamente. Nosso primeiro bug, ou erro! Podemos adicionar um bloco para esperar, para que os miados soem mais normais.  
        ![blocos rotulados como "para sempre" com "tocar som Miau até terminar" e "esperar 1 segundo" aninhados dentro](/static/portuguese/cs50x/notes/0/sempre_miau_esperar.png)
*   Podemos fazer o Scratch apontar para o mouse e mover em sua direção:  
    ![blocos rotulados como "para sempre" com "apontar para o ponteiro do mouse" e "mover 10 passos" aninhados dentro](/static/portuguese/cs50x/notes/0/aponte_para.png)
*   Vamos olhar para uma ovelha que sabe contar:  
    ![blocos rotulados como "definir contador para 1" e "para sempre" com "dizer contador durante 1 segundo", "esperar 1 segundo" e "alterar contador em 1" aninhados dentro](/static/portuguese/cs50x/notes/0/contar.png)
    *   Aqui, `contador` é uma variável, cujo valor podemos definir, usar e alterar.
*   Também podemos fazer o Scratch miar se tocarmos nele com o ponteiro do mouse:  
    ![blocos rotulados como "para sempre" com "se estiver tocando no ponteiro do mouse? então" e "tocar som Miau até terminar" aninhados dentro](/static/portuguese/cs50x/notes/0/acariciar0.png)'

*   Alternativamente, podemos fazer com que o Scratch grite se fizermos o seguinte:  
    ![blocos rotulados como "sempre" com "se o ponteiro do mouse estiver tocando? então" e "reproduzir som rugido até terminar" em aninhamento, e "senão", "reproduzir som miau até terminar", "esperar 1 segundo"](/static/portuguese/cs50x/notes/0/acariciar1.png)

*   Aqui, temos dois ramos diferentes, ou condições, que se repetirão para sempre. Se o mouse estiver tocando, o Scratch vai "rugir", caso contrário, ele apenas vai miar.
*   Podemos fazer o Scratch se mover de um lado para o outro na tela com alguns blocos adicionais que podemos descobrir olhando ao redor:  
    ![blocos rotulados como "definir estilo de rotação esquerda-direita" e "sempre" com "mover 10 passos", "se tocar a borda? então" e "reproduzir som ouch até terminar", "girar 180 graus"](/static/portuguese/cs50x/notes/0/ai.png)
    *   Podemos até gravar nosso próprio som para reproduzir.
*   Com dois "trajes" diferentes, ou imagens do Scratch com as pernas em posições diferentes, podemos até simular um movimento de caminhada animado:  
    ![blocos rotulados como "definir estilo de rotação esquerda-direita" e "sempre" com "mover 10 passos", "se tocar a borda? então" com "reproduzir som ouch até terminar", "girar 180 graus" aninhados, e "próximo traje"](/static/portuguese/cs50x/notes/0/esbarrar.png)
*   Olhamos para outro programa, "bark", onde podemos usar a barra de espaço para silenciar um leão-marinho:  
    ![blocos rotulados como "definir silenciado como falso" e "sempre" com "se a tecla espaço for pressionada? então" com "se silenciado = verdadeiro então" e "definir silenciado como falso", "senão" e "definir silenciado como verdadeiro" aninhados, e "esperar 1 segundo"](/static/portuguese/cs50x/notes/0/oioioi.png)
    *   Temos uma variável, `silenciado`, que é `falso` por padrão. E nosso programa verificará constantemente se a barra de espaço foi pressionada e definirá `silenciado` como `falso`, se for `true`, ou `true` caso contrário. Dessa forma, podemos alternar se o som será reproduzido ou não, já que nosso outro conjunto de blocos para o leão-marinho verifica a variável `silenciado`:  
        ![blocos rotulados como "sempre" com "se silenciado = falso então" com "iniciar som LeãoMarinho" e "pensar oi oi oi por 2 segundos" aninhados, e "esperar 1 segundo"](/static/portuguese/cs50x/notes/0/oioioi1.png)
*   Com múltiplos sprites, ou personagens, podemos ter conjuntos diferentes de blocos para cada um deles:  
    ![blocos rotulados como "sempre" com "se a tecla espaço for pressionada? então" com "dizer Marco! por 2 segundos" e "transmitir evento" aninhados](/static/portuguese/cs50x/notes/0/marco.png)
    *   Para um boneco, temos esses blocos que dizem "Marco!", e depois um bloco de "transmitir evento". Esse "evento" é usado para que nossos dois sprites se comuniquem entre si, como enviar uma mensagem secreta. Assim, nosso outro boneco só precisa esperar por esse evento para dizer "Polo!":  
        ![blocos rotulados como "quando receber evento", "dizer Polo! por 2 segundos"](/static/portuguese/cs50x/notes/0/polo.png)
*   Agora que conhecemos alguns conceitos básicos, podemos pensar no design, ou na qualidade de nossos programas. Por exemplo, podemos fazer com que o Scratch tossa três vezes repetindo alguns blocos:  
    ![blocos rotulados como "dizer tossir por 1 segundo", "esperar 1 segundo", "dizer tossir por 1 segundo", "esperar 1 segundo", "dizer tossir por 1 segundo", "esperar 1 segundo"](/static/portuguese/cs50x/notes/0/espirrar0.png)
*   Embora isso esteja correto, podemos evitar repetir blocos com um loop:  
    ![blocos rotulados como "repetir 3 vezes" com "dizer tossir por 1 segundo", "esperar 1 segundo" aninhados](/static/portuguese/cs50x/notes/0/espirrar1.png)
*   O próximo passo é abstrair parte do nosso código em uma função, ou torná-lo reutilizável de diferentes maneiras. Podemos criar um bloco chamado "tossir" e colocar alguns blocos dentro dele:  
    ![dois conjuntos de blocos. o primeiro conjunto de blocos é: "definir tossir", "dizer tossir por 1 segundo", "esperar 1 segundo". o segundo conjunto é: "quando clicar na bandeira verde", "repetir 3 vezes", "tossir"](/static/portuguese/cs50x/notes/0/funcao_espirrar.png)
    *   Agora, todos os nossos sprites podem usar o mesmo bloco "tossir", em quantos lugares desejarmos.
*   Podemos até colocar um número de vezes em nossa função de tossir, para que precisemos apenas de um único bloco para tossir qualquer número de vezes:  
    ![dois conjuntos de blocos. o primeiro conjunto de blocos é: "definir tossir n vezes", "repetir n vezes", "dizer tossir por 1 segundo", "esperar 1 segundo". o segundo conjunto é: "quando clicar na bandeira verde", "tossir 3 vezes"](/static/portuguese/cs50x/notes/0/funcao_espirrar_2.png)
*   Olhamos para alguns exemplos e discutimos como podemos implementar componentes deles com diferentes sprites que seguem o cursor do mouse, ou que causam algo diferente no palco.
*   Bem-vindo a bordo!

