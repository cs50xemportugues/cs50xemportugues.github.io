Strings
-------

*   As strings são na verdade apenas arrays de caracteres. Se tivermos uma string `s`, cada caracter pode ser acessado com `s[0]`, `s[1]`, e assim por diante.
*   E acontece que uma string termina com um caracter especial, ‘\\0’, ou um byte com todos os bits definidos como 0. Esse caracter é chamado de caracter nulo, ou caracter de terminação nula. Portanto, na verdade precisamos de quatro bytes para armazenar a nossa string "OI!":  
    ![grade com H rotulado de s[0], I rotulado de s[1], ! rotulado de s[2], \0 rotulado de s[3], cada um ocupando uma caixa, e muitas caixas vazias a seguir](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png)
*   Agora vamos ver como quatro strings em um array podem se parecer:
    
        string nomes[4];
        nomes[0] = "EMMA";
        nomes[1] = "RODRIGO";
        nomes[2] = "BRIAN";
        nomes[3] = "DAVID";
        
        printf("%s\n", nomes[0]);
        printf("%c%c%c%c\n", nomes[0][0], nomes[0][1], nomes[0][2], nomes[0][3]);
        
    
    *   Podemos imprimir o primeiro valor em `nomes` como uma string, ou podemos obter a primeira string e obter cada caracter individual nessa string usando `[]` novamente. (Podemos pensar nisso como `(nomes[0])[0]`, embora não precisemos dos parênteses.)
    *   E embora saibamos que o primeiro nome tinha quatro caracteres, `printf` provavelmente usou um loop para examinar cada caracter na string, imprimindo-os um de cada vez até chegar ao caracter nulo que marca o final da string. E na verdade, podemos imprimir `nomes[0][4]` como um `int` com `%i` e ver um `0` sendo impresso.
*   Podemos visualizar cada caracter com seu próprio rótulo na memória:  
    ![grade com E rotulado de nomes[0][0], M rotulado de nomes[0][1], e assim por diante, até nomes[3][5] com um \0, cada um ocupando uma caixa, e caixas vazias a seguir](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png)
*   Podemos tentar experimentar com `string0.c`:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Entrada:  ");
            printf("Saída: ");
            for (int i = 0; i < strlen(s); i++)
            {
                printf("%c", s[i]);
            }
            printf("\n");
        }
        
    
    *   Podemos usar a condição `s[i] != '\0'`, onde podemos verificar o caractere atual e apenas imprimi-lo se ele não for o caracter nulo.
    *   Também podemos usar o tamanho da string, mas primeiro, precisamos de uma nova biblioteca, `string.h`, para `strlen`, que nos diz o tamanho de uma string.
*   Podemos melhorar o design do nosso programa. `string0` foi um pouco ineficiente, já que verificamos o tamanho da string depois que cada caracter é impresso, em nossa condição. Mas como o tamanho da string não muda, podemos verificar o tamanho da string uma vez:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Entrada: ");
            printf("Saída:\n");
            for (int i = 0, n = strlen(s); i < n; i++)
            {
                printf("%c\n", s[i]);
            }
        }
        
    
    *   Agora, no início do nosso loop, inicializamos tanto uma variável `i` quanto uma variável `n` e lembramos o tamanho da nossa string em `n`. Em seguida, podemos verificar os valores a cada vez, sem precisar calcular o tamanho da string de fato.
    *   E precisamos usar um pouco mais de memória para `n`, mas isso nos economiza algum tempo em não ter que verificar o tamanho da string a cada vez.
*   Agora podemos combinar o que vimos para escrever um programa que pode capitalizar letras:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Antes: ");
            printf("Depois:  ");
            for (int i = 0, n = strlen(s); i < n; i++)
            {
                if (s[i] >= 'a' && s[i] <= 'z')
                {
                    printf("%c", s[i] - 32);
                }
                else
                {
                    printf("%c", s[i]);
                }
            }
            printf("\n");
        }
        
    
    *   Primeiro, obtemos uma string `s`. Em seguida, para cada caracter na string, se for minúsculo (seu valor estiver entre o de `a` e `z`), o convertemos para maiúsculo. Caso contrário, apenas o imprimimos.
    *   Podemos converter uma letra minúscula para seu equivalente em maiúscula, subtraindo a diferença entre seus valores ASCII. (Sabemos que letras minúsculas têm um valor ASCII maior do que letras maiúsculas, e a diferença é convenientemente a mesma entre as mesmas letras, então podemos subtrair essa diferença para obter uma letra maiúscula a partir de uma letra minúscula.)
*   Podemos usar as [**man pages**](https://man.cs50.io/), ou manual do programador, para encontrar funções de biblioteca que podemos usar para realizar a mesma coisa:
    
        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string s = get_string("Antes: ");
            printf("Depois:  ");
            for (int i = 0, n = strlen(s); i < n; i++)
            {
                printf("%c", toupper(s[i]));
            }
            printf("\n");
        }
        
    
    *   Ao pesquisar nas man pages, vemos que `toupper()` é uma função, entre outras, de uma biblioteca chamada `ctype`, que podemos usar.