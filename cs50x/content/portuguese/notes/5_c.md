Mais estruturas de dados
--------------------

*   Uma **árvore** é outra estrutura de dados em que cada nó aponta para outros dois nós, um para a esquerda (com um valor menor) e outro para a direita (com um valor maior):
    ![árvore com nó 4 no topo central, seta esquerda para 3 abaixo, seta direita para 6 abaixo; 2 tem seta esquerda para 1 abaixo, seta direita para 3 abaixo; 6 tem seta esquerda para 5 abaixo, seta direita para 7 abaixo](https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png)
    *   Note que agora há duas dimensões nessa estrutura de dados, onde alguns nós estão em diferentes "níveis" em relação aos outros. E podemos imaginar que isso seja implementado com uma versão mais complexa de um nó em uma lista encadeada, onde cada nó não tem apenas um, mas dois ponteiros, um para o valor "no meio da metade esquerda" e outro para o valor "no meio da metade direita". E todos os elementos à esquerda de um nó são menores e todos os elementos à direita são maiores.
    *   Isso é chamado de árvore binária de busca porque cada nó tem no máximo dois filhos, ou nós para os quais está apontando, e árvore de busca porque está ordenada de uma maneira que nos permite fazer buscas corretamente.
    *   E, como em uma lista encadeada, vamos querer manter um ponteiro apenas para o início da lista, mas neste caso queremos apontar para a raiz, ou seja, o nó central superior da árvore (o 4).
*   Agora, podemos facilmente fazer uma busca binária e, como cada nó está apontando para outro, também podemos inserir nós na árvore sem movê-los todos como teríamos que fazer em um array. A busca recursiva nesta árvore seria algo como:
    
        typedef struct node
        {
            int number;
            struct node *left;
            struct node *right;
        } node;
        
        // Aqui, *tree é um ponteiro para a raiz de nossa árvore.
        bool search(node *tree)
        {
            // Precisamos de um caso base, se a árvore atual (ou parte da árvore) for NULA,
            // para retornar false:
            if (tree == NULL)
            {
                return false;
            }
            // Agora, dependendo se o número no nó atual é maior ou menor,
            // podemos apenas olhar para o lado esquerdo ou direito da árvore:
            else if (50 < tree->number)
            {
                return search(tree->left);
            }
            else if (50 > tree->number)
            {
                return search(tree->right);
            }
            // Caso contrário, o número deve ser igual ao que procuramos:
            else {
                return true;
            }
        }

*   O tempo de execução para pesquisar em uma árvore é _O_(log _n_), e inserir nós mantendo a árvore equilibrada também é _O_(log _n_). Ao gastarmos um pouco mais de memória e tempo para manter a árvore, agora temos uma pesquisa mais rápida em comparação com uma simples lista encadeada.
*   Uma estrutura de dados com tempo de pesquisa quase constante é uma **tabela de dispersão** (hash table), que é uma combinação de um array e uma lista encadeada. Temos um array de listas encadeadas, e cada lista encadeada no array tem elementos de uma determinada categoria. Por exemplo, no mundo real, podemos ter muitos crachás de identificação e podemos classificá-los em 26 compartimentos, um rotulado com cada letra do alfabeto, para que possamos encontrar os crachás de identificação olhando em apenas um compartimento.
*   Podemos implementar isso em uma tabela de dispersão com um array de 26 ponteiros, cada um apontando para uma lista encadeada para uma letra do alfabeto:
    ![array vertical com 26 caixas, a primeira com uma seta apontando para uma caixa rotulada Albus, a segunda vazia, a terceira com uma seta apontando para uma caixa rotulada Cedric ... a sétima com uma seta apontando para uma caixa rotulada Ginny com uma seta dessa caixa apontando para uma caixa rotulada George...](https://cs50.harvard.edu/x/2020/notes/5/hash_table.png)
*   Como temos acesso aleatório com arrays, podemos adicionar elementos rapidamente, e também indexar rapidamente um compartimento.
*   Um compartimento pode ter vários valores correspondentes, então usaremos uma lista encadeada para armazenar todos eles horizontalmente. (Chamamos isso de colisão, quando dois valores correspondem de alguma maneira.)
*   Isso é chamado de tabela de dispersão porque usamos uma função de dispersão, que recebe uma entrada e a mapeia para um compartimento em que deve ser colocada. Em nosso exemplo, a função de dispersão está apenas olhando para a primeira letra do nome, então pode retornar `0` para "Albus" e `25` para "Zacharias".
*   Mas no pior caso, todos os nomes podem começar com a mesma letra, então podemos acabar com o equivalente a uma única lista encadeada novamente. Podemos olhar para as primeiras duas letras e alocar compartimentos suficientes para 26\*26 possíveis valores dispersados, ou até mesmo as primeiras três letras, e agora precisaríamos de 26\*26\*26 compartimentos. No entanto, ainda poderíamos ter um pior caso em que todos os nossos valores comecem com os mesmos três caracteres, portanto o tempo de execução para pesquisa é _O_(_n_). Na prática, porém, podemos chegar mais perto de _O_(1) se tivermos cerca de tantos compartimentos quanto valores possíveis, especialmente se tivermos uma função de dispersão ideal, onde podemos classificar nossas entradas em compartimentos únicos.
*   Podemos usar outra estrutura de dados chamada **árvore trie** (lê-se como "try" e é a abreviação de "retrieval"):

    ![array com letras de A-Z em 26 elementos, com H apontando para outro array com todas as 26 letras. os A e E deste array cada um apontam para outros dois arrays de todas as 26 letras, e isso continua em uma árvore até os arrays mais inferiores terem apenas uma letra marcada como válida](https://cs50.harvard.edu/x/2020/notes/5/trie.png)
    *   Imagine que queremos armazenar um dicionário de palavras de maneira eficiente e ser capazes de acessar cada uma delas em tempo constante. Um árvore trie é como uma árvore, mas cada nó é um array. Cada array terá cada letra, de A a Z, armazenada. Para cada palavra, a primeira letra apontará para um array, onde a próxima letra válida apontará para outro array, e assim por diante, até chegarmos a algo que indique o final de uma palavra válida. Se a palavra não estiver no trie, então um dos arrays não terá um ponteiro ou caractere de finalização para a nossa palavra. Agora, mesmo se a nossa estrutura de dados tiver muitas palavras, o tempo de busca será apenas o comprimento da palavra que estamos procurando, e isso pode ser um máximo fixo, então temos _O_(1) para busca e inserção. O custo disso, porém, é 26 vezes mais memória do que precisamos para cada caractere.
*   Existem até construções de nível mais alto, **estruturas de dados abstratas**, onde usamos nossos blocos de construção de arrays, listas encadeadas, tabelas de dispersão e árvores trie para implementar uma solução para algum problema.
*   Por exemplo, uma estrutura de dados abstrata é uma **fila**, onde queremos ser capazes de adicionar valores e remover valores de forma que o primeiro a entrar seja o primeiro a sair (FIFO). Para adicionar um valor, podemos enfileirá-lo, e para remover um valor, podemos desenfileirá-lo. E podemos implementar isso com um array que redimensionamos à medida que adicionamos itens, ou uma lista encadeada onde apendicamos valores ao final.
*   Uma estrutura de dados "oposta" seria uma **pilha**, onde os itens adicionados mais recentemente (empilhados) são removidos (desempilhados) primeiro, em uma forma de último a entrar, primeiro a sair (LIFO). Nossa caixa de entrada de e-mail é uma pilha, onde nossos e-mails mais recentes estão no topo.
*   Outro exemplo é um **dicionário**, onde podemos mapear chaves para valores, ou strings para valores, e podemos implementar um com uma tabela de dispersão onde uma palavra vem com alguma outra informação (como sua definição ou significado).
*   Vamos dar uma olhada em [“Jack Learns the Facts About Queues and Stacks”](https://www.youtube.com/watch?v=2wM6_PuBIxY), uma animação sobre essas estruturas de dados.