string
------

*   Podemos ter uma variável `string s` para um nome como `EMMA` e ser capaz de acessar cada caractere com `s[0]` e assim por diante:
    ![caixas lado a lado, contendo: E rotulado como s[0], M rotulado como s[1], M rotulado como s[2], A rotulado como s[3], \0 rotulado como s[4]](https://cs50.harvard.edu/x/2020/notes/4/s_array.png)
*   Mas acontece que cada caractere é armazenado na memória em um byte com algum endereço, e `s` é na verdade apenas um ponteiro com o endereço do primeiro caractere:
    ![caixa contendo 0x123 rotulado como s, caixas lado a lado contendo E rotulado como 0x123, M rotulado como 0x124, M rotulado como 0x125, A rotulado como 0x126, \0 rotulado como 0x127](https://cs50.harvard.edu/x/2020/notes/4/s_pointer.png)
*   E como `s` é apenas um ponteiro para o início, apenas o `\0` indica o fim da string.
*   Na verdade, a Biblioteca CS50 define uma `string` com `typedef char *string`, o que significa apenas que queremos nomear um novo tipo, `string`, como um `char *`, ou um ponteiro para um caractere.
*   Vamos imprimir uma string:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string s = "EMMA";
            printf("%s\n", s);
        }
        
    
*   Isso é familiar, mas podemos apenas dizer:
    
        #include <stdio.h>
        
        int main(void)
        {
            char *s = "EMMA";
            printf("%s\n", s);
        }
        
    
    *   Isso também imprimirá `EMMA`.
*   Com `printf("%p\n", s);`, podemos imprimir `s` como seu valor como um ponteiro, como `0x42ab52`. (`printf` sabe acessar o endereço e imprimir a string inteira quando usamos `%s` e passamos `s`, mesmo `s` apontando apenas para o primeiro caractere.)
*   Também podemos tentar `printf("%p\n", &s[0]);`, que é o endereço do primeiro caractere de `s` e é exatamente o mesmo que imprimir `s`. E imprimir `&s[1]`, `&s[2]` e `&s[3]` nos dá os endereços que são os próximos caracteres na memória após `&s[0]`, como `0x42ab53`, `0x42ab54` e `0x42ab55`, exatamente um byte após o outro.
*   E finalmente, se tentarmos `printf("%c\n", *s);`, obtemos um único caractere `E`, pois estamos acessando o endereço armazenado em `s`, que é o primeiro caractere da string.
*   Na verdade, `s[0]`, `s[1]` e `s[2]` mapeiam diretamente para `*s`, `*(s+1)` e `*(s+2)`, já que cada um dos próximos caracteres está no endereço do próximo byte.

Compare e copie
----------------

*   Vamos olhar para `compare0`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Obter dois inteiros
            int i = get_int("i: ");
            int j = get_int("j: ");
        
            // Comparar inteiros
            if (i == j)
            {
                printf("Iguais\n");
            }
            else
            {
                printf("Diferentes\n");
            }
        }
        
    
    *   Podemos compilar e executar isso, e nosso programa funciona como esperado, com os mesmos valores dos dois inteiros nos dando "Iguais" e valores diferentes "Diferentes".
*   Em `compare1`, vemos que os mesmos valores de string fazem com que nosso programa imprima "Diferentes":
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Obter duas strings
            string s = get_string("s: ");
            string t = get_string("t: ");
        
            // Comparar endereços das strings
            if (s == t)
            {
                printf("Iguais\n");
            }
            else
            {
                printf("Diferentes\n");
            }
        }
        
    
    *   Com base no que sabemos agora sobre strings, isso faz sentido porque cada variável "string" está apontando para uma localização diferente na memória, onde o primeiro caractere de cada string está armazenado. Portanto, mesmo que os valores das strings sejam os mesmos, isso sempre imprimirá "Diferentes".
    *   Por exemplo, nossa primeira string pode estar no endereço 0x123, nossa segunda pode estar no 0x456, e `s` será `0x123` e `t` será `0x456`, então esses valores serão diferentes.
    *   E `get_string`, durante todo esse tempo, estava retornando apenas um `char *`, ou seja, um ponteiro para o primeiro caractere de uma string do usuário.
*   Agora vamos tentar copiar uma string:
    
        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        
        int main(void)
        {
            string s = get_string("s: ");
        
            string t = s;
        
            t[0] = toupper(t[0]);
        
            // Imprimir string duas vezes
            printf("s: %s\n", s);
            printf("t: %s\n", t);
        }
        
    
    *   Obtemos uma string `s` e copiamos o valor de `s` para `t`. Em seguida, capitalizamos a primeira letra em `t`.
    *   Mas quando executamos nosso programa, vemos que tanto `s` quanto `t` estão agora capitalizados.
    *   Como definimos `s` e `t` com os mesmos valores, eles são na verdade ponteiros para o mesmo caractere, então capitalizamos o mesmo caractere!
*   Para realmente fazer uma cópia de uma string, temos que fazer um pouco mais de trabalho:
    
        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            char *s = get_string("s: ");
        
            char *t = malloc(strlen(s) + 1);
        
            for (int i = 0, n = strlen(s); i < n + 1; i++)
            {
                t[i] = s[i];
            }
        
            t[0] = toupper(t[0]);
        
            printf("s: %s\n", s);
            printf("t: %s\n", t);
        }
        
    
    *   Criamos uma nova variável, `t`, do tipo `char *`, com `char *t`. Agora, queremos apontá-la para um novo bloco de memória grande o suficiente para armazenar a cópia da string. Com `malloc`, podemos alocar algum número de bytes na memória (que não estejam sendo usados para armazenar outros valores) e passamos o número de bytes que queremos. Já conhecemos o comprimento de `s`, então adicionamos 1 para o caractere nulo terminador. Portanto, nossa última linha de código é `char *t = malloc(strlen(s) + 1);`.
    *   Em seguida, copiamos cada caractere, um de cada vez, e agora podemos capitalizar apenas a primeira letra de `t`. E usamos `i < n + 1`, pois queremos ir até `n`, para garantir que copiamos o caractere terminador da string.
    *   Na verdade, podemos usar também a função de biblioteca `strcpy` com `strcpy(t, s)` em vez do nosso loop, para copiar a string `s` para `t`. Para ficar claro, o conceito de "string" vem da linguagem C e é bem suportado; as únicas "rodinhas de treinamento" do CS50 são o tipo `string` em vez de `char *` e a função `get_string`.
*   Se não copiarmos o caractere nulo terminador, `\0`, e tentarmos imprimir nossa string `t`, `printf` continuará e imprimirá os valores desconhecidos ou lixo que temos na memória, até chegar a um `\0` ou travar completamente, pois nosso programa pode acabar tentando ler memória que não pertence a ele!