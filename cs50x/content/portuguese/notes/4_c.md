valgrind
--------

*   Descobre-se que, após terminarmos de usar a memória alocada com `malloc`, devemos chamar `free` (como em `free(t)`), que informa ao computador que aqueles bytes não são mais úteis para nosso programa, então esses bytes na memória podem ser reutilizados novamente.
*   Se continuarmos executando nosso programa e alocando memória com `malloc`, mas nunca liberando a memória após terminarmos de usá-la, teremos um **vazamento de memória**, que deixará nosso computador mais lento e consumirá cada vez mais memória até que nosso computador fique sem memória.
*   `valgrind` é uma ferramenta de linha de comando que podemos usar para executar nosso programa e verificar se ele tem vazamentos de memória. Podemos executar o valgrind em nosso programa acima com `help50 valgrind ./copy` e ver, a partir da mensagem de erro, que na linha 10 alocamos memória que nunca foi liberada (ou "perdida").
*   Então, no final, podemos adicionar uma linha `free(t)`, que não alterará o funcionamento do nosso programa, mas eliminará os erros do valgrind.
*   Vamos dar uma olhada no arquivo `memory.c`:

        // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare
        
        #include <stdlib.h>
        
        void f(void)
        {
            int *x = malloc(10 * sizeof(int));
            x[10] = 0;
        }
        
        int main(void)
        {
            f();
            return 0;
        }
        
    
    *   Este é um exemplo da documentação do valgrind (valgrind é uma ferramenta real, enquanto o help50 foi escrito especificamente para nos ajudar neste curso).
    *   A função `f` aloca memória suficiente para 10 inteiros e armazena o endereço em um ponteiro chamado `x`. Em seguida, tentamos definir o valor do 11º elemento de `x` com `x[10]` como `0`, o que ultrapassa o tamanho do array de memória alocado para nosso programa. Isso é chamado de **buffer overflow**, onde ultrapassamos os limites do buffer ou array e acessamos a memória desconhecida.
*   O valgrind também nos informará que existe uma "Escrita inválida de tamanho 4" na linha 8, onde de fato estamos tentando alterar o valor de um inteiro (de tamanho 4 bytes).
*   E durante todo esse tempo, a Biblioteca CS50 tem liberado a memória alocada em `get_string` quando nosso programa termina!

Swap
----

*   Temos duas bebidas de cores diferentes, roxo e verde, cada uma em um copo. Queremos trocar as bebidas entre os dois copos, mas não podemos fazer isso sem um terceiro copo para despejar uma das bebidas primeiro.
*   Agora, digamos que queiramos trocar os valores de dois inteiros.
    
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
        
    
    *   Com uma terceira variável para usar como espaço de armazenamento temporário, podemos fazer isso facilmente, colocando `a` em `tmp`, depois `b` em `a` e, finalmente, o valor original de `a`, agora em `tmp`, em `b`.
*   Mas, se tentarmos usar essa função em um programa, não veremos nenhuma mudança:
    
        #include <stdio.h>
        
        void swap(int a, int b);
        
        int main(void)
        {
            int x = 1;
            int y = 2;
        
            printf("x é %i, y é %i\n", x, y);
            swap(x, y);
            printf("x é %i, y é %i\n", x, y);
        }
        
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
        
    
    *   Acontece que a função `swap` recebe suas próprias variáveis, `a` e `b`, quando são passadas, que são cópias de `x` e `y`, portanto, alterar esses valores não altera `x` e `y` na função `main`.