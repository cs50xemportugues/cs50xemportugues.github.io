'*   Alternativamente, podemos fazer com que o Scratch grite se fizermos o seguinte:  
    ![blocos rotulados como "sempre" com "se o ponteiro do mouse estiver tocando? então" e "reproduzir som rugido até terminar" em aninhamento, e "senão", "reproduzir som miau até terminar", "esperar 1 segundo"](https://cs50.harvard.edu/x/2020/notes/0/pet1.png)
    *   Aqui, temos dois ramos diferentes, ou condições, que se repetirão para sempre. Se o mouse estiver tocando, o Scratch vai "rugir", caso contrário, ele apenas vai miar.
*   Podemos fazer o Scratch se mover de um lado para o outro na tela com alguns blocos adicionais que podemos descobrir olhando ao redor:  
    ![blocos rotulados como "definir estilo de rotação esquerda-direita" e "sempre" com "mover 10 passos", "se tocar a borda? então" e "reproduzir som ouch até terminar", "girar 180 graus"](https://cs50.harvard.edu/x/2020/notes/0/ouch.png)
    *   Podemos até gravar nosso próprio som para reproduzir.
*   Com dois "trajes" diferentes, ou imagens do Scratch com as pernas em posições diferentes, podemos até simular um movimento de caminhada animado:  
    ![blocos rotulados como "definir estilo de rotação esquerda-direita" e "sempre" com "mover 10 passos", "se tocar a borda? então" com "reproduzir som ouch até terminar", "girar 180 graus" aninhados, e "próximo traje"](https://cs50.harvard.edu/x/2020/notes/0/bounce.png)
*   Olhamos para outro programa, "bark", onde podemos usar a barra de espaço para silenciar um leão-marinho:  
    ![blocos rotulados como "definir silenciado como falso" e "sempre" com "se a tecla espaço for pressionada? então" com "se silenciado = verdadeiro então" e "definir silenciado como falso", "senão" e "definir silenciado como verdadeiro" aninhados, e "esperar 1 segundo"](https://cs50.harvard.edu/x/2020/notes/0/bark.png)
    *   Temos uma variável, `silenciado`, que é `falso` por padrão. E nosso programa verificará constantemente se a barra de espaço foi pressionada e definirá `silenciado` como `falso`, se for `true`, ou `true` caso contrário. Dessa forma, podemos alternar se o som será reproduzido ou não, já que nosso outro conjunto de blocos para o leão-marinho verifica a variável `silenciado`:  
        ![blocos rotulados como "sempre" com "se silenciado = falso então" com "iniciar som LeãoMarinho" e "pensar oi oi oi por 2 segundos" aninhados, e "esperar 1 segundo"](https://cs50.harvard.edu/x/2020/notes/0/bark1.png)
*   Com múltiplos sprites, ou personagens, podemos ter conjuntos diferentes de blocos para cada um deles:  
    ![blocos rotulados como "sempre" com "se a tecla espaço for pressionada? então" com "dizer Marco! por 2 segundos" e "transmitir evento" aninhados](https://cs50.harvard.edu/x/2020/notes/0/marco.png)
    *   Para um boneco, temos esses blocos que dizem "Marco!", e depois um bloco de "transmitir evento". Esse "evento" é usado para que nossos dois sprites se comuniquem entre si, como enviar uma mensagem secreta. Assim, nosso outro boneco só precisa esperar por esse evento para dizer "Polo!":  
        ![blocos rotulados como "quando receber evento", "dizer Polo! por 2 segundos"](https://cs50.harvard.edu/x/2020/notes/0/polo.png)
*   Agora que conhecemos alguns conceitos básicos, podemos pensar no design, ou na qualidade de nossos programas. Por exemplo, podemos fazer com que o Scratch tossa três vezes repetindo alguns blocos:  
    ![blocos rotulados como "dizer tossir por 1 segundo", "esperar 1 segundo", "dizer tossir por 1 segundo", "esperar 1 segundo", "dizer tossir por 1 segundo", "esperar 1 segundo"](https://cs50.harvard.edu/x/2020/notes/0/cough0.png)
*   Embora isso esteja correto, podemos evitar repetir blocos com um loop:  
    ![blocos rotulados como "repetir 3 vezes" com "dizer tossir por 1 segundo", "esperar 1 segundo" aninhados](https://cs50.harvard.edu/x/2020/notes/0/cough1.png)
*   O próximo passo é abstrair parte do nosso código em uma função, ou torná-lo reutilizável de diferentes maneiras. Podemos criar um bloco chamado "tossir" e colocar alguns blocos dentro dele:  
    ![dois conjuntos de blocos. o primeiro conjunto de blocos é: "definir tossir", "dizer tossir por 1 segundo", "esperar 1 segundo". o segundo conjunto é: "quando clicar na bandeira verde", "repetir 3 vezes", "tossir"](https://cs50.harvard.edu/x/2020/notes/0/cough_function.png)
    *   Agora, todos os nossos sprites podem usar o mesmo bloco "tossir", em quantos lugares desejarmos.
*   Podemos até colocar um número de vezes em nossa função de tossir, para que precisemos apenas de um único bloco para tossir qualquer número de vezes:  
    ![dois conjuntos de blocos. o primeiro conjunto de blocos é: "definir tossir n vezes", "repetir n vezes", "dizer tossir por 1 segundo", "esperar 1 segundo". o segundo conjunto é: "quando clicar na bandeira verde", "tossir 3 vezes"](https://cs50.harvard.edu/x/2020/notes/0/cough_function_2.png)
*   Olhamos para alguns exemplos e discutimos como podemos implementar componentes deles com diferentes sprites que seguem o cursor do mouse, ou que causam algo diferente no palco.
*   Bem-vindo a bordo!'