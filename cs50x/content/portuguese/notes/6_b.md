Exemplos
--------

*   Podemos desfocar uma imagem com:

        from PIL import Image, ImageFilter
        
        antes = Image.open("bridge.bmp")
        depois = antes.filter(ImageFilter.BLUR)
        depois.save("out.bmp")
    
    *   Em Python, incluímos outras bibliotecas com `import`, e aqui vamos `importar` os nomes `Image` e `ImageFilter` da biblioteca `PIL`.
    *   Acontece que, se procurarmos pela documentação da biblioteca `PIL`, podemos usar as próximas três linhas de código para abrir uma imagem chamada `bridge.bmp`, aplicar um filtro de desfoque nela e salvar em um arquivo chamado `out.bmp`.
    *   E podemos executar isso com `python blur.py` após salvar em um arquivo chamado `blur.py`.
*   Podemos implementar um dicionário com:

        palavras = set()
        
        def verificar(palavra):
            if palavra.lower() in palavras:
                return True
            else:
                return False
        
        def carregar(dicionario):
            arquivo = open(dicionario, "r")
            for linha in arquivo:
                palavras.add(linha.rstrip("\n"))
            arquivo.close()
            return True
        
        def tamanho():
            return len(palavras)
        
        def descarregar():
            return True
    
    *   Primeiro, criamos um novo conjunto chamado `palavras`. Então, para `verificar`, podemos simplesmente perguntar `if palavra.lower() in palavras`. Para `carregar`, abrimos o arquivo e usamos `palavras.add` para adicionar cada linha ao nosso conjunto. Para `tamanho`, podemos usar `len` para contar o número de elementos do conjunto e, finalmente, para `descarregar`, não precisamos fazer nada!
*   Acontece que, mesmo que implementar um programa em Python seja mais simples para nós, o tempo de execução do nosso programa em Python é mais lento do que nosso programa em C, pois nosso interpretador precisa fazer mais trabalho para nós. Portanto, dependendo de nossos objetivos, também teremos que considerar a troca de tempo humano de escrever um programa mais eficiente em relação ao tempo de execução do programa.
*   Em Python, também podemos incluir a biblioteca CS50, mas a sintaxe será:

        from cs50 import get_string
    
    *   Observe que especificamos as funções que queremos usar.
*   Agora podemos obter strings de um usuário:

        from cs50 import get_string
        
        s = get_string("Qual é o seu nome?:\n")
        print("Olá, " + s)
    
*   Podemos substituir expressões em nossas strings formatadas também:

        from cs50 import get_int
        
        idade = get_int("Qual é a sua idade?\n")
        print(f"Você tem pelo menos {idade * 365} dias de idade.")
    
*   E podemos demonstrar condições:

        from cs50 import get_int
        
        x = get_int("x: ")
        y = get_int("y: ")
        
        if x < y:
            print("x é menor que y")
        elif x > y:
            print("x é maior que y")
        else:
            print("x é igual a y")
    
*   Para verificar condições, podemos dizer:

        from cs50 import get_string
        
        s = get_string("Você concorda?\n")
        
        if s == "Y" or s == "y":
            print("Concordou.")
        elif s == "N" or s == "n":
            print("Não concordou.")
    
    *   Python não tem caracteres individuais, então podemos verificá-los como strings diretamente.
    *   Também podemos dizer `if s in ["Y", "y"]:`, ou `if s.lower() in ["y"]:`.
    *   Acontece que strings em Python são como estruturas em C, onde temos não apenas variáveis, mas também funções que podemos chamar. Por exemplo, dado uma string `s`, podemos chamar sua função `lower` com `s.lower()` para obter a versão em minúsculas da string.
*   Podemos melhorar também as versões de `cough`:

        print("cough")
        print("cough")
        print("cough")
    
    *   Não precisamos declarar uma função `main`, então apenas escrevemos a mesma linha de código três vezes.
*   Mas podemos fazer melhor:

        for i in range(3):
            cough()
        
        def cough():
            print("cough")
    
    *   Observe que não precisamos especificar o tipo de retorno de uma nova função, que podemos definir com `def`.
    *   Mas isso causa um erro quando tentamos executá-lo: `NameError: name 'cough' is not defined`. Acontece que precisamos definir nossa função antes de usá-la, então podemos mover a definição de `cough` para o topo ou criar uma função `main`:
        
            def main():
                for i in range(3):
                    cough()
            
            def cough():
                print("cough")
            
            main()
        
    *   Agora, no momento em que realmente chamamos nossa função `main`, a função `cough` já terá sido lida pelo nosso interpretador.
*   Nossas funções também podem receber entradas:

        def main():
            cough(3)
        
        def cough(n):
            for i in range(n):
                print("cough")
        
        main()