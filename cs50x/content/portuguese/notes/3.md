Aula 3
=========

*   [Busca](#busca)
*   [Big O](#big-o)
*   [Busca linear](#busca-linear)
*   [Structs](#structs)
*   [Ordenação](#ordenacao)
*   [Selection sort](#selection-sort)
*   [Recursão](#recursao)
*   [Merge sort](#merge-sort)

Busca
---------

*   Da última vez, falamos sobre a memória em um computador, ou RAM, e como nossos dados podem ser armazenados como variáveis individuais ou como arrays com vários itens, ou elementos.
*   Podemos pensar em um array com vários itens como uma fileira de armários, onde um computador só pode abrir um armário para olhar um item, de cada vez.
*   Por exemplo, se quisermos verificar se um número está em um array, com um algoritmo que recebe um array como entrada e produz um booleano como resultado, poderíamos:
    *   olhar em cada armário, ou em cada elemento, de cada vez, do início ao fim.
        *   Isso é chamado de **busca linear**, onde nos movemos em uma linha, já que nosso array não está ordenado.
    *   começar no meio e mover para a esquerda ou direita, dependendo do que estamos procurando, se nosso array de itens estiver ordenado.
        *   Isso é chamado de **busca binária**, já que podemos dividir nosso problema em dois a cada passo, como David fez com a lista telefônica na semana 0.
*   Podemos escrever um pseudocódigo para a busca linear assim:
    
        Para i de 0 a n–1
            Se o i-ésimo elemento for 50
                Retorna verdadeiro
        Retorna falso
        
    
    *   Podemos rotular cada um dos armários, de `0` a `n–1`, e verificá-los em ordem.
*   Para a busca binária, nosso algoritmo pode ser assim:
    
        Se não houver itens
            Retorna falso
        Se o item do meio for 50
            Retorna verdadeiro
        Senão, se 50 < item do meio
            Buscar na metade esquerda
        Senão, se 50 > item do meio
            Buscar na metade direita
        
    
    *   Eventualmente, não teremos mais partes do array sobrando (se o item que queremos não estiver nele), então podemos retornar `falso`.
    *   Caso contrário, podemos procurar em cada metade, dependendo do valor do item do meio.

Big O
-----

*   Na semana 0, vimos diferentes tipos de algoritmos e seus tempos de execução: ![gráfico com: "tamanho do problema" como eixo x; "tempo para resolver" como eixo y; linha reta vermelha e íngreme desde a origem até o topo do gráfico rotulada como "n"; linha reta amarela e menos íngreme desde a origem até o topo do gráfico rotulada como "n/2"; linha curva verde que fica cada vez menos íngreme desde a origem até a direita do gráfico rotulada como "log_2 n"](https://cs50.harvard.edu/x/2020/notes/3/running_time.png)
*   A maneira mais formal de descrever isso é com a notação big _O_, que podemos pensar como "na ordem de". Por exemplo, se nosso algoritmo é a busca linear, ele levará aproximadamente _O_(_n_) passos, "na ordem de _n_". Na verdade, até mesmo um algoritmo que olha dois itens de cada vez e leva _n_/2 passos tem _O_(_n_). Isso ocorre porque, à medida que _n_ fica cada vez maior, apenas o termo maior, _n_, importa.
*   Da mesma forma, um tempo de execução logarítmico é _O_(log _n_), não importando qual seja a base, já que isso é apenas uma aproximação do que acontece quando _n_ é muito grande.
*   Existem alguns tempos de execução comuns:
    *   _O_(_n_2)
    *   _O_(_n_ log _n_)
    *   _O_(_n_)
        *   (busca linear)
    *   _O_(log _n_)
        *   (busca binária)
    *   _O_(1)
*   Os cientistas da computação também podem usar o big Ω, notação big Omega, que é o limite inferior do número de passos para nosso algoritmo. (Big _O_ é o limite superior do número de passos, ou o pior caso, e geralmente é o que mais nos interessa.) Com a busca linear, por exemplo, o pior caso é _n_ passos, mas o melhor caso é 1 passo, já que nosso item pode acontecer de ser o primeiro item que verificamos. O melhor caso para a busca binária também é 1, já que nosso item pode estar no meio do array.
*   E temos um conjunto similar dos tempos de execução mais comuns em big Ω:
    *   Ω(_n_2)
    *   Ω(_n_ log _n_)
    *   Ω(_n_)
        *   (contando o número de itens)
    *   Ω(log _n_)
    *   Ω(1)
        *   (busca linear, busca binária)

Busca linear
------------

*   Vamos dar uma olhada no `numbers.c`:

        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Um array de números
            int numbers[] = {4, 8, 15, 16, 23, 42};
        
            // Busca por 50
            for (int i = 0; i < 6; i++)
            {
                if (numbers[i] == 50)
                {
                    printf("Encontrado\n");
                    return 0;
                }
            }
            printf("Não encontrado\n");
            return 1;
        }
    

    *   Aqui, inicializamos um array com alguns valores e verificamos os itens do array um por vez, em ordem.
    *   E em cada caso, dependendo se o valor foi encontrado ou não, podemos retornar um código de saída de 0 (para sucesso) ou 1 (para falha).
*   Podemos fazer o mesmo para nomes:

        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            // Um array de nomes
            string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
        
            // Busca por EMMA
            for (int i = 0; i < 4; i++)
            {
                if (strcmp(names[i], "EMMA") == 0)
                {
                    printf("Encontrado\n");
                    return 0;
                }
            }
            printf("Não encontrado\n");
            return 1;
        }
    

    *   Não podemos comparar strings diretamente, pois elas não são um tipo de dados simples, mas sim um array de muitos caracteres, e precisamos compará-las de forma diferente. Felizmente, a biblioteca `string` possui uma função `strcmp` que compara strings para nós e retorna `0` se forem iguais, então podemos usá-la.
*   Vamos tentar implementar uma lista telefônica com as mesmas ideias:

        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        int main(void)
        {
            string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
            string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};
        
            for (int i = 0; i < 4; i++)
            {
                if (strcmp(names[i], "EMMA") == 0)
                {
                    printf("Encontrado %s\n", numbers[i]);
                    return 0;
                }
            }
            printf("Não encontrado\n");
            return 1;
        }
    

    *   Vamos usar strings para números de telefone, pois eles podem incluir formatação ou ser muito longos para serem representados como números.
    *   Agora, se o nome em um certo índice no array `names` corresponder à pessoa que estamos procurando, retornaremos o número de telefone no array `numbers`, no mesmo índice. Mas isso significa que precisamos ter cuidado para garantir que cada número corresponda ao nome em cada índice, especialmente se adicionarmos ou removermos nomes e números.

Ficheiros Markdown
-------

* Descobrimos que podemos criar os nossos próprios tipos de dados personalizados chamados de **structs**:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        typedef struct
        {
            string name;
            string number;
        }
        person;
        
        int main(void)
        {
            person people[4];
        
            people[0].name = "EMMA";
            people[0].number = "617–555–0100";
        
            people[1].name = "RODRIGO";
            people[1].number = "617–555–0101";
        
            people[2].name = "BRIAN";
            people[2].number = "617–555–0102";
        
            people[3].name = "DAVID";
            people[3].number = "617–555–0103";
        
            // Procurar por EMMA
            for (int i = 0; i < 4; i++)
            {
                if (strcmp(people[i].name, "EMMA") == 0)
                {
                    printf("Encontrado: %s\n", people[i].number);
                    return 0;
                }
            }
            printf("Não encontrado\n");
            return 1;
        }
        
    
    * Podemos pensar em structs como contentores, dentro dos quais existem vários outros tipos de dados.
    * Aqui, criamos o nosso próprio tipo com uma struct chamada `person`, que terá uma `string` chamada `name` e uma `string` chamada `number`. Então, podemos criar um array desses tipos de struct e inicializar os valores dentro de cada um deles, usando uma nova sintaxe, `.`, para acessar as propriedades de cada `person`.
    * No nosso loop, agora podemos ter mais certeza de que o `number` corresponde ao `name`, pois eles são do mesmo elemento `person`.

Ordenação
-------

* Se a nossa entrada for uma lista não ordenada de números, existem vários algoritmos que podemos usar para produzir uma lista ordenada.
* Com oito voluntários no palco com os seguintes números, podemos considerar trocar pares de números adjacentes como o primeiro passo.
* Nossos voluntários começam na seguinte ordem aleatória:
    
        6 3 8 5 2 7 4 1
        
    
* Olhamos para os dois primeiros números e os trocamos para que fiquem em ordem:
    
        6 3 8 5 2 7 4 1
        – –
        3 6 8 5 2 7 4 1
        
    
* O próximo par, `6` e `8`, já está em ordem, então não precisamos trocá-los.
* O próximo par, `8` e `5`, precisa ser trocado:
    
        3 6 8 5 2 7 4 1
            – –
        3 6 5 8 2 7 4 1
        
    
* Continuamos até chegar ao final da lista:
    
        3 6 5 2 8 7 4 1
                – –
        3 6 5 2 7 8 4 1
                  – –
        3 6 5 2 7 4 8 1
                    – –
        3 6 5 2 7 4 1 8
        
    
* Não ordenamos ainda a nossa lista, mas estamos um pouco mais perto da solução, porque o maior valor, `8`, foi movido para a extrema direita.
* Repetimos isso com mais uma passagem pela lista:
    
        3 6 5 2 7 4 1 8
        – –
        3 6 5 2 7 4 1 8
          – –
        3 5 6 2 7 4 1 8
            – –
        3 5 2 6 7 4 1 8
              – –
        3 5 2 6 7 4 1 8
                – –
        3 5 2 6 4 7 1 8
                    – –
        3 5 2 6 4 1 7 8
        
    
    * Note que não precisamos trocar o 3 e o 6, ou o 6 e o 7.
* Agora, o próximo maior valor, `7`, foi movido para a extrema direita. Se repetirmos isso, mais e mais da lista ficará ordenada e, rapidamente, teremos uma lista totalmente ordenada.
* Esse algoritmo é chamado de **ordenamento por bolha**, onde valores grandes "borbulham" para a direita. O pseudocódigo para isso pode parecer com:
    
        Repetir n–1 vezes
            Para i de 0 até n–2
                Se os i-ésimo e i+1-ésimo elementos estiverem fora de ordem
                    Trocá-los
        
    
    * Como estamos comparando o i-ésimo e o i+1-ésimo elemento, só precisamos ir até _n_ – 2 para o `i`. Em seguida, trocamos os dois elementos se eles estiverem fora de ordem.
    * E podemos parar depois de fazermos _n_ – 1 passagens, já que sabemos que os _n_-1 maiores elementos terão borbulhado para a direita.
* Temos _n_ – 2 etapas para o loop interno e _n_ – 1 loops, então obtemos um total de _n_2 – 3_n_ + 2 etapas. Mas o termo dominante é _n_2, à medida que `n` fica cada vez maior, então podemos dizer que o ordenamento por bolha é _O_(_n_2).
* Já vimos tempos de execução como os seguintes e, mesmo que a busca binária seja muito mais rápida do que a busca linear, pode não valer o custo único de ordenar a lista primeiro, a menos que façamos muitas pesquisas ao longo do tempo:
    * _O_(_n_2)
        * ordenamento por bolha
    * _O_(_n_ log _n_)
    * _O_(_n_)
        * busca linear
    * _O_(log _n_)
        * busca binária
    * _O_(1)
* E Ω para o ordenamento por bolha ainda é _n_2, já que ainda verificamos cada par de elementos para _n_ – 1 passagens.

Ordenação por seleção
--------------

* Podemos adotar uma abordagem diferente com o mesmo conjunto de números:

        6 3 8 5 2 7 4 1
        

* Primeiro, vamos analisar cada número e lembrar o menor número que encontramos. Em seguida, podemos trocá-lo com o primeiro número da nossa lista, já que sabemos que é o menor:

        6 3 8 5 2 7 4 1
        –             –
        1 3 8 5 2 7 4 6
        

* Agora sabemos que pelo menos o primeiro elemento da nossa lista está no lugar certo, então podemos procurar o menor elemento entre os restantes e trocá-lo com o próximo elemento não ordenado (agora o segundo elemento):

        1 3 8 5 2 7 4 6
          –     –
        1 2 8 5 3 7 4 6
        

* Podemos repetir esse processo várias vezes, até obtermos uma lista ordenada.
* Esse algoritmo é chamado de **ordenação por seleção** e poderíamos escrever um pseudocódigo assim:

        Para i de 0 a n–1
            Encontre o item mais pequeno entre o i-ésimo item e o último item
            Troque o item mais pequeno pelo i-ésimo item
        
    
* Com notação _O_ grande, ainda temos uma complexidade de tempo de execução de _O_(_n_2), pois estamos olhando aproximadamente para todos os _n_ elementos para encontrar o menor e fazendo _n_ passagens para ordenar todos os elementos.
* Mais formalmente, podemos usar algumas fórmulas para mostrar que o maior fator é realmente _n_2:

        n + (n – 1) + (n – 2) + ... + 1
        n(n + 1)/2
        (n^2 + n)/2
        n^2/2 + n/2
        O(n^2)
        
    
* Portanto, descobrimos que a ordenação por seleção é fundamentalmente igual à ordenação por bolha em termos de tempo de execução:
    *   _O_(_n_2)
        *   ordenação por bolha, ordenação por seleção
    *   _O_(_n_ log _n_)
    *   _O_(_n_)
        *   busca linear
    *   _O_(log _n_)
        *   busca binária
    *   _O_(1)
* O melhor caso, Ω, também é _n_2.
* Podemos voltar à ordenação por bolha e alterar seu algoritmo para algo assim, o que nos permitirá parar cedo se todos os elementos estiverem ordenados:

        Repita até não haver trocas
            Para i de 0 a n–2
                Se o i-ésimo e o (i+1)-ésimo elementos estiverem fora de ordem
                    Troque-os
        
    
    * Agora, só precisamos analisar cada elemento uma vez, então o melhor caso agora é Ω(_n_):
        *   Ω(_n_2)
            *   ordenação por seleção
        *   Ω(_n_ log _n_)
        *   Ω(_n_)
            *   ordenação por bolha
        *   Ω(log _n_)
        *   Ω(1)
            *   busca linear, busca binária
* Podemos ver uma visualização online [comparando algoritmos de ordenação](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html) com animações que mostram como os elementos se movem dentro dos arrays tanto para a ordenação por bolha quanto para a ordenação por seleção.

Recursão
--------

*   Lembre-se de que na semana 0, tínhamos um pseudocódigo para encontrar um nome em uma lista telefônica, onde tínhamos linhas nos dizendo para "voltar" e repetir algumas etapas:

        1  Pegue a lista telefônica
        2  Abra no meio da lista telefônica
        3  Olhe a página
        4  Se Smith estiver na página
        5      Ligue para Mike
        6  Senão, se Smith estiver antes do meio da lista
        7      Abra no meio da metade esquerda da lista
        8      **Volte para a linha 3**
        9  Senão, se Smith estiver depois do meio da lista
        10     Abra no meio da metade direita da lista
        11     **Volte para a linha 3**
        12 Senão
        13     Saia
        
    
*   Em vez disso, poderíamos simplesmente repetir todo o nosso algoritmo na metade da lista restante:

        1  Pegue a lista telefônica
        2  Abra no meio da lista telefônica
        3  Olhe a página
        4  Se Smith estiver na página
        5      Ligue para Mike
        6  Senão, se Smith estiver antes do meio da lista
        7      **Pesquise na metade esquerda da lista**
        8
        9  Senão, se Smith estiver depois do meio da lista
        10     **Pesquise na metade direita da lista**
        11
        12 Senão
        13     Saia
        
    
    *   Isso parece um processo cíclico que nunca terminará, mas na verdade estamos dividindo o problema pela metade a cada vez e parando quando não há mais lista restante.
*   **Recursão** ocorre quando uma função ou algoritmo se refere a si mesma, como no novo pseudocódigo acima.
*   Na semana 1 também implementamos uma "pirâmide" de blocos no seguinte formato:

        #
        ##
        ###
        ####
        
    
    *   E poderíamos ter código iterativo como este:
        
            #include <cs50.h>
            #include <stdio.h>
            
            void draw(int h);
            
            int main(void)
            {
                // Obtenha a altura da pirâmide
                int altura = get_int("Altura: ");
            
                // Desenhe a pirâmide
                draw(altura);
            }
            
            void draw(int h)
            {
                // Desenhe uma pirâmide de altura h
                for (int i = 1; i <= h; i++)
                {
                    for (int j = 1; j <= i; j++)
                    {
                        printf("#");
                    }
                    printf("\n");
                }
            }
            
        
        *   Aqui, usamos `for` loops para imprimir cada bloco em cada linha.
*   Mas observe que uma pirâmide de altura 4 é na verdade uma pirâmide de altura 3, com uma linha extra de 4 blocos adicionados. E uma pirâmide de altura 3 é uma pirâmide de altura 2, com uma linha extra de 3 blocos. Uma pirâmide de altura 2 é uma pirâmide de altura 1, com uma linha extra de 2 blocos. E finalmente, uma pirâmide de altura 1 é apenas uma pirâmide de altura 0, ou nada, com mais uma linha adicionada contendo um único bloco.
*   Com essa ideia em mente, podemos escrever:

        #include <cs50.h>
        #include <stdio.h>
        
        void draw(int h);
        
        int main(void)
        {
            // Obtenha a altura da pirâmide
            int altura = get_int("Altura: ");
        
            // Desenhe a pirâmide
            draw(altura);
        }
        
        void draw(int h)
        {
            // Se não houver nada para desenhar
            if (h == 0)
            {
                return;
            }
        
            // Desenhe uma pirâmide de altura h - 1
            draw(h - 1);
        
            // Desenhe mais uma linha com largura h
            for (int i = 0; i < h; i++)
            {
                printf("#");
            }
            printf("\n");
        }
        
    
    *   Agora, nossa função `draw` primeiro chama a si mesma **recursivamente**, desenhando uma pirâmide de altura `h - 1`. Mas antes mesmo disso, precisamos parar se `h` for igual a 0, já que não haverá mais nada para ser desenhado.
    *   Depois, desenhamos a próxima linha ou uma linha com largura `h`.


Ordenação por intercalação
----------

* Podemos aplicar a ideia de recursão à ordenação, com um outro algoritmo chamado ordenação por intercalação. O pseudocódigo pode ser assim:

        Se tiver apenas um item
          Retorne
        Senão
            Ordenar a metade esquerda dos itens
            Ordenar a metade direita dos itens
            Intercalar as metades ordenadas
        
    
* Podemos entender melhor com uma lista não ordenada como exemplo:
    
        7 4 5 2 6 3 8 1
        
    
* Primeiramente, vamos ordenar a metade esquerda (os primeiros quatro elementos):
    
        7 4 5 2 | 6 3 8 1
        – – – –
        
    
* Para ordenar isso, precisamos primeiro ordenar a metade esquerda da metade esquerda:
    
        7 4 | 5 2 | 6 3 8 1
        – –
        
    
* Agora, temos apenas um item, `7`, na metade esquerda, e um item, `4`, na metade direita. Então, vamos intercalar os dois, pegando o item menor de cada lista primeiro:
    
        – – | 5 2 | 6 3 8 1
        4 7
        
    
* Agora voltamos para a metade direita da metade esquerda e a ordenamos:
    
        – – | – – | 6 3 8 1
        4 7 | 2 5
        
    
* Agora que ambas as metades da metade esquerda estão ordenadas, podemos intercalá-las. Olhamos para o início de cada lista e pegamos o `2` já que é menor que `4`. Em seguida, pegamos o `4` pois é o menor item do início de ambas as listas. Em seguida, pegamos o `5` e finalmente o `7`, dando-nos:
    
        – – – – | 6 3 8 1
        – – – –
        2 4 5 7
        
    
* Agora vamos ordenar a metade direita da mesma maneira. Primeiro, a metade esquerda da metade direita:
    
        – – – – | – – | 8 1
        – – – – | 3 6 |
        2 4 5 7
        
    
* Em seguida, a metade direita da metade direita:
    
        – – – – | – – | – –
        – – – – | 3 6 | 1 8
        2 4 5 7
        
    
* Podemos intercalar a metade direita agora:
    
        – – – – | – – – –
        – – – – | – – – –
        2 4 5 7 | 1 3 6 8
        
    
* Por fim, podemos intercalar ambas as metades da lista completa, seguindo os mesmos passos de antes. Observe que não precisamos verificar todos os elementos de cada metade para encontrar o menor, pois sabemos que cada metade já está ordenada. Em vez disso, pegamos o elemento menor das duas metades no início de cada uma:
    
        – – – – | – – – –
        – – – – | – – – –
        2 4 5 7 | – 3 6 8
        1
        
    
        – – – – | – – – –
        – – – – | – – – –
        – 4 5 7 | – 3 6 8
        1 2
        
    
        – – – – | – – – –
        – – – – | – – – –
        – 4 5 7 | – – 6 8
        1 2 3
        
    
        – – – – | – – – –
        – – – – | – – – –
        – – 5 7 | – – 6 8
        1 2 3 4
        
    
        – – – – | – – – –
        – – – – | – – – –
        – – – 7 | – – 6 8
        1 2 3 4   5
        
    
        – – – – | – – – –
        – – – – | – – – –
        – – – 7 | – – – 8
        1 2 3 4   5 6
        
    
        – – – – | – – – –
        – – – – | – – – –
        – – – – | – – – 8
        1 2 3 4   5 6 7
        
    
        – – – – | – – – –
        – – – – | – – – –
        – – – – | – – – –
        1 2 3 4   5 6 7 8
        
    
* Foram necessários diversos passos, mas na verdade foram menos passos do que nos outros algoritmos que vimos até agora. Dividimos nossa lista pela metade a cada vez, até estarmos "ordenando" oito listas com apenas um elemento cada:
    
        7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
        4   7 | 2   5 | 3   6 | 1   8
        2   4   5   7 | 1   3   6   8
        1   2   3   4   5   6   7   8
        
    
* Como nosso algoritmo dividiu o problema pela metade a cada vez, seu tempo de execução é logarítmico com _O_(log _n_). E depois de ordenarmos cada metade (ou metade de uma metade), precisamos intercalar todos os elementos, com _n_ passos, já que precisamos olhar cada elemento uma vez.
* Portanto, nosso tempo de execução total é _O_(_n_ log _n_):
    * _O_(_n_2)
        * ordenação bolha (bubble sort), ordenação por seleção (selection sort)
    * _O_(_n_ log _n_)
        * ordenação por intercalação (merge sort)
    * _O_(_n_)
        * busca linear (linear search)
    * _O_(log _n_)
        * busca binária (binary search)
    * _O_(1)
* Como log _n_ é maior que 1, mas menor que _n_, _n_ log _n_ está entre _n_ (vezes 1) e _n_2.
* O melhor caso, Ω, ainda é _n_ log _n_, pois ainda ordenamos cada metade primeiro e depois as intercalamos:
    * Ω(_n_2)
        * ordenação por seleção (selection sort)
    * Ω(_n_ log _n_)
        * ordenação por intercalação (merge sort)
    * Ω(_n_)
        * ordenação bolha (bubble sort)
    * Ω(log _n_)
    * Ω(1)
        * busca linear (linear search), busca binária (binary search)
* Finalmente, há outra notação, Θ, Theta, que usamos para descrever os tempos de execução dos algoritmos se o limite superior e o limite inferior forem os mesmos. Por exemplo, a ordenação por intercalação tem Θ(_n_ log _n_), já que o melhor e o pior caso requerem o mesmo número de passos. E a ordenação por seleção tem Θ(_n_2).
* Podemos ver uma [visualização final](https://www.youtube.com/watch?v=ZZuD6iUe3Pc) dos algoritmos de ordenação com um maior número de entradas, executando ao mesmo tempo.

