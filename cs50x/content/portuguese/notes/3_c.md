Ficheiros Markdown
-------

* Descobrimos que podemos criar os nossos próprios tipos de dados personalizados chamados de **structs**:
    
        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>
        
        typedef struct
        {
            string name;
            string number;
        }
        person;
        
        int main(void)
        {
            person people[4];
        
            people[0].name = "EMMA";
            people[0].number = "617–555–0100";
        
            people[1].name = "RODRIGO";
            people[1].number = "617–555–0101";
        
            people[2].name = "BRIAN";
            people[2].number = "617–555–0102";
        
            people[3].name = "DAVID";
            people[3].number = "617–555–0103";
        
            // Procurar por EMMA
            for (int i = 0; i < 4; i++)
            {
                if (strcmp(people[i].name, "EMMA") == 0)
                {
                    printf("Encontrado: %s\n", people[i].number);
                    return 0;
                }
            }
            printf("Não encontrado\n");
            return 1;
        }
        
    
    * Podemos pensar em structs como contentores, dentro dos quais existem vários outros tipos de dados.
    * Aqui, criamos o nosso próprio tipo com uma struct chamada `person`, que terá uma `string` chamada `name` e uma `string` chamada `number`. Então, podemos criar um array desses tipos de struct e inicializar os valores dentro de cada um deles, usando uma nova sintaxe, `.`, para acessar as propriedades de cada `person`.
    * No nosso loop, agora podemos ter mais certeza de que o `number` corresponde ao `name`, pois eles são do mesmo elemento `person`.

Ordenação
-------

* Se a nossa entrada for uma lista não ordenada de números, existem vários algoritmos que podemos usar para produzir uma lista ordenada.
* Com oito voluntários no palco com os seguintes números, podemos considerar trocar pares de números adjacentes como o primeiro passo.
* Nossos voluntários começam na seguinte ordem aleatória:
    
        6 3 8 5 2 7 4 1
        
    
* Olhamos para os dois primeiros números e os trocamos para que fiquem em ordem:
    
        6 3 8 5 2 7 4 1
        – –
        3 6 8 5 2 7 4 1
        
    
* O próximo par, `6` e `8`, já está em ordem, então não precisamos trocá-los.
* O próximo par, `8` e `5`, precisa ser trocado:
    
        3 6 8 5 2 7 4 1
            – –
        3 6 5 8 2 7 4 1
        
    
* Continuamos até chegar ao final da lista:
    
        3 6 5 2 8 7 4 1
                – –
        3 6 5 2 7 8 4 1
                  – –
        3 6 5 2 7 4 8 1
                    – –
        3 6 5 2 7 4 1 8
        
    
* Não ordenamos ainda a nossa lista, mas estamos um pouco mais perto da solução, porque o maior valor, `8`, foi movido para a extrema direita.
* Repetimos isso com mais uma passagem pela lista:
    
        3 6 5 2 7 4 1 8
        – –
        3 6 5 2 7 4 1 8
          – –
        3 5 6 2 7 4 1 8
            – –
        3 5 2 6 7 4 1 8
              – –
        3 5 2 6 7 4 1 8
                – –
        3 5 2 6 4 7 1 8
                    – –
        3 5 2 6 4 1 7 8
        
    
    * Note que não precisamos trocar o 3 e o 6, ou o 6 e o 7.
* Agora, o próximo maior valor, `7`, foi movido para a extrema direita. Se repetirmos isso, mais e mais da lista ficará ordenada e, rapidamente, teremos uma lista totalmente ordenada.
* Esse algoritmo é chamado de **ordenamento por bolha**, onde valores grandes "borbulham" para a direita. O pseudocódigo para isso pode parecer com:
    
        Repetir n–1 vezes
            Para i de 0 até n–2
                Se os i-ésimo e i+1-ésimo elementos estiverem fora de ordem
                    Trocá-los
        
    
    * Como estamos comparando o i-ésimo e o i+1-ésimo elemento, só precisamos ir até _n_ – 2 para o `i`. Em seguida, trocamos os dois elementos se eles estiverem fora de ordem.
    * E podemos parar depois de fazermos _n_ – 1 passagens, já que sabemos que os _n_-1 maiores elementos terão borbulhado para a direita.
* Temos _n_ – 2 etapas para o loop interno e _n_ – 1 loops, então obtemos um total de _n_2 – 3_n_ + 2 etapas. Mas o termo dominante é _n_2, à medida que `n` fica cada vez maior, então podemos dizer que o ordenamento por bolha é _O_(_n_2).
* Já vimos tempos de execução como os seguintes e, mesmo que a busca binária seja muito mais rápida do que a busca linear, pode não valer o custo único de ordenar a lista primeiro, a menos que façamos muitas pesquisas ao longo do tempo:
    * _O_(_n_2)
        * ordenamento por bolha
    * _O_(_n_ log _n_)
    * _O_(_n_)
        * busca linear
    * _O_(log _n_)
        * busca binária
    * _O_(1)
* E Ω para o ordenamento por bolha ainda é _n_2, já que ainda verificamos cada par de elementos para _n_ – 1 passagens.