Layout de Memória
-------------

*   Dentro da memória do nosso computador, os diferentes tipos de dados que precisam ser armazenados para o nosso programa são organizados em diferentes seções:
    ![Grade com seções, de cima para baixo: código de máquina, globais, heap (com seta apontando para baixo), stack (com seta apontando para cima)](https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png)
    *   A seção _código de máquina_ é o código binário do nosso programa compilado. Quando executamos nosso programa, esse código é carregado no "topo" da memória.
    *   _Globais_ são variáveis globais que declaramos em nosso programa ou outras variáveis compartilhadas que todo o nosso programa pode acessar.
    *   A seção _heap_ é uma área vazia onde o `malloc` pode obter memória livre para o nosso programa usar.
    *   A seção _stack_ é usada pelas funções em nosso programa conforme elas são chamadas. Por exemplo, nossa função `main` está na parte inferior da stack e possui as variáveis locais `x` e `y`. A função `swap`, quando chamada, tem seu próprio quadro, ou "fatia", de memória que está no topo do quadro de `main`, com as variáveis locais `a`, `b` e `tmp`:
        ![Seção da stack com (a, b, tmp) acima de (x, y)](https://cs50.harvard.edu/x/2020/notes/4/stack.png)
        *   Uma vez que a função `swap` retorna, a memória que ela estava usando é liberada para a próxima chamada de função, e perdemos qualquer coisa que fizemos, exceto os valores de retorno, e nosso programa volta para a função que chamou `swap`.
        *   Portanto, ao passar os endereços de `x` e `y` de `main` para `swap`, podemos alterar os valores de `x` e `y`: ![Seção da stack com (a, b, tmp) acima de (x, y), e a apontando para x e b apontando para y](https://cs50.harvard.edu/x/2020/notes/4/pointers.png)
*   Ao passar o endereço de `x` e `y`, nossa função `swap` pode realmente funcionar:

    #include <stdio.h>
    
    void swap(int *a, int *b);
    
    int main(void)
    {
        int x = 1;
        int y = 2;
    
        printf("x é %i, y é %i\n", x, y);
        swap(&x, &y);
        printf("x é %i, y é %i\n", x, y);
    }
    
    void swap(int *a, int *b)
    {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
    

    *   Os endereços de `x` e `y` são passados de `main` para `swap`, e usamos a sintaxe `int *a` para declarar que nossa função `swap` recebe ponteiros. Salvamos o valor de `x` em `tmp` seguindo o ponteiro `a`, então pegamos o valor de `y` seguindo o ponteiro `b` e armazenamos isso no local para onde `a` está apontando (`x`). Por fim, armazenamos o valor de `tmp` no local apontado por `b` (`y`), e estamos prontos.
*   Se chamarmos `malloc` muitas vezes, teremos um **estouro do heap**, onde ultrapassamos o tamanho do heap. Ou, se tivermos muitas funções sendo chamadas, teremos um **estouro da stack**, onde nossa stack tem muitos quadros de memória alocados também. E esses dois tipos de estouro geralmente são conhecidos como estouros de buffer, após os quais nosso programa (ou computador inteiro) pode travar.

get\_int
--------

*   Podemos implementar `get_int` nós mesmos com uma função da biblioteca C, `scanf`:

    #include <stdio.h>
    
    int main(void)
    {
        int x;
        printf("x: ");
        scanf("%i", &x);
        printf("x: %i\n", x);
    }
    

    *   `scanf` recebe um formato, `%i`, então a entrada é "escaneada" para esse formato e o endereço na memória onde queremos que essa entrada vá. Mas `scanf` não possui muita verificação de erros, então talvez não obtenhamos um número inteiro.
*   Podemos tentar obter uma string da mesma maneira:

    #include <stdio.h>
    
    int main(void)
    {
        char *s = NULL;
        printf("s: ");
        scanf("%s", s);
        printf("s: %s\n", s);
    }
    

    *   Mas na verdade não alocamos nenhuma memória para `s` (`s` é `NULL`, ou não está apontando para nada), então talvez queiramos chamar `char s[5]` para alocar um array de 5 caracteres para nossa string. Em seguida, `s` será tratado como um ponteiro em `scanf` e `printf`.
    *   Agora, se o usuário digitar uma string com comprimento igual ou menor que 4, nosso programa funcionará com segurança. Mas se o usuário digitar uma string mais longa, `scanf` pode estar tentando escrever além do final de nosso array em memória desconhecida, causando o travamento de nosso programa.