Aula 1
=========

*   [C](#c)
*   [olá, mundo](#hello-world)
*   [Compiladores](#compilers)
*   [String](#string)
*   [Blocos Scratch em C](#scratch-blocks-in-c)
*   [Tipos, formatos, operadores](#types-formats-operators)
*   [Mais exemplos](#more-examples)
    *   [Telas](#screens)
*   [Memória, imprecisão e overflow](#memory-imprecision-and-overflow)

C
-

*   Hoje vamos aprender uma nova linguagem, **C**: uma linguagem de programação que tem todos os recursos do Scratch e mais, mas talvez seja um pouco menos amigável, já que é puramente em texto:
    
        #include <stdio.h>
        
        int main(void)
        {
            printf("olá, mundo\n");
        }
        
    
    *   Embora as palavras sejam novas, as ideias são exatamente as mesmas dos blocos "quando a bandeira verde for clicada" e "dizer (olá, mundo)" no Scratch:  
        ![bloco rotulado 'quando a bandeira verde for clicada', bloco rotulado 'dizer (olá, mundo)'](https://cs50.harvard.edu/x/2020/notes/1/when_green_flag.png)
*   Embora criptico, não se esqueça de que 2/3 dos estudantes do CS50 nunca estudaram CS antes, então não se intimide! E embora no início, para emprestar uma frase do MIT, tentar absorver todos esses novos conceitos possa parecer como beber água de uma mangueira de incêndio, tenha a certeza de que no final do semestre estaremos empoderados e experientes em aprender e aplicar esses conceitos.
*   Podemos comparar muitas das construções em C com blocos que já vimos e usamos no Scratch. A sintaxe é muito menos importante do que os princípios, aos quais já fomos apresentados.

olá, mundo
------------

*   O bloco "quando a bandeira verde for clicada" no Scratch inicia o programa principal; clicar na bandeira verde faz com que o conjunto correto de blocos abaixo comece a ser executado. Em C, a primeira linha para o mesmo é `int main(void)`, o que aprenderemos mais sobre nas próximas semanas, seguido de uma chave aberta `{` e uma chave fechada `}`, envolvendo tudo o que deve estar em nosso programa.

        int main(void)
        {
        
        }
        
    
*   O bloco "dizer (olá, mundo)" é uma função e corresponde a `printf("olá, mundo");`. Em C, a função para imprimir algo na tela é `printf`, onde `f` significa "formato", o que significa que podemos formatar a string impressa de diferentes maneiras. Em seguida, usamos parênteses para passar o que queremos imprimir. Temos que usar aspas duplas para cercar nosso texto para que ele seja entendido como texto, e finalmente, adicionamos um ponto e vírgula `;` para encerrar esta linha de código.
*   Para fazer nosso programa funcionar, também precisamos de outra linha no topo, uma linha de cabeçalho `#include <stdio.h>` que define a função `printf` que queremos usar. Em algum lugar do nosso computador, há um arquivo, `stdio.h`, que inclui o código que nos permite acessar a função `printf`, e a linha `#include` diz ao computador para incluir esse arquivo em nosso programa.
*   Para escrever nosso primeiro programa no Scratch, abrimos o site do Scratch. Da mesma forma, usaremos o [CS50 Sandbox](https://sandbox.cs50.io/) para começar a escrever e executar código da mesma maneira. O CS50 Sandbox é um ambiente virtual baseado em nuvem com as bibliotecas e ferramentas já instaladas para escrever programas em várias linguagens. Na parte superior, há um editor de código simples, onde podemos digitar texto. Abaixo, temos uma janela do terminal na qual podemos digitar comandos:
    ![dois painéis, parte superior rotulada hello.c, parte inferior rotulada Terminal](https://cs50.harvard.edu/x/2020/notes/1/cs50_sandbox.png)
*   Digitaremos nosso código anterior no topo, após usar o sinal de `+` para criar um novo arquivo chamado `hello.c`:
    ![olá, mundo no editor](https://cs50.harvard.edu/x/2020/notes/1/editor.png)
*   Terminamos o arquivo do nosso programa com `.c` por convenção, para indicar que é um programa em C. Observe que nosso código está colorizado, para que certas coisas sejam mais visíveis.


Compiladores
---------

*   Uma vez que salvamos o código que escrevemos, chamado de **código-fonte**, precisamos convertê-lo em **código de máquina**, instruções binárias que o computador entende diretamente.
*   Usamos um programa chamado **compilador** para compilar nosso código-fonte em código de máquina.
*   Para fazer isso, usamos o painel do **Terminal**, que possui um **prompt de comando**. O `$` à esquerda é um prompt, após o qual podemos digitar comandos.
    *   Digitamos `clang hello.c` (onde `clang` significa "C languages", um compilador escrito por um grupo de pessoas). Mas antes de pressionarmos enter, clique no ícone da pasta no canto superior esquerdo do CS50 Sandbox. Vemos nosso arquivo, `hello.c`. Então pressionamos enter na janela do terminal e vemos que agora temos outro arquivo chamado `a.out` (abreviação de "assembly output"). Dentro desse arquivo está o código do nosso programa, em binário. Agora, podemos digitar `./a.out` no prompt do terminal para executar o programa `a.out` em nossa pasta atual. Acabamos de escrever, compilar e executar nosso primeiro programa!

String
------

*   Mas depois de executarmos nosso programa, vemos `hello, world$`, com o novo prompt na mesma linha que a saída. Acontece que precisamos especificar precisamente que precisamos de uma nova linha após nosso programa, então podemos atualizar nosso código para incluir um caractere de nova linha especial, `\n`:
    
        #include <stdio.h>
        
        int main(void)
        {
            printf("hello, world\n");
        }
        
    
    *   Agora precisamos lembrar de recompilar nosso programa com `clang hello.c` antes de podermos executar essa nova versão.
*   A linha 2 de nosso programa está intencionalmente em branco, pois queremos iniciar uma nova seção de código, assim como iniciar novos parágrafos em ensaios. Não é estritamente necessário para que nosso programa seja executado corretamente, mas ajuda os humanos a lerem programas mais longos com mais facilidade.
*   Podemos alterar o nome de nosso programa de `a.out` para outra coisa também. Podemos passar **argumentos de linha de comando**, ou opções adicionais, para programas no terminal, dependendo do que o programa está escrito para entender. Por exemplo, podemos digitar `clang -o hello hello.c`, e `-o hello` está dizendo ao programa `clang` para salvar a saída compilada apenas como `hello`. Em seguida, podemos simplesmente executar `./hello`.
*   Em nosso prompt de comando, podemos executar outros comandos, como `ls` (listar), que mostra os arquivos em nossa pasta atual:
    
        $ ls
        a.out* hello* hello.c
        
    
    *   O asterisco, `*`, indica que esses arquivos são executáveis, ou que podem ser executados pelo nosso computador.
*   Podemos usar o comando `rm` (remover) para excluir um arquivo:
    
        $ rm a.out
        rm: remove regular file 'a.out'?
        
    
    *   Podemos digitar `y` ou `yes` para confirmar e usar `ls` novamente para ver que ele desapareceu permanentemente.
*   Agora, vamos tentar obter entrada do usuário, como fizemos no Scratch quando queríamos dizer "hello, David":  
    ![captura de tela dos blocos "perguntar qual é o seu nome? e esperar", "dizer junte olá, resposta"](https://cs50.harvard.edu/x/2020/notes/1/ask_say_join.png)
    
        string answer = get_string("Qual é o seu nome?\n");
        printf("hello, %s\n", answer);
        
    
    *   Primeiro, precisamos de uma **string**, ou seja, um pedaço de texto (especificamente, zero ou mais caracteres em sequência entre aspas duplas, como `""`, `"ba"` ou “bananas”), que podemos pedir ao usuário usando a função `get_string`. Passamos o prompt, ou o que queremos perguntar ao usuário, para a função com `"Qual é o seu nome?\n"` dentro dos parênteses. À esquerda, queremos criar uma variável, `answer`, cujo valor será o que o usuário digitar. (O sinal de igual `=` está definindo o valor da direita para a esquerda.) Por fim, o tipo de variável que queremos é `string`, então especificamos isso à esquerda de `answer`.
    *   Em seguida, dentro da função `printf`, queremos o valor de `answer` naquilo que imprimimos. Usamos um espaço reservado para nossa variável de string, `%s`, dentro da frase que queremos imprimir, como `"hello, %s\n"`, e em seguida, damos a `printf` outro argumento, ou opção, para informar que queremos que a variável `answer` seja substituída.
*   Se cometemos um erro, como escrever `printf("hello, world"\n);` com o `\n` fora das aspas duplas para nossa string, veremos erros do nosso compilador:
    
        $ clang -o hello hello.c
        hello.c:5:26: error: expected ')'
            printf("hello, world"\n);
                                 ^
        hello.c:5:11: note: to match this '('
            printf("hello, world"\n);
                  ^
        1 error generated.
        
    
    *   A primeira linha do erro nos diz para olhar para `hello.c`, linha 5, coluna 26, onde o compilador esperava um parêntese de fechamento, em vez de uma barra invertida.
*   Para simplificar as coisas (pelo menos no início), incluiremos uma biblioteca, ou conjunto de código, do CS50. A biblioteca fornece-nos o tipo de variável `string`, a função `get_string` e muito mais. Só temos que escrever uma linha no topo para `include` o arquivo `cs50.h`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, name\n");
        }
        
    
*   Então vamos criar um novo arquivo, `string.c`, com este código:
    
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, %s\n", name);
        }
        
    
*   Agora, se tentarmos compilar esse código, obtemos várias linhas de erros. Às vezes, um erro significa que o compilador passa a interpretar código correto incorretamente, gerando mais erros do que realmente existem. Portanto, começamos com nosso primeiro erro:
    
        $ clang -o string string.c
        string.c:5:5: error: use of undeclared identifier 'string'; did you mean 'stdin'?
          string name = get_string("Qual é o seu nome?\n");
          ^~~~~~
          stdin
        /usr/include/stdio.h:135:25: note: 'stdin' declared here
        extern struct _IO_FILE *stdin;          /* Fluxo de entrada padrão.  */
        
    
    *   Não queríamos dizer `stdin` (entrada padrão) em vez de `string`, portanto, essa mensagem de erro não foi útil. Na verdade, precisamos importar outro arquivo que defina o tipo `string` (na verdade, uma rodinha de treinamento do CS50, como descobriremos nas próximas semanas).
*   Portanto, podemos incluir outro arquivo, `cs50.h`, que também inclui a função `get_string`, entre outras.
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Qual é o seu nome?\n");
            printf("hello, %s\n", name);
        }
        
    
*   Agora, quando tentamos compilar nosso programa, temos apenas um erro:
    
        $ clang -o string string.c
        /tmp/string-aca94d.o: In function `main':
        string.c:(.text+0x19): undefined reference to `get_string'
        clang-7: error: comando do vinculador falhou com o código de saída 1 (use -v para ver a invocação)
        
    
    *   Acontece que também precisamos dizer ao compilador para adicionar nosso arquivo especial da biblioteca CS50, com `clang -o string string.c -lcs50`, com `-l` para "link".
*   Podemos até abstrair isso e simplesmente digitar `make string`. Vemos que, por padrão no CS50 Sandbox, `make` usa `clang` para compilar nosso código de `string.c` em `string`, com todos os argumentos necessários, ou flags, passados.
'

Blocos Scratch em C
-------------------

*   O bloco "definir \[contador\] para (0)" está criando uma variável, e em C nós escreveríamos `int contador = 0;`, onde `int` especifica que o tipo da nossa variável é um inteiro:
    ![bloco rotulado 'definir contador para (0)'](https://cs50.harvard.edu/x/2020/notes/1/set_counter_to_0.png)
*   "mudar \[contador\] por (1)" é `contador = contador + 1;` em C. (Em C, o `=` não é como um sinal de igual em uma equação, onde estamos dizendo que `contador` é o mesmo que `contador + 1`. Em vez disso, `=` é um operador de atribuição que significa "copie o valor à direita para o valor à esquerda".) E observe que não precisamos mais dizer `int`, já que presumimos que já especificamos anteriormente que `contador` é um `int`, com algum valor existente. Também podemos dizer `contador += 1;` ou `contador++;`, ambos têm o mesmo efeito com menos caracteres para digitar.
    ![bloco rotulado 'mudar contador por (1)'](https://cs50.harvard.edu/x/2020/notes/1/change_counter_by_1.png)
*   Uma condição seria mapeada como:
    ![bloco rotulado 'se < (x) < (y)>', dentro do qual há um bloco rotulado 'dizer (x é menor que y)'](https://cs50.harvard.edu/x/2020/notes/1/if_x_y.png)
    
        if (x < y)
        {
            printf("x é menor que y\n");
        }
        
    
    *   Observe que em C usamos `{` e `}` (bem como indentação) para indicar como as linhas de código devem ser aninhadas.
*   Também podemos ter condições de if-else:
    ![bloco rotulado 'se < (x) < (y)>', dentro do qual há um bloco rotulado 'dizer (x é menor que y)', bloco pai também tem um 'senão', dentro do qual há um bloco rotulado 'dizer (x não é menor que y)'](https://cs50.harvard.edu/x/2020/notes/1/if_else.png)
    
        if (x < y)
        {
            printf("x é menor que y\n");
        }
        else
        {
            printf("x não é menor que y\n");
        }
        
    
    *   Observe que as linhas de código que não são uma ação em si (`if...` e as chaves) não terminam com um ponto e vírgula.
*   E até mesmo `else if`:
    ![bloco rotulado 'se < (x) < (y)>', dentro do qual há um bloco rotulado 'dizer (x é menor que y)', bloco pai também tem um 'senão', dentro do qual há um aninhamento de um bloco rotulado 'se < (x) > (y) >', dentro do qual há um bloco rotulado 'dizer (x é maior que y)', bloco pai também tem um 'senão', dentro do qual há um bloco rotulado 'se < (x) = (y) >', dentro do qual há um bloco rotulado 'dizer (x é igual a y)'](https://cs50.harvard.edu/x/2020/notes/1/if_else_if.png)
    
        if (x < y)
        {
            printf("x é menor que y\n");
        }
        else if (x > y)
        {
            printf("x é maior que y\n");
        }
        else if (x == y)
        {
            printf("x é igual a y\n");
        }
        
    
    *   Observe que, para comparar dois valores em C, usamos `==`, dois sinais de igual.
    *   E, logicamente, não precisamos do `if (x == y)` na condição final, já que esse é o único caso restante, e podemos usar apenas `else`.
*   Loops podem ser escritos da seguinte forma:
    ![bloco rotulado 'para sempre', dentro do qual há um bloco rotulado 'dizer (olá, mundo)'](https://cs50.harvard.edu/x/2020/notes/1/forever.png)
    
        while (true)
        {
            printf("olá, mundo\n");
        }
        
    
    *   A palavra-chave `while` também requer uma condição, então usamos `true` como a expressão booleana para garantir que nosso loop será executado para sempre. Nosso programa verificará se a expressão avalia para `true` (o que sempre acontecerá neste caso) e então executará as linhas dentro das chaves. Em seguida, ele repetirá isso até que a expressão não seja mais verdadeira (o que não mudará neste caso).
*   Podemos fazer algo um certo número de vezes com `while`:
    ![bloco rotulado 'repetir (50)', dentro do qual há um bloco rotulado 'dizer (olá, mundo)'](https://cs50.harvard.edu/x/2020/notes/1/repeat.png)
    
        int i = 0;
        while (i < 50)
        {
            printf("olá, mundo\n");
            i++;
        }
        
    
    *   Criamos uma variável, `i`, e a definimos como 0. Então, enquanto `i < 50`, executamos algumas linhas de código e adicionamos 1 a `i` após cada execução.
    *   As chaves em torno das duas linhas dentro do loop `while` indicam que essas linhas se repetirão, e podemos adicionar linhas adicionais ao nosso programa depois, se desejarmos.
*   Para fazer a mesma repetição, mais comumente usamos a palavra-chave `for`:
    
        for (int i = 0; i < 50; i++)
        {
            printf("olá, mundo\n");
        }
        
    
    *   Novamente, primeiro criamos uma variável chamada `i` e a definimos como 0. Em seguida, verificamos se `i < 50` toda vez que alcançamos o topo do loop, antes de executar qualquer código dentro. Se essa expressão for verdadeira, executamos o código interno. Por fim, depois de executarmos o código interno, usamos `i++` para adicionar um a `i`, e o loop se repete.

Tipos, formatos, operadores
-------------------------

*   Existem outros tipos que podemos usar para nossas variáveis
    *   `bool`, uma expressão booleana de `true` ou `false`
    *   `char`, um único caractere como `a` ou `2`
    *   `double`, um valor de ponto flutuante com ainda mais dígitos
    *   `float`, um valor de ponto flutuante ou número real com um valor decimal
    *   `int`, inteiros até um certo tamanho ou número de bits
    *   `long`, inteiros com mais bits, permitindo contar mais alto
    *   `string`, uma sequência de caracteres
*   A biblioteca CS50 possui funções correspondentes para obter entrada de vários tipos:
    *   `get_char`
    *   `get_double`
    *   `get_float`
    *   `get_int`
    *   `get_long`
    *   `get_string`
*   Para o `printf`, também existem diferentes espaços reservados para cada tipo:
    *   `%c` para caracteres
    *   `%f` para floats, doubles
    *   `%i` para inteiros
    *   `%li` para longs
    *   `%s` para strings
*   E existem alguns operadores matemáticos que podemos usar:
    *   `+` para adição
    *   `-` para subtração
    *   `*` para multiplicação
    *   `/` para divisão
    *   `%` para resto

Mais exemplos
=============

*   Para cada um desses exemplos, você pode clicar nos [links de sandbox](../../weeks/1/) para executar e editar suas próprias cópias deles.
*   No arquivo `int.c`, obtemos e imprimimos um número inteiro:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            int age = get_int("Qual a sua idade?\n");
            int days = age * 365;
            printf("Você tem pelo menos %i dias de idade.\n", days);
        }
        
    
    *   Observe que usamos `%i` para imprimir um número inteiro.
    *   Agora podemos executar `make int` e rodar nosso programa com `./int`.
    *   Podemos combinar linhas e remover a variável `days` com:
        
            int age = get_int("Qual a sua idade?\n");
            printf("Você tem pelo menos %i dias de idade.\n", age * 365);
            
        
    *   Ou até mesmo combinar tudo em uma única linha:
        
            printf("Você tem pelo menos %i dias de idade.\n", get_int("Qual a sua idade?\n") * 365);
            
        
    *   No entanto, quando uma linha fica muito longa ou complicada, pode ser melhor dividir em duas ou até três linhas para melhorar a legibilidade.
*   No arquivo `float.c`, podemos obter números decimais (chamados de valores de ponto flutuante nos computadores, porque a vírgula decimal pode "flutuar" entre os dígitos, dependendo do número):
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            float price = get_float("Qual é o preço?\n");
            printf("O total é %f.\n", price * 1.0625);
        }
        
    
    *   Agora, se compilarmos e executarmos nosso programa, veremos um preço impresso com imposto.
    *   Podemos especificar o número de dígitos impressos após a vírgula decimal com um espaço reservado como `%.2f` para dois dígitos após a vírgula.
*   Com `parity.c`, podemos verificar se um número é par ou ímpar:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            int n = get_int("n: ");
        
            if (n % 2 == 0)
            {
                printf("par\n");
            }
            else
            {
                printf("ímpar\n");
            }
        }
        
    
    *   Com o operador `%` (módulo), podemos obter o resto de `n` após dividir por 2. Se o resto for 0, sabemos que `n` é par. Caso contrário, sabemos que `n` é ímpar.
    *   E funções como `get_int` da biblioteca CS50 fazem verificação de erros, onde apenas entradas do usuário que correspondem ao tipo que desejamos são aceitas.
*   No arquivo `conditions.c`, transformamos os trechos de condição anteriores em um programa:
    
        // Condições e operadores relacionais
        
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Solicita ao usuário um valor para x
            int x = get_int("x: ");
        
            // Solicita ao usuário um valor para y
            int y = get_int("y: ");
        
            // Compara x e y
            if (x < y)
            {
                printf("x é menor que y\n");
            }
            else if (x > y)
            {
                printf("x é maior que y\n");
            }
            else
            {
                printf("x é igual a y\n");
            }
        }
        
    
    *   Linhas que começam com `//` são comentários, ou notas para os seres humanos que o compilador ignorará.
    *   Para David compilar e executar este programa em seu sandbox, ele precisava executar o comando `cd src1` no terminal. Isso muda o diretório, ou pasta, para aquele em que ele salvou todos os arquivos de origem da palestra. Em seguida, ele pode executar `make conditions` e `./conditions`. Com `pwd`, ele pode ver que está em uma pasta `src1` (dentro de outras pastas). E `cd` sozinho, sem argumentos, nos levará de volta à nossa pasta padrão no sandbox.
*   No arquivo `agree.c`, podemos pedir ao usuário para confirmar ou negar algo:
    
        // Operadores lógicos
        
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Solicita ao usuário para concordar
            char c = get_char("Você concorda?\n");
        
            // Verifica se concordou
            if (c == 'Y' || c == 'y')
            {
                printf("Concordou.\n");
            }
            else if (c == 'N' || c == 'n')
            {
                printf("Não concordou.\n");
            }
        }
        
    
    *   Usamos duas barras verticais, `||`, para indicar um "ou" lógico, ou seja, qualquer uma das expressões pode ser verdadeira para que a condição seja seguida.
    *   E se nenhuma das expressões for verdadeira, nada acontecerá, pois nosso programa não possui um loop.
*   Vamos implementar o programa de tossir da semana 0:
    
        #include <stdio.h>
        
        int main(void)
        {
            printf("tossir\n");
            printf("tossir\n");
            printf("tossir\n");
        }
        
    
*   Poderíamos usar um loop `for`:
    
        #include <stdio.h>
        
        int main(void)
        {
            for (int i = 0; i < 3; i++)
            {
                printf("tossir\n");
            }
        }
        
    
    *   Por convenção, os programadores tendem a começar a contar em 0, então `i` terá os valores `0`, `1` e `2` antes de parar, totalizando três iterações. Também poderíamos escrever `for (int i = 1; i <= 3; i++)` para o mesmo efeito final.
*   Podemos mover a linha `printf` para sua própria função:
    
        #include <stdio.h>
        
        void tossir(void);
        
        int main(void)
        {
            for (int i = 0; i < 3; i++)
            {
                tossir();
            }
        }
        
        void tossir(void)
        {
            printf("tossir\n");
        }
        
    
    *   Declaramos uma nova função com `void tossir(void);`, antes de nossa função `main` chamá-la. O compilador C lê nosso código de cima para baixo, então precisamos informá-lo que a função `tossir` existe antes de usá-la. Depois, após nossa função `main`, podemos implementar a função `tossir`. Dessa forma, o compilador sabe que a função existe e podemos manter nossa função `main` próxima ao topo.
    *   E nossa função `tossir` não recebe nenhuma entrada, então temos `tossir(void)`.
*   Podemos abstrair ainda mais a função `tossir`:
    
        #include <stdio.h>
        
        void tossir(int n);
        
        int main(void)
        {
            tossir(3);
        }
        
        void tossir(int n)
        {
            for (int i = 0; i < n; i++)
            {
                printf("tossir\n");
            }
        }
        
    
    *   Agora, quando quisermos imprimir "tossir" qualquer número de vezes, podemos simplesmente chamar a mesma função. Observe que, com `void tossir(int n)`, indicamos que a função `tossir` recebe como entrada um inteiro (`int`), que chamamos de `n`. E dentro de `tossir`, usamos `n` em nosso loop `for` para imprimir "tossir" o número certo de vezes.
*   Vamos dar uma olhada em `positive.c`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int get_positive_int(void);
        
        int main(void)
        {
            int i = get_positive_int();
            printf("%i\n", i);
        }
        
        // Solicita ao usuário um inteiro positivo
        int get_positive_int(void)
        {
            int n;
            do
            {
                n = get_int("%s", "Inteiro Positivo: ");
            }
            while (n < 1);
            return n;
        }
        
    
    *   A biblioteca CS50 não possui uma função `get_positive_int`, mas podemos escrever uma por conta própria. Nossa função `int get_positive_int(void)` solicitará ao usuário um número inteiro (`int`) e retornará esse número, que nossa função `main` armazena como `i`. Em `get_positive_int`, inicializamos uma variável `int n` sem atribuir um valor a ela ainda. Em seguida, temos uma nova construção, `do ... while`, que faz algo _primeiro_, verifica uma condição e repete até que a condi

Telas
-----

*   Talvez queiramos um programa que imprima uma parte de uma tela de um video game como Super Mario Bros. No arquivo `mario0.c`, temos:

        // Imprime uma fileira de 4 pontos de interrogação
        
        #include <stdio.h>
        
        int main(void)
        {
            printf("????\n");
        }
        

*   Podemos pedir ao usuário um número de pontos de interrogação e, em seguida, imprimi-los, com `mario2.c`:

        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            int n;
            do
            {
                n = get_int("Largura: ");
            }
            while (n < 1);
            for (int i = 0; i < n; i++)
            {
                printf("?");
            }
            printf("\n");
        }
        

*   E podemos imprimir um conjunto bidimensional de blocos com `mario8.c`:

        // Imprime uma grade de tijolos de tamanho n com um loop
        
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            int n;
            do
            {
                n = get_int("Tamanho: ");
            }
            while (n < 1);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    printf("#");
                }
                printf("\n");
            }
        }
        

    *   Observe que temos dois loops aninhados, onde o loop externo usa `i` para executar tudo dentro dele `n` vezes, e o loop interno usa `j`, uma variável diferente, para fazer algo `n` vezes para cada uma daquelas vezes. Em outras palavras, o loop externo imprime `n` "linhas" ou linhas, e o loop interno imprime `n` "colunas" ou caracteres `#`, em cada linha.
*   Outros exemplos não abordados na palestra estão disponíveis em "Código-fonte" para [Semana 1](../../weeks/1/).

Memória, imprecisão e estouro
=================================

Nosso computador tem memória, em chips de hardware chamados RAM, memória de acesso aleatório. Nossos programas usam essa RAM para armazenar dados enquanto são executados, mas essa memória é finita. Portanto, com um número finito de bits, não podemos representar todos os números possíveis (dos quais há um número infinito). Então, nosso computador tem um certo número de bits para cada float e int, e precisa arredondar para o valor decimal mais próximo em determinado ponto.
Com `floats.c`, podemos ver o que acontece quando usamos floats:
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Solicitar x ao usuário
    float x = get_float("x: ");

    // Solicitar y ao usuário
    float y = get_float("y: ");

    // Realizar a divisão
    printf("x / y = %.50f\n", x / y);
}
```
Com `%50f`, podemos especificar o número de casas decimais exibidas.
Hmm, agora obtemos ...
```
x: 1
y: 10
x / y = 0.10000000149011611938476562500000000000000000000000
```
Acontece que isso é chamado de **imprecisão de ponto flutuante**, onde não temos bits suficientes para armazenar todos os valores possíveis, então o computador precisa armazenar o valor mais próximo possível de 1 dividido por 10.

Podemos ver um problema semelhante em `overflow.c`:
```c
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf("%i\n", i);
        sleep(1);
    }
}
```
Em nosso loop `for`, definimos `i` como `1` e dobramos seu valor com `*= 2`. (E continuaremos fazendo isso para sempre, então não há condição que verifiquemos.)
Também usamos a função `sleep` de `unistd.h` para pausar nosso programa a cada vez.
Agora, quando executamos este programa, vemos o número ficando cada vez maior, até que:
```
1073741824
overflow.c:6:25: erro em tempo de execução: estouro de inteiro assinado: 1073741824 * 2 não pode ser representado no tipo 'int'
-2147483648
0
0
...
```
Acontece que nosso programa reconheceu que um inteiro assinado (um inteiro com sinal positivo ou negativo) não poderia armazenar aquele próximo valor e exibiu um erro. Em seguida, como tentou dobrar mesmo assim, `i` se tornou um número negativo e depois 0.
Esse problema é chamado de **estouro de inteiro**, onde um inteiro só pode ser tão grande antes de ficar sem bits e "voltar ao início". Podemos imaginar adicionando 1 a 999 em decimal. O último dígito se torna 0, carregamos o 1, então o próximo dígito se torna 0 e obtemos 1000. Mas se tivéssemos apenas três dígitos, ficaríamos com 000, pois não há lugar para colocar o 1 final!
O problema do ano 2000 surgiu porque muitos programas armazenavam o ano do calendário com apenas dois dígitos, como 98 para 1998 e 99 para 1999. Mas quando o ano 2000 se aproximou, os programas teriam armazenado 00, causando confusão entre os anos 1900 e 2000.
Um avião Boeing 787 também tinha um bug, onde um contador no gerador sofre um estouro após um certo número de dias de operação contínua, pois o número de segundos em que ele estava em execução não poderia mais ser armazenado nesse contador.
Portanto, vimos alguns problemas que podem ocorrer, mas agora entendemos por que eles acontecem e como evitá-los.
Com o conjunto de problemas desta semana, usaremos o Laboratório CS50, construído sobre o Sandbox CS50, para escrever alguns programas com tutoriais para nos orientar.

