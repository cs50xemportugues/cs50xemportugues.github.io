Mais exemplos
=============

*   Para cada um desses exemplos, você pode clicar nos [links de sandbox](../../weeks/1/) para executar e editar suas próprias cópias deles.
*   No arquivo `int.c`, obtemos e imprimimos um número inteiro:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            int age = get_int("Qual a sua idade?\n");
            int days = age * 365;
            printf("Você tem pelo menos %i dias de idade.\n", days);
        }
        
    
    *   Observe que usamos `%i` para imprimir um número inteiro.
    *   Agora podemos executar `make int` e rodar nosso programa com `./int`.
    *   Podemos combinar linhas e remover a variável `days` com:
        
            int age = get_int("Qual a sua idade?\n");
            printf("Você tem pelo menos %i dias de idade.\n", age * 365);
            
        
    *   Ou até mesmo combinar tudo em uma única linha:
        
            printf("Você tem pelo menos %i dias de idade.\n", get_int("Qual a sua idade?\n") * 365);
            
        
    *   No entanto, quando uma linha fica muito longa ou complicada, pode ser melhor dividir em duas ou até três linhas para melhorar a legibilidade.
*   No arquivo `float.c`, podemos obter números decimais (chamados de valores de ponto flutuante nos computadores, porque a vírgula decimal pode "flutuar" entre os dígitos, dependendo do número):
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            float price = get_float("Qual é o preço?\n");
            printf("O total é %f.\n", price * 1.0625);
        }
        
    
    *   Agora, se compilarmos e executarmos nosso programa, veremos um preço impresso com imposto.
    *   Podemos especificar o número de dígitos impressos após a vírgula decimal com um espaço reservado como `%.2f` para dois dígitos após a vírgula.
*   Com `parity.c`, podemos verificar se um número é par ou ímpar:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            int n = get_int("n: ");
        
            if (n % 2 == 0)
            {
                printf("par\n");
            }
            else
            {
                printf("ímpar\n");
            }
        }
        
    
    *   Com o operador `%` (módulo), podemos obter o resto de `n` após dividir por 2. Se o resto for 0, sabemos que `n` é par. Caso contrário, sabemos que `n` é ímpar.
    *   E funções como `get_int` da biblioteca CS50 fazem verificação de erros, onde apenas entradas do usuário que correspondem ao tipo que desejamos são aceitas.
*   No arquivo `conditions.c`, transformamos os trechos de condição anteriores em um programa:
    
        // Condições e operadores relacionais
        
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Solicita ao usuário um valor para x
            int x = get_int("x: ");
        
            // Solicita ao usuário um valor para y
            int y = get_int("y: ");
        
            // Compara x e y
            if (x < y)
            {
                printf("x é menor que y\n");
            }
            else if (x > y)
            {
                printf("x é maior que y\n");
            }
            else
            {
                printf("x é igual a y\n");
            }
        }
        
    
    *   Linhas que começam com `//` são comentários, ou notas para os seres humanos que o compilador ignorará.
    *   Para David compilar e executar este programa em seu sandbox, ele precisava executar o comando `cd src1` no terminal. Isso muda o diretório, ou pasta, para aquele em que ele salvou todos os arquivos de origem da palestra. Em seguida, ele pode executar `make conditions` e `./conditions`. Com `pwd`, ele pode ver que está em uma pasta `src1` (dentro de outras pastas). E `cd` sozinho, sem argumentos, nos levará de volta à nossa pasta padrão no sandbox.
*   No arquivo `agree.c`, podemos pedir ao usuário para confirmar ou negar algo:
    
        // Operadores lógicos
        
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            // Solicita ao usuário para concordar
            char c = get_char("Você concorda?\n");
        
            // Verifica se concordou
            if (c == 'Y' || c == 'y')
            {
                printf("Concordou.\n");
            }
            else if (c == 'N' || c == 'n')
            {
                printf("Não concordou.\n");
            }
        }
        
    
    *   Usamos duas barras verticais, `||`, para indicar um "ou" lógico, ou seja, qualquer uma das expressões pode ser verdadeira para que a condição seja seguida.
    *   E se nenhuma das expressões for verdadeira, nada acontecerá, pois nosso programa não possui um loop.
*   Vamos implementar o programa de tossir da semana 0:
    
        #include <stdio.h>
        
        int main(void)
        {
            printf("tossir\n");
            printf("tossir\n");
            printf("tossir\n");
        }
        
    
*   Poderíamos usar um loop `for`:
    
        #include <stdio.h>
        
        int main(void)
        {
            for (int i = 0; i < 3; i++)
            {
                printf("tossir\n");
            }
        }
        
    
    *   Por convenção, os programadores tendem a começar a contar em 0, então `i` terá os valores `0`, `1` e `2` antes de parar, totalizando três iterações. Também poderíamos escrever `for (int i = 1; i <= 3; i++)` para o mesmo efeito final.
*   Podemos mover a linha `printf` para sua própria função:
    
        #include <stdio.h>
        
        void tossir(void);
        
        int main(void)
        {
            for (int i = 0; i < 3; i++)
            {
                tossir();
            }
        }
        
        void tossir(void)
        {
            printf("tossir\n");
        }
        
    
    *   Declaramos uma nova função com `void tossir(void);`, antes de nossa função `main` chamá-la. O compilador C lê nosso código de cima para baixo, então precisamos informá-lo que a função `tossir` existe antes de usá-la. Depois, após nossa função `main`, podemos implementar a função `tossir`. Dessa forma, o compilador sabe que a função existe e podemos manter nossa função `main` próxima ao topo.
    *   E nossa função `tossir` não recebe nenhuma entrada, então temos `tossir(void)`.
*   Podemos abstrair ainda mais a função `tossir`:
    
        #include <stdio.h>
        
        void tossir(int n);
        
        int main(void)
        {
            tossir(3);
        }
        
        void tossir(int n)
        {
            for (int i = 0; i < n; i++)
            {
                printf("tossir\n");
            }
        }
        
    
    *   Agora, quando quisermos imprimir "tossir" qualquer número de vezes, podemos simplesmente chamar a mesma função. Observe que, com `void tossir(int n)`, indicamos que a função `tossir` recebe como entrada um inteiro (`int`), que chamamos de `n`. E dentro de `tossir`, usamos `n` em nosso loop `for` para imprimir "tossir" o número certo de vezes.
*   Vamos dar uma olhada em `positive.c`:
    
        #include <cs50.h>
        #include <stdio.h>
        
        int get_positive_int(void);
        
        int main(void)
        {
            int i = get_positive_int();
            printf("%i\n", i);
        }
        
        // Solicita ao usuário um inteiro positivo
        int get_positive_int(void)
        {
            int n;
            do
            {
                n = get_int("%s", "Inteiro Positivo: ");
            }
            while (n < 1);
            return n;
        }
        
    
    *   A biblioteca CS50 não possui uma função `get_positive_int`, mas podemos escrever uma por conta própria. Nossa função `int get_positive_int(void)` solicitará ao usuário um número inteiro (`int`) e retornará esse número, que nossa função `main` armazena como `i`. Em `get_positive_int`, inicializamos uma variável `int n` sem atribuir um valor a ela ainda. Em seguida, temos uma nova construção, `do ... while`, que faz algo _primeiro_, verifica uma condição e repete até que a condi