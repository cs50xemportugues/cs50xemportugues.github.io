Recursão
--------

*   Lembre-se de que na semana 0, tínhamos um pseudocódigo para encontrar um nome em uma lista telefônica, onde tínhamos linhas nos dizendo para "voltar" e repetir algumas etapas:

        1  Pegue a lista telefônica
        2  Abra no meio da lista telefônica
        3  Olhe a página
        4  Se Smith estiver na página
        5      Ligue para Mike
        6  Senão, se Smith estiver antes do meio da lista
        7      Abra no meio da metade esquerda da lista
        8      **Volte para a linha 3**
        9  Senão, se Smith estiver depois do meio da lista
        10     Abra no meio da metade direita da lista
        11     **Volte para a linha 3**
        12 Senão
        13     Saia
        
    
*   Em vez disso, poderíamos simplesmente repetir todo o nosso algoritmo na metade da lista restante:

        1  Pegue a lista telefônica
        2  Abra no meio da lista telefônica
        3  Olhe a página
        4  Se Smith estiver na página
        5      Ligue para Mike
        6  Senão, se Smith estiver antes do meio da lista
        7      **Pesquise na metade esquerda da lista**
        8
        9  Senão, se Smith estiver depois do meio da lista
        10     **Pesquise na metade direita da lista**
        11
        12 Senão
        13     Saia
        
    
    *   Isso parece um processo cíclico que nunca terminará, mas na verdade estamos dividindo o problema pela metade a cada vez e parando quando não há mais lista restante.
*   **Recursão** ocorre quando uma função ou algoritmo se refere a si mesma, como no novo pseudocódigo acima.
*   Na semana 1 também implementamos uma "pirâmide" de blocos no seguinte formato:

        #
        ##
        ###
        ####
        
    
    *   E poderíamos ter código iterativo como este:
        
            #include <cs50.h>
            #include <stdio.h>
            
            void draw(int h);
            
            int main(void)
            {
                // Obtenha a altura da pirâmide
                int altura = get_int("Altura: ");
            
                // Desenhe a pirâmide
                draw(altura);
            }
            
            void draw(int h)
            {
                // Desenhe uma pirâmide de altura h
                for (int i = 1; i <= h; i++)
                {
                    for (int j = 1; j <= i; j++)
                    {
                        printf("#");
                    }
                    printf("\n");
                }
            }
            
        
        *   Aqui, usamos `for` loops para imprimir cada bloco em cada linha.
*   Mas observe que uma pirâmide de altura 4 é na verdade uma pirâmide de altura 3, com uma linha extra de 4 blocos adicionados. E uma pirâmide de altura 3 é uma pirâmide de altura 2, com uma linha extra de 3 blocos. Uma pirâmide de altura 2 é uma pirâmide de altura 1, com uma linha extra de 2 blocos. E finalmente, uma pirâmide de altura 1 é apenas uma pirâmide de altura 0, ou nada, com mais uma linha adicionada contendo um único bloco.
*   Com essa ideia em mente, podemos escrever:

        #include <cs50.h>
        #include <stdio.h>
        
        void draw(int h);
        
        int main(void)
        {
            // Obtenha a altura da pirâmide
            int altura = get_int("Altura: ");
        
            // Desenhe a pirâmide
            draw(altura);
        }
        
        void draw(int h)
        {
            // Se não houver nada para desenhar
            if (h == 0)
            {
                return;
            }
        
            // Desenhe uma pirâmide de altura h - 1
            draw(h - 1);
        
            // Desenhe mais uma linha com largura h
            for (int i = 0; i < h; i++)
            {
                printf("#");
            }
            printf("\n");
        }
        
    
    *   Agora, nossa função `draw` primeiro chama a si mesma **recursivamente**, desenhando uma pirâmide de altura `h - 1`. Mas antes mesmo disso, precisamos parar se `h` for igual a 0, já que não haverá mais nada para ser desenhado.
    *   Depois, desenhamos a próxima linha ou uma linha com largura `h`.
