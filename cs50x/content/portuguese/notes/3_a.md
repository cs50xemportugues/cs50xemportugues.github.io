Aula 3
=========

*   [Busca](#busca)
*   [Big O](#big-o)
*   [Busca linear](#busca-linear)
*   [Structs](#structs)
*   [Ordenação](#ordenacao)
*   [Selection sort](#selection-sort)
*   [Recursão](#recursao)
*   [Merge sort](#merge-sort)

Busca
---------

*   Da última vez, falamos sobre a memória em um computador, ou RAM, e como nossos dados podem ser armazenados como variáveis individuais ou como arrays com vários itens, ou elementos.
*   Podemos pensar em um array com vários itens como uma fileira de armários, onde um computador só pode abrir um armário para olhar um item, de cada vez.
*   Por exemplo, se quisermos verificar se um número está em um array, com um algoritmo que recebe um array como entrada e produz um booleano como resultado, poderíamos:
    *   olhar em cada armário, ou em cada elemento, de cada vez, do início ao fim.
        *   Isso é chamado de **busca linear**, onde nos movemos em uma linha, já que nosso array não está ordenado.
    *   começar no meio e mover para a esquerda ou direita, dependendo do que estamos procurando, se nosso array de itens estiver ordenado.
        *   Isso é chamado de **busca binária**, já que podemos dividir nosso problema em dois a cada passo, como David fez com a lista telefônica na semana 0.
*   Podemos escrever um pseudocódigo para a busca linear assim:
    
        Para i de 0 a n–1
            Se o i-ésimo elemento for 50
                Retorna verdadeiro
        Retorna falso
        
    
    *   Podemos rotular cada um dos armários, de `0` a `n–1`, e verificá-los em ordem.
*   Para a busca binária, nosso algoritmo pode ser assim:
    
        Se não houver itens
            Retorna falso
        Se o item do meio for 50
            Retorna verdadeiro
        Senão, se 50 < item do meio
            Buscar na metade esquerda
        Senão, se 50 > item do meio
            Buscar na metade direita
        
    
    *   Eventualmente, não teremos mais partes do array sobrando (se o item que queremos não estiver nele), então podemos retornar `falso`.
    *   Caso contrário, podemos procurar em cada metade, dependendo do valor do item do meio.

Big O
-----

*   Na semana 0, vimos diferentes tipos de algoritmos e seus tempos de execução: ![gráfico com: "tamanho do problema" como eixo x; "tempo para resolver" como eixo y; linha reta vermelha e íngreme desde a origem até o topo do gráfico rotulada como "n"; linha reta amarela e menos íngreme desde a origem até o topo do gráfico rotulada como "n/2"; linha curva verde que fica cada vez menos íngreme desde a origem até a direita do gráfico rotulada como "log_2 n"](https://cs50.harvard.edu/x/2020/notes/3/running_time.png)
*   A maneira mais formal de descrever isso é com a notação big _O_, que podemos pensar como "na ordem de". Por exemplo, se nosso algoritmo é a busca linear, ele levará aproximadamente _O_(_n_) passos, "na ordem de _n_". Na verdade, até mesmo um algoritmo que olha dois itens de cada vez e leva _n_/2 passos tem _O_(_n_). Isso ocorre porque, à medida que _n_ fica cada vez maior, apenas o termo maior, _n_, importa.
*   Da mesma forma, um tempo de execução logarítmico é _O_(log _n_), não importando qual seja a base, já que isso é apenas uma aproximação do que acontece quando _n_ é muito grande.
*   Existem alguns tempos de execução comuns:
    *   _O_(_n_2)
    *   _O_(_n_ log _n_)
    *   _O_(_n_)
        *   (busca linear)
    *   _O_(log _n_)
        *   (busca binária)
    *   _O_(1)
*   Os cientistas da computação também podem usar o big Ω, notação big Omega, que é o limite inferior do número de passos para nosso algoritmo. (Big _O_ é o limite superior do número de passos, ou o pior caso, e geralmente é o que mais nos interessa.) Com a busca linear, por exemplo, o pior caso é _n_ passos, mas o melhor caso é 1 passo, já que nosso item pode acontecer de ser o primeiro item que verificamos. O melhor caso para a busca binária também é 1, já que nosso item pode estar no meio do array.
*   E temos um conjunto similar dos tempos de execução mais comuns em big Ω:
    *   Ω(_n_2)
    *   Ω(_n_ log _n_)
    *   Ω(_n_)
        *   (contando o número de itens)
    *   Ω(log _n_)
    *   Ω(1)
        *   (busca linear, busca binária)