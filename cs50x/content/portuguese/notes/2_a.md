Palestra 2
=========

*   [Compilação](#compilacao)
*   [Depuração](#depuracao)
*   [help50 e printf](#help50-e-printf)
*   [debug50](#debug50)
*   [check50 e style50](#check50-e-style50)
*   [Tipos de dados](#tipos-de-dados)
*   [Memória](#memoria)
*   [Arrays](#arrays)
*   [Strings](#strings)
*   [Argumentos da linha de comando](#argumentos-da-linha-de-comando)
*   [Legibilidade](#legibilidade)
*   [Criptografia](#criptografia)

Compilação
---------
*   Na última vez, aprendemos a escrever nosso primeiro programa em C. Aprendemos a sintaxe para a função `main` em nosso programa, a função `printf` para imprimir no terminal, como criar strings com aspas duplas e como incluir `stdio.h` para a função `printf`.
*   Em seguida, compilamos com `clang hello.c` para poder executar `./a.out` (nome padrão) e então `clang -o hello hello.c` (passando um argumento da linha de comando para o nome de saída) para poder executar `./hello`.
*   Se quiséssemos usar a biblioteca do CS50, através do `#include <cs50.h>`, para strings e a função `get_string`, também teríamos que adicionar uma flag: `clang -o hello hello.c -lcs50`. A flag `-l` vincula o arquivo `cs50`, que já está instalado no Sandbox do CS50, e inclui protótipos ou definições de strings e `get_string` (entre outras) que nosso programa pode usar e referenciar.
*   Escrevemos nosso código-fonte em C, mas precisamos compilá-lo para código de máquina, em binário, antes que nossos computadores possam executá-lo.
    *   `clang` é o compilador e `make` é uma ferramenta que nos ajuda a executar o `clang` sem ter que indicar todas as opções manualmente.
*   "Compilar" o código-fonte em código de máquina é, na verdade, composto de etapas menores:
    *   pré-processamento
    *   compilação
    *   montagem
    *   linkagem
*   **Pré-processamento** envolve a análise de linhas que começam com um `#`, como `#include`, antes de tudo. Por exemplo, `#include <cs50.h>` dirá ao `clang` para procurar esse arquivo de cabeçalho primeiro, pois ele contém conteúdo que queremos incluir em nosso programa. Em seguida, o `clang` substituirá essencialmente o conteúdo desses arquivos de cabeçalho em nosso programa.
*   Por exemplo …

        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string name = get_string("Nome: ");
            printf("olá, %s\n", name);
        }
        
    
*   … será pré-processado para:
    
        string get_string(string prompt);
        int printf(const char *format, ...);
        
        int main(void)
        {
            string name = get_string("Nome: ");
            printf("olá, %s\n", name);
        }
        
    
*   **Compilação** pega nosso código-fonte, em C, e o converte para código assembly, que se parece com isso:
    
        ...
        main:                         # @main
            .cfi_startproc
        # BB#0:
            pushq    %rbp
        .Ltmp0:
            .cfi_def_cfa_offset 16
        .Ltmp1:
            .cfi_offset %rbp, -16
            movq    %rsp, %rbp
        .Ltmp2:
            .cfi_def_cfa_register %rbp
            subq    $16, %rsp
            xorl    %eax, %eax
            movl    %eax, %edi
            movabsq    $.L.str, %rsi
            movb    $0, %al
            callq    get_string
            movabsq    $.L.str.1, %rdi
            movq    %rax, -8(%rbp)
            movq    -8(%rbp), %rsi
            movb    $0, %al
            callq    printf
            ...
        
    
    *   Essas instruções são de nível mais baixo e estão mais próximas das instruções binárias que a CPU de um computador pode entender diretamente. Elas geralmente operam em bytes em si, em vez de abstrações como nomes de variáveis.
*   O próximo passo é levar o código assembly e traduzi-lo para instruções em binário **montando**-o. As instruções em binário são chamadas de **código de máquina**, que a CPU de um computador pode executar diretamente.
*   A última etapa é a **linkagem**, onde o conteúdo das bibliotecas previamente compiladas que queremos vincular, como `cs50.c`, são combinadas com o binário de nosso programa. Assim, acabamos com um único arquivo binário, `a.out` ou `hello`, que é a versão compilada de `hello.c`, `cs50.c` e `printf.c`.