Se você assistiu ao nosso vídeo sobre recursão, o processo pode ter parecido um pouco mágico. Como uma função sabe esperar por outra função e passar seus dados para alguma outra coisa que está sendo executada ao mesmo tempo? À primeira vista, pode parecer um pouco mágico se você não entender exatamente como as funções são chamadas e operam em C. E a maneira como operam é usando algo chamado de pilha de chamadas. E a maneira como a pilha de chamadas funciona é a seguinte. Se você chamar uma função, basicamente o que acontece é que um grande bloco de memória é reservado em algum lugar do sistema para que essa função faça seu trabalho. Então, por exemplo, se você chama uma função e a primeira coisa que você faz é declarar um par de variáveis, o que vai acontecer é que um quadro de pilha ou um quadro de função será criado, um grande bloco de memória, e essas variáveis ​​receberão espaço. Portanto, se forem três inteiros, você terá três pedaços de quatro bytes, assim como o tamanho de um inteiro, além de algum espaço para fazer alguns cálculos e o que mais a função precisar. E é aí que a função fará todo o seu trabalho. Agora, é possível que mais de um quadro de função possa existir em memória em um determinado momento. Então, por exemplo, vamos dizer que a função principal chama outra função chamada mover. E então a função mover chama outra função chamada direção. Nesse ponto, todas as três funções têm quadros abertos. Mas em geral, apenas um desses quadros será ativo. Apenas uma dessas funções está sempre em execução em um determinado momento, embora as três tenham espaço reservado e estejam esperando para fazer algo. Agora, a maneira como esses quadros são organizados é em algo chamado pilha. E o quadro para a função mais recentemente chamada é sempre aquele no topo da pilha, que é chamado de quadro ativo. Então, novamente, se principal chamou mover e mover chamou direção, você pode pensar nisso como uma pilha da seguinte forma, onde principal está na parte inferior, mover está acima dela, direção está no topo e direção é o quadro ativo. Essa é a única função que está fazendo algo no momento, embora mover e principal estejam aguardando para se tornarem o quadro ativo. Eles estão esperando para se tornar o quadro que está no topo da pilha. Quando você chama uma nova função, um novo quadro é o que é chamado de empurrado para o topo da pilha. Portanto, se você chama uma nova função, essa função imediatamente recebe espaço e memória e é colocada no topo da pilha de chamadas. E ela se torna o quadro ativo. E o quadro ativo anterior, se houver um, está em pausa. Ele está apenas sentado ali. É um padrão de espera, aguardando para se tornar o quadro ativo novamente. Quando uma função termina seu trabalho, como retornar, mais comumente ou talvez chegar ao final da linha se for uma função do tipo void, que não tem um valor de retorno, esse quadro é o que chamamos de retirado da pilha. E, em seguida, o quadro que estava em segundo lugar, uma vez que esse quadro agora se foi, será o quadro ativo. Ele retomará de onde parou. Se você tivesse pausado essa função, ela começará imediatamente de onde parou. É por isso que a recursão funciona, porque todos esses quadros estão em execução, mas apenas um deles está se movendo em um determinado momento. O restante deles está em pausa. Eles estão apenas esperando para se tornar o novo topo da pilha novamente. Se chamarmos outra função, o quadro ativo vai entrar em pausa novamente. A função que acabou de chamar é colocada no topo e assim por diante, até que todos os quadros de função sejam concluídos. Então, vamos dar uma olhada em uma visualização disso, um exemplo usando a função fatorial, para ver se podemos ajudar a tornar isso um pouco mais claro. Este é todo um arquivo fatorial, por exemplo. E dentro desse arquivo fatorial, tenho duas funções, fact, que será uma implementação recursiva da fatorial, e main, que basicamente chama ou imprime o valor da fatorial, neste caso, de 5. Começamos no início de main. E a primeira coisa que a main faz é chamar outra função. Ela chama printf(). Assim que ele faz isso, main entra em pausa. Ele está aqui apenas esperando para printf() fazer seu trabalho. O que printf() tem a fazer? Ele só tem que imprimir um número, mas ele tem que imprimir a fatorial de 5 ou não saberá a fatorial de 5. Ele tem que fazer uma chamada de função. Então, printf() entra em pausa e aguarda a fatorial de 5, que agora se torna o novo quadro ativo. Então, no quadro fatorial de 5, o que está acontecendo? Estamos passando o valor 5 para a função fact. E então ele vai verificar, bem, n é igual a 1? Não. Então, no caso, ele retornará n vezes fact n - 1. OK, então agora o quadro fatorial 5 basicamente está chamando uma nova função, passando outro chamado para fatorial, passando 4 como parâmetro. Então, o quadro fatorial de 5 entra em pausa e um quadro para a fatorial de 4 se torna o novo quadro ativo. E ele passará pelo mesmo processo. Ele sai 4 = 1? Não. Então, em vez disso, ele retornará n vezes, neste caso, ou quatro vezes a fatorial de 3, outra chamada de função. Então, o quadro fatorial 4 entra em pausa. O quadro da fatorial de 3 se torna o novo quadro ativo e repete esse processo novamente para a fatorial de 3, para a fatorial de 2 e, em seguida, chegamos à fatorial de 1. Assim, bem no início, quando a fatorial de 1 é chamada, existem sete quadros de função na pilha de chamadas. Fatorial 2, 3, 4, 5, printf() e main estão todos em pausa nas linhas que você vê aqui. Eles estão apenas esperando para se tornarem novamente o novo quadro ativo. Mas eles não estão se movendo desses indicadores com setas. O quadro da fatorial de 1 começa. Ele faz a pergunta, n é igual a 1? Bem, neste caso, a resposta é sim. Ele vai retornar 1. Agora, lembre-se do que acontece quando uma função retorna um valor, aquele quadro está feito. Ele vai embora. E isso significa que ele é retirado da pilha de chamadas e o quadro que está abaixo dele se tornará o novo quadro ativo. Então, fatorial de 1 retorna 1. Neste ponto, seu quadro é destruído e a fatorial de 2 pode ser desativada. Agora, a fatorial de 2 é aquela linha azul escura à esquerda e estava aguardando o valor de retorno da fatorial de 1. Bem, a fatorial de 1 disse: eu retornei um 1 para você. Então, a fatorial de 2 retornará 2 vezes 1 ou 2. Agora, também está retornando e, quando retorna, é retirado da pilha. Seu quadro de função é destruído e a fatorial de 3 se torna o novo quadro ativo. A fatorial de 3 estava aguardando a fatorial de 2, que retornou 2. Então, ele vai retornar 3 vezes 2 ou 6, retorna o valor. Seu quadro de função é retirado da pilha. É destruído. A fatorial de 4 se torna o novo quadro ativo. A fatorial de 4 estava aguardando a fatorial de 3. Obteve sua resposta de volta de 6. Então, ele vai retornar 4 vezes 6 ou 24. E ele vai devolver esse valor para a fatorial de 5, que esteve esperando para que a fatorial de 4 terminasse seu trabalho. Ele retorna 5 vezes 24, o que é 120. Quando aquele quadro é destruído, agora retomamos em printf(). Printf() tem aquela linha cor de vinho escuro na parte inferior. Ele estava aguardando a fatorial de 5, que acabou de retornar 120. Então, o que printf() faz é imprimir 120 e seu trabalho está feito. Ele não tem mais nada a fazer. Ele não está esperando outra chamada de função e, portanto, ele termina de executar. Ele não retorna nada, mas não tem mais nada a fazer. Então, seu quadro de função é destruído. Ele é retirado da pilha de chamadas. E então, tudo o que temos que fazer é ver onde main parou. Bem, isso é tudo o que main tinha. Então, o quadro de sua função será retirado da pilha também e este programa terá completado seu trabalho imprimindo 120. Espero que essa ilustração da pilha de chamadas tenha ajudado a mostrar exatamente