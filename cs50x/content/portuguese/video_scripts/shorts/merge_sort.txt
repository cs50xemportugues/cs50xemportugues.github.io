Certo, até agora falamos sobre alguns algoritmos de ordenação que são bastante simples de trabalhar, espero que tenha sido útil. Temos bubble sort, insertion sort e selection sort. E o que sabemos é que todos eles têm em comum um pior caso de tempo de execução de n ao quadrado. Podemos fazer melhor do que isso? Bem, a resposta é sim, usando um algoritmo chamado merge sort. Agora, no merge sort, a ideia é ordenar arrays menores e depois combiná-los juntos na ordem classificada. Em vez de pensar que temos um array de seis elementos, vamos pensar em seis arrays de um elemento cada, reunindo-os na ordem correta. É assim que o merge sort funciona e utiliza algo chamado recursão, que veremos em outro vídeo. Se você quiser entender melhor como a recursão funciona, convém assistir aquele vídeo antes de assistir a este, pois falaremos muito sobre recursão aqui. O merge sort é definitivamente o mais complicado dos quatro tipos de ordenação que abordamos na aula. Vou passar mais devagar nele do que nos outros. Mas o algoritmo em si é bastante simples, basicamente vamos dizer dividir ao meio, ordenar a metade esquerda do array, ordenar a metade direita do array e, em seguida, mesclaremos as duas metades juntas. Em prática, é um pouco mais detalhado do que isso, mas vamos por partes. Aqui está o mesmo array de seis elementos que temos ordenado o tempo todo. Agora vamos seguir nossos passos de pseudocódigo, queremos ordenar a metade esquerda desse array em vermelho-escuro. Então vamos nos concentrar nessa parte por enquanto. Para simplificar as coisas, daqui por diante, vamos nos referir a essa metade do array em vermelho-escuro como a metade roxa do array. Estamos ordenando a metade esquerda do array roxo. Mas não sabemos como fazer isso. Então, por que não voltar aos nossos passos de ordenação? Se eu não sei como ordenar a metade esquerda do array, vou começar de novo. Ordeno a metade esquerda deste array. E agora quero me concentrar apenas nesta parte do array, a metade esquerda. E decido arbitrariamente que a metade esquerda será menor que a metade direita. Tenho três elementos, não posso dividir igualmente. Então, desde que seja consistente, escolha a esquerda como menor, e isso será bom para os propósitos do merge sort. Agora fiquei com este único elemento, o cinco. Como ordenar um array de um elemento? A boa notícia aqui é que não preciso ordená-lo. Um array de um elemento deve ser necessariamente ordenado. Então, se estou ordenando a metade esquerda da parte roxa, isso já está ordenado. Vamos chamá-lo de ordenado e deixá-lo de lado por enquanto. Agora volto à metade direita da parte roxa. Como ordenar este array, este subarray? Vamos voltar aos nossos passos de novo. Quero ordenar apenas a metade esquerda. A metade esquerda agora é dois, um único elemento. Sei como ordenar um array de um único elemento. Então ordenei a metade esquerda da metade direita do roxo. Agora volto e ordeno a metade direita da metade esquerda do roxo, que é um. Um é um único elemento, é fácil de ordenar. Agora é a primeira vez que finalmente chego a essa terceira etapa do merge sort, onde mesclamos as duas metades. Então vou considerar essas duas metades em verde claro. Preciso decidir qual tem o menor elemento. Neste caso, é um. Então pego o um e o coloco na primeira posição de algum novo array hipotético. Em seguida, comparo dois com nada e pergunto qual é o menor. Bem, dois. Reflita sobre a imagem novamente, porque estamos nos concentrando apenas na metade esquerda do array em vermelho-escuro e, em seguida, chamamos de array roxo. Nesse ponto de nossos passos, em relação ao array roxo, ordenamos a metade esquerda (cinco) e a metade direita (originalmente dois e um, mas agora combinados na ordem correta). Agora estamos no passo três para todo o array roxo, porque já classificamos a metade esquerda e a metade direita do array em questão. Agora precisamos mesclar essas duas etapas juntas. Igualmente ao que fizemos um pouco antes com dois e um, vamos comparar o primeiro elemento da parte esquerda e o primeiro elemento da parte direita e descobrir qual é menor, tornando isso o primeiro elemento do novo array. Então, comparo cinco e um e pergunto qual é menor. Bem, um é menor, então um se torna o primeiro elemento deste novo array de três elementos. Agora devo fazer outra escolha. Seis é menor ou quatro é menor? Quatro é menor, então agora voltamos a focar no que nos foi apresentado pela recursão, ou seja, ordenamos a metade esquerda da metade direita. Está ordenada. Agora vou ordenar a metade direita da metade direita, que é quatro. Está ordenado. Agora chego a essa etapa de mesclagem novamente, onde devo novamente fazer essas comparações lado a lado. Qual é menor? Seis ou quatro? Bem, é quatro, então torna-se o primeiro elemento dessa nova submatriz mesclada. E agora tenho que escolher entre seis e nada. E digo que seis é o menor restante. Assim, já ordenamos a metade esquerda da metade direita da metade roxa, e também já ordenamos a metade direita da metade direita da metade roxa. Agora quero mesclar essas duas porções juntas, e novamente faremos exatamente o mesmo processo que fizemos para a parte esquerda. Vou dizer, é três menor ou quatro? É três. E, em seguida, pergunto, é quatro ou nada? Não há nada na parte es