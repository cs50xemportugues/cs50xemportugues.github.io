OK. Trabalhamos com inteiros, caracteres, floats, doubles, strings e bools. Esgotamos praticamente todos os tipos de dados que estiveram disponíveis para nós desde o início. Mas agora queremos fazer algo mais. Como fazemos isso? Como criamos diferentes tipos de dados? Podemos fazer isso usando estruturas. As estruturas nos permitem unificar variáveis de diferentes tipos em um único novo tipo de variável, ao qual podemos atribuir seu próprio nome de tipo. Isso é muito forte porque agora podemos agrupar elementos de diferentes tipos de dados que têm uma conexão lógica. Conseguimos fazer isso com arrays, certo? Podemos agrupar variáveis do mesmo tipo de dados em uma grande unidade de memória, um array.

Mas não conseguimos misturar diferentes tipos de dados juntos. Não podemos, digamos, parear um inteiro, um caractere e um double tudo na mesma coisa e chamá-lo de uma única unidade. Mas com estruturas, ou frequentemente referido como structs, nós realmente podemos. Então, uma estrutura é como uma super-variável. É uma variável que contém outras variáveis dentro dela. Aqui está um exemplo de uma estrutura muito simples. Este é o que a sintaxe pareceria para criar uma estrutura para um carro. Agora, vamos passar pela sintaxe aqui. Struct, essa é a palavra-chave que indica que estou criando um novo tipo de dados aqui. Em particular, o nome do tipo de dados será struct car, como veremos. Mas esta é a dica ao compilador de que este é um grupo de variáveis que será considerado parte do mesmo tipo em um minuto.

Carros, apenas o nome da estrutura. Novamente, o tipo de dados aqui será struct car, não apenas car. Mas se você tem structs diferentes no mesmo programa, precisa distinguir entre struct e struct. Então, struct car, por exemplo, eu também posso ter struct student no mesmo programa. Dentro das chaves estão todos os chamados campos ou membros da estrutura. Então, quais são algumas das coisas que são inerentes a um carro? Bem, geralmente tem um ano, tem um nome do modelo e uma placa, um odômetro que geralmente tem algum número de milhas, e talvez um tamanho do motor. E como você pode ver, estou misturando inteiros, caracteres e doubles. Todos eles farão parte desse novo tipo de dados.

Por último, a última coisa que preciso fazer, não esqueça desse ponto e vírgula no final. Depois de terminarmos de definir a estrutura, precisamos colocar um ponto e vírgula no final. É um erro sintático muito comum, porque com uma função, por exemplo, você teria apenas chaves abertas e fechadas. Você não coloca um ponto e vírgula no final de uma definição de função. Isso parece uma definição de função, mas não é, então o ponto e vírgula lá é apenas um lembrete de que você precisa colocá-lo lá, porque o compilador não saberá o que fazer com ele. É um erro muito comum de cometer ao definir estruturas.

OK. Costumamos definir nossas estruturas no topo de nossos programas porque elas provavelmente serão usadas por várias funções. Não queremos definir uma estrutura dentro de uma função, porque então só podemos - o escopo da estrutura realmente só existe dentro dessa função. Provavelmente queremos definir uma estrutura para que possamos usá-la em várias funções ou talvez em vários arquivos que estão conectados para criar nosso único programa. Às vezes, em vez de definir a estrutura no topo, onde você coloca suas definições de inclusão e definições de liberação, por exemplo, você pode colocá-las em arquivos separados com um sufixo .h que você então inclui.

Então, temos estruturas, mas agora precisamos entrar nelas. Como entramos em uma estrutura para acessar essas subvariáveis, aquelas variáveis que existem dentro da estrutura? Bem, temos algo chamado operador de ponto, que nos permite acessar os campos da estrutura. Então, por exemplo, digamos que eu tenha declarado meu tipo de dados de estrutura em algum lugar no topo do meu programa, ou talvez em um arquivo .h que incluí. Se então quiser criar uma nova variável desse tipo de dados, posso dizer struct car, meu carro, ponto e vírgula. Assim como eu poderia dizer int x ou string nome, ponto e vírgula.

O tipo de dados aqui é struct car, o nome da variável é meu carro, e então posso usar o operador de ponto para acessar os vários campos do meu carro. Então, posso dizer meu carro.ano é igual a 2011. Isso é perfeitamente aceitável. Ano, se você se lembra, foi definido como um campo inteiro dentro deste novo tipo de dados de struct car. Então, qualquer variável do tipo de dados struct car, como meu carro, eu posso dizer meu carro.ano é igual e, em seguida, atribuir-lhe algum valor inteiro, 2011. Meu carro.plate é igual CS50. Meu carro.odômetro é igual a 50505, ponto e vírgula. Todos esses são aceitáveis e é assim que acessamos os campos da estrutura. As estruturas, no entanto, não precisam ser criadas na pilha. Assim como qualquer outra variável, podemos alocá-las dinamicamente. Se tivermos um programa que pode estar gerando muitas estruturas, não sabemos quantas vamos precisar, então precisamos alocar dinamicamente essas estruturas à medida que nosso programa está rodando. E então, se vamos acessar os campos de uma estrutura nesse contexto, lembre-se de que primeiro precisamos desreferenciar o ponteiro para a estrutura, e depois que desreferenciamos o ponteiro, podemos acessar os campos. Se só temos um ponteiro para a estrutura, não podemos simplesmente dizer nome do ponteiro.campo e obter o que estamos procurando. Há a etapa extra de desreferenciamento. Então, digamos que, em vez do exemplo anterior - assim como o exemplo anterior, em vez de declará-lo na pilha, struct car, meu carro, ponto e vírgula, digo struct car, estrela, um ponteiro para uma estrutura de carro chamada meu carro, igual a malloc tamanho de struct car. Size ofirá descobrir quantos bytes seu novo tipo de dados ocupa. Você não precisa necessariamente usar size of, largura, int ou char ou qualquer um dos tipos de dados integrados. O compilador é inteligente o suficiente para descobrir quantos bytes são necessários para a sua nova estrutura. Então, percorro um bloco de memória grande o suficiente para segurar um carro struct e obtenho um ponteiro de volta para aquele bloco de memória, e esse ponteiro é atribuído ao meu carro.

Agora, se eu quiser acessar os campos do meu carro, primeiro preciso desreferenciar meu carro usando o operador de desreferência star que vimos nos vídeos sobre ponteiros, e depois que desreferenciar o ponteiro, posso usar o operador de ponto para acessar os vários campos do meu carro. Star my car.ano é igual a 2011. Isso teria o efeito que queremos neste caso, porque alocamos dinamicamente meu carro.

Isso é meio chato, certo? Há um processo de duas etapas agora. Agora temos que desreferenciar - temos um operador star e um operador de ponto. E como você pode imaginar, porque os programadores C adoram maneiras mais curtas de fazer as coisas, há uma maneira mais curta de fazer isso. Há outro operador chamado seta, que torna esse processo muito mais fácil. A maneira como a seta funciona é que primeiro desreferencia o ponteiro no lado esquerdo do operador e, em seguida, após ter desreferenciado o ponteiro à esquerda, acessa o campo à direita. E então, anteriormente, tínhamos essa coisa de estrela meu carro. Está tudo bem, há muito acontecendo lá. Mas o que podemos fazer em vez disso é isso - meu carro seta ano é igual a 2011.

Novamente, o que está acontecendo aqui? Primeiro, estou desreferenciando meu carro. Que, novamente, é um ponteiro aqui. Então, depois de ter desreferenciado meu carro, posso então acessar os campos de ano, placa e odômetro assim como poderia antes de ter usado star para desreferenciar meu carro e ponto para acessar o campo. Então, você pode ter estruturas, pode ter ponteiros para estruturas e tem maneiras de acessar os campos dessas estruturas, seja por meio de ponteiros para eles ou pelas próprias variáveis. Dot ou seta, dependendo de como a variável foi declarada. Eu sou Doug Lloyd, isto é o CS50.