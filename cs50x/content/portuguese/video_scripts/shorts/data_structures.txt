Então, em CS50, nós cobrimos muitas estruturas de dados diferentes, certo? Já vimos arrays, listas encadeadas, tabelas de hash, tries, pilhas e filas. Também aprenderemos um pouco sobre árvores e heaps, mas na verdade tudo acaba sendo variações de um tema. Existem basicamente quatro ideias fundamentais que tudo se resume: arrays, listas encadeadas, tabelas de hash e tries. E como eu disse, são variações dessas ideias, mas isso resume tudo que vamos falar nesta aula em termos de C. Mas como comparar todas elas, certo? Já falamos sobre as vantagens e desvantagens de cada uma em vídeos separados, mas existem muitos números e pensamentos gerais sendo jogados. Vamos tentar consolidar tudo em um só lugar. Vamos analisar as vantagens e desvantagens e considerar qual estrutura de dados pode ser a certa para sua situação específica, qualquer que seja o tipo de dados que você esteja armazenando. Você não precisa necessariamente usar a inserção, exclusão e pesquisa ultra rápidas de uma trie se você realmente não se importar muito com inserções e exclusões. Se você precisar apenas de um acesso aleatório rápido, talvez um array seja melhor. Então vamos resumir isso. Vamos falar sobre cada um dos quatro tipos principais de estruturas de dados que falamos e ver quando eles podem ser bons e quando podem não ser tão bons. Então vamos começar com arrays. A inserção não é tão boa assim.

A inserção no final de um array é ok, se estivermos construindo um array enquanto vamos. Mas se precisarmos inserir elementos no meio, pense na inserção de classificação, há muitas mudanças para encaixar o elemento ali. E se formos inserir em qualquer lugar do array, exceto no final, provavelmente não será tão bom.

Da mesma forma, a exclusão, a menos que estejamos excluindo do final do array, provavelmente também não será tão boa se não quisermos deixar lacunas vazias, o que geralmente não queremos. Queremos remover um elemento e, em seguida, ajustar tudo. E assim, excluir elementos de um array também não é tão bom.

A pesquisa, no entanto, é boa. Temos acesso aleatório, pesquisa constante. Basta dizer sete e ir para a localização de índice sete do array. Dizemos 20 e vamos para a localização de índice 20 do array. Não precisamos iterar por tudo. Isso é um tanto bom.

Os arrays também são relativamente fáceis de classificar. Sempre que falamos sobre um algoritmo de classificação, como classificação de seleção, classificação de inserção, classificação de bolha, classificação de junção, sempre usamos arrays para isso, porque os arrays são relativamente fáceis de classificar, em relação às estruturas de dados que vimos até agora.

Eles também são relativamente pequenos. Não há muito espaço extra. Você cria exatamente a quantidade necessária para armazenar seus dados, e isso é basicamente tudo. Então, eles são bastante pequenos e eficientes dessa forma. Mas outra desvantagem é que eles são de tamanho fixo. Temos que declarar exatamente o tamanho que queremos para o nosso array e só temos uma chance. Não podemos aumentá-lo e diminuí-lo.

Se precisarmos aumentá-lo ou diminuí-lo, precisamos declarar um novo array completo, copiar todos os elementos do primeiro array para o segundo array. E se calculamos mal naquele momento, precisamos fazer isso novamente. Não é tão bom. Portanto, os arrays não nos dão a flexibilidade de ter números variáveis de elementos.

Com uma lista encadeada, a inserção é bastante fácil. Basta adicionar na frente. A exclusão também é fácil. Precisamos encontrar o elemento. Isso envolve alguma pesquisa.

Mas uma vez que encontramos o elemento que estamos procurando, tudo o que precisamos fazer é mudar um ponteiro, possivelmente dois se tivermos uma lista encadeada - uma lista encadeada duplamente, e então podemos liberar o nó. Não precisamos mover tudo. Basta mudar dois ponteiros e pronto.

A pesquisa é ruim, no entanto, certo? Para encontrarmos um elemento em uma lista encadeada, seja ela simples ou duplamente encadeada, precisamos pesquisar linearmente. Precisamos começar no início e ir até o fim, ou começar no final e ir para o começo. Não temos mais acesso aleatório. Então, se estamos fazendo muitas pesquisas, talvez uma lista encadeada não seja tão boa para nós.

Também é muito difícil classificar as listas encadeadas, certo? A única maneira real de classificar uma lista encadeada é classificá-la enquanto você a constrói. Mas se você classificar enquanto a constrói, não estará fazendo inserções rápidas. Você não está apenas adicionando as coisas na frente. Você precisa encontrar o lugar certo para colocá-las e, em seguida, sua inserção se torna tão ruim como a inserção em um array. Portanto, as listas encadeadas não são tão boas para classificar dados.

Eles também são relativamente pequenos, em termos de tamanho. Uma lista duplamente encadeada é um pouco maior que uma lista simplesmente encadeada, que é um pouco maior que um array, mas não é uma grande quantidade de espaço desperdiçado. Então, se o espaço for um prêmio para você, mas não for um prêmio realmente intenso, talvez seja a maneira certa de ir.

Tabelas de hash. A inserção em uma tabela hash é bastante simples. É um processo de duas etapas. Primeiro precisamos executar nossos dados através de uma função hash para obter um código hash e, em seguida, inserir o elemento na tabela de hash naquela localização de código hash.

A exclusão, semelhante à lista encadeada, é fácil uma vez que você encontra o elemento. Você precisa encontrá-lo primeiro, mas quando o exclui, você só precisa trocar alguns ponteiros, se estiver usando encadeamento separado. Se você estiver usando sondagem, ou se não estiver usando encadeamento de forma alguma em sua tabela hash, a exclusão é realmente fácil. Tudo que você precisa fazer é calcular o hash dos dados e, em seguida, ir para aquela localização. E supondo que você não tenha colisões, poderá excluir muito rapidamente.

A pesquisa é onde as coisas ficam um pouco mais complicadas. É em média melhor do que as listas encadeadas. Se você estiver usando encadeamento, ainda tem uma lista encadeada, o que significa que ainda tem o dano da pesquisa de uma lista encadeada. Mas porque você está dividindo essa lista encadeada por 100 ou 1.000 ou n elementos em sua tabela hash, suas listas encadeadas são todas um n-ésimo do tamanho. Todas são substancialmente menores. Você tem n listas encadeadas em vez de uma lista encadeada de tamanho n.

E, portanto, esse fator constante do mundo real, que normalmente não falamos em complexidade de tempo, faz diferença aqui. Então, a pesquisa ainda é uma pesquisa linear se você estiver usando encadeamento, mas o comprimento da lista que você está pesquisando é muito, muito curto em comparação. Novamente, se a classificação for sua meta aqui, a tabela hash provavelmente não é a maneira certa de seguir. Use apenas um array se classificação for realmente importante para você.

Eles podem variar muito em tamanho. É difícil dizer se uma tabela hash é pequena ou grande, porque realmente depende de quão grande é sua tabela hash. Se você for armazenar apenas cinco elementos em sua tabela hash e tiver uma tabela hash com 10.000 elementos nela, provavelmente está desperdiçando muito espaço. Por outro lado, você também pode ter tabelas hash muito compactas, mas quanto menor sua tabela hash, mais longas ficam cada uma dessas listas encadeadas. E assim, não há realmente uma maneira de definir exatamente o tamanho