Neste laboratório, sua tarefa será escrever um programa em C que simula a herança dos genes do tipo sanguíneo dentro de uma família. Para dar um pouco de antecedentes científicos, seu tipo de sangue é determinado por alelos. Alelos são diferentes versões de um gene. E existem três alelos diferentes em relação ao tipo sanguíneo, chamados A, B e O.

Cada pessoa tem dois desses alelos. Talvez você tenha dois A's, dois B's, dois O's. Ou talvez misture e combine, tenha um A e um B, ou um B e um O, ou um A ou um O, por exemplo.

E quando um pai tem um filho, cada pai passa um de seus alelos para o filho. Então, por exemplo, se imaginarmos dois pais, um com um tipo sanguíneo de AB e outro com um tipo sanguíneo de OO, então seu filho herdará um tipo sanguíneo pequeno de cada um de seus pais. Por exemplo, podemos escolher A aleatoriamente de um pai e entre o outro pai O e, por fim, obter um tipo sanguíneo de AO. Mas também poderíamos ter obtido um tipo sanguíneo de BO, por exemplo. Qual dos dois alelos é passado é escolhido aleatoriamente.

Para simular esse tipo de herança dentro de nosso programa, vamos precisar de algum tipo de estrutura de dados que nos permita representar a conexão entre pessoas e seus pais, bem como quais alelos eles têm para seu tipo sanguíneo. E porque não há um tipo construído em C para fazer exatamente isso, podemos criar um tipo próprio usando um typedef. Então, aqui temos um typedef de personagem, onde cada pessoa será representada por esses dois campos.

Personagem struct * pais [2] significa que cada pessoa terá uma matriz de 2 pais, onde cada um desses pais será um ponteiro para outra pessoa. Enquanto isso, cada pessoa também terá uma matriz de dois caracteres chamada alelos, representando quais dois alelos, A, B ou O, essa pessoa em particular tem. E porque cada pessoa tem dois alelos, esta será uma matriz de tamanho 2 para representar ambos os alelos.

Então, no exemplo que vimos antes, podemos, para essa criança em particular, ter a letra A armazenada nos alelos 0 dessa criança e 0 armazenado nos alelos 1. E, enquanto isso, pais [0] apontaria para um dos pais e pais [1] apontaria para o outro pai. Vamos ver como essas peças agora se juntariam dentro do código de distribuição que damos a você para o laboratório.

Há uma quantidade justa de código de distribuição que já fornecemos dentro de inheritance.c. Mas vamos tentar simplificar para apenas o que é mais importante. Aqui vamos notar o mesmo typedef, que definimos uma pessoa como tendo ponteiros para dois pais neste array de 2 ponteiros e também tendo uma matriz de dois caracteres, representando os dois alelos que essa pessoa tem para seu tipo sanguíneo.

Em seguida, temos essa variável relevante chamada const int GENERATIONS, um inteiro constante, que é definido como o número 3. E isso vai representar o número de gerações de dados que vamos simular gerando. Neste caso, estamos apenas esperando três gerações de dados para tipos sanguíneos, o que significa que não estamos apenas simulando a única criança, mas também a geração 2, seus pais e também a geração 3, os avós dessa criança também . Então temos alguns protótipos para funções, mas vamos pular para a função principal para realmente ver o que é que esse programa está fazendo.

A função principal já está escrita. Nada que você precise fazer aqui. Mas começamos semeando o gerador de números aleatórios, para que possamos gerar números pseudoaleatórios, o que será útil. Porque quando decidimos como os genes são herdados, queremos ser capazes de escolher aleatoriamente qual gene será transmitido dos pais para o filho.

Em seguida, chamamos a função create_family para criar uma família com um número especificado de gerações, retornando um ponteiro para a geração mais recente de pessoa dessa família. Portanto, se criarmos uma família com três gerações, acabaremos com um ponteiro para uma pessoa. Mas usando seus ponteiros de pai, poderíamos acessar os pais dessa criança, bem como os avós dessa criança, mas não mais se estivéssemos olhando apenas para uma família com três gerações.

A função create_family será sua responsabilidade de escrever. Mas a função print_family escreveremos. Depois de já ter criado uma família, já escrevemos uma função que pegará essa família e a imprimirá como uma árvore genealógica hierárquica, imprimindo que tipo de sangue cada pessoa dessa família possui.

Finalmente, você escreverá a função free_family, que liberará toda a memória que você pode ter alocado no processo de criação dessa família. Porque lembre-se de que, para cada uma das pessoas que você deseja representar dentro da memória do seu computador, provavelmente precisará alocar memória para elas usando a função malloc para alocar memória dinamicamente. Mas sempre que você alocar memória com malloc, você também desejará liberar essa memória, devolvendo-a ao computador para que ela possa ser usada para outros fins.

Aqui, na função create_family, é o que você implementará, alocando memória para uma nova pessoa e lidando com dois casos possíveis. Um, se houver possíveis pais que essa criança tem que precisamos gerar recursivamente, ou então, se estivermos gerando apenas uma única geração, gerando apenas uma única pessoa sem nenhum dado dos pais.

Você também escreverá a função free_family, que recebe como entrada um ponteiro para uma pessoa p. E a tarefa desta função é liberar p, bem como qualquer ancestral de p. Portanto, se a pessoa p tiver pais ou avós ou outros ancestrais também, você desejará ter certeza de liberá-los também.

A função print_family já escrevemos para você. Nada precisa ser feito aqui. Ele pega uma pessoa e imprime toda a sua árvore genealógica, junto com seus tipos sanguíneos. E essa função de alelo aleatório que escrevemos pode ser útil para você. Ele escolhe aleatoriamente um alelo, A, B ou O, o que pode ser útil se você chegar a um ponto em que precisa gerar aleatoriamente um alelo para armazenar dentro da matriz dele.

Portanto, com esse código de distribuição em mente, vamos ver o que seu programa vai fazer. A primeira coisa que você deve fazer é completar a função create_family para criar uma família com um número de gerações especificado. Para fazê-lo, a primeira coisa que você deve fazer é alocar memória para uma nova pessoa, chamando malloc, passando o tamanho da pessoa para garantir que você tenha memória suficiente para uma nova pessoa. E então você usará essa pessoa para potencialmente gerar ancestrais se houver mais gerações com as quais você precisa trabalhar.

Então, se gerações forem maiores do que 1, o que significa que há mais gerações que você precisa gerar, então você deverá criar recursivamente essas gerações anteriores. O que significa criar recursivamente gerações anteriores? Bem, se você estiver tentando criar uma criança que tenha dois pais de duas gerações, você chamará recursivamente a função create_family para cada um desses pais, onde cada um desses pais terá uma geração de pais e assim por diante.

Portanto, se gerações forem maiores do que 1, você desejará criar recursivamente essas gerações anteriores. E usando o valor de retorno que você obtém dessas funções create_family, você atualizará os pais dessa nova pessoa, definindo os pais [0]