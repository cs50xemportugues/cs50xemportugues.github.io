Neste laboratório, a sua tarefa será determinar qual algoritmo de ordenação é utilizado em vários programas diferentes. Agora, foram introduzidos três algoritmos diferentes de ordenação - seleção, bubble sort e merge sort. Lembre-se de que na seleção de ordenação, o algoritmo funciona ao tomar uma matriz de números e repetir algum processo - o processo de olhar através dessa matriz inteira de números para tentar encontrar o item mais pequeno nessa matriz inteira e, em seguida, trazer esse item mais pequeno para o início da matriz.

Em seguida, pesquisamos o restante da matriz, procurando o próximo item mais pequeno e, quando o encontramos, trazemos aquele próximo item mais pequeno de volta para o início da matriz, e repetimos esse processo, continuamente olhando através da porção restante não ordenada da matriz, encontrando o menor elemento e trocando-o com o elemento na próxima posição. Uma vez que repetimos esse processo em toda a matriz, acabaremos com uma matriz ordenada.

Enquanto isso, o bubble sort funciona um pouco diferente. Também faz passagens pela matriz, mas compara dois valores de cada vez. Olha para cada par de valores e tenta determinar se esse par de números está na ordem correta.

Ou seja, se você está tentando classificar do menor para o maior, certificando-se de que, para qualquer par de dois números, o número menor está à esquerda do número maior. E o que o bubble sort faz é que, se encontrar dois números que estão fora de ordem, os troca. E o bubble sort continuará a passar por esse processo de consideração de pares de valores e trocá-los, se necessário, até chegar ao final da matriz.

Finalmente, o merge sort trabalha de forma fundamentalmente diferente. Trabalha ao tomar uma matriz e dividi-la em uma metade esquerda e uma metade direita, e classificar cada uma dessas metades primeiro, e depois de classificarmos recursivamente cada uma dessas metades, juntamos essas metades novamente. Ao repetir esse processo recursivamente várias vezes, podemos construir uma matriz inteira ordenada muito rapidamente.

Cada um desses algoritmos pode ser analisado em termos de tempo de execução, em termos de big O - o limite superior no número de etapas necessárias para completar a classificação - e também em termos de big omega - o limite inferior no número de etapas necessárias para completar a classificação. Neste caso, podemos ver que, para uma seleção de classificação, ela tem tanto big O quanto big omega de n ao quadrado. Ou seja, se houver n números que estamos tentando classificar, pode levar cerca de n ao quadrado etapas para realmente completar esse algoritmo de classificação.

Enquanto isso, o bubble sort também tem um big O de n ao quadrado. Como limite superior, ainda pode levar cerca de n ao quadrado etapas para classificar n números, mas tem um big omega de n. Ou seja, se tivéssemos sorte e recebêssemos uma matriz que já está ordenada, por exemplo, o bubble sort poderia classificar n itens e usar apenas n etapas, fazendo uma passagem pela matriz, concluindo que não são necessárias algumas trocas e, em seguida, não continuar com nada, porque a matriz já está ordenada.

Enquanto isso, o merge sort tem um tempo de execução de big O de n log n e big omega de n log n também, o que significa que, se houver n números que estamos tentando classificar, esse algoritmo levará em torno de n vezes log n etapas para classificar todos esses números. Isso é melhor do que n ao quadrado, embora não seja tão bom quanto big omega de n, por exemplo.

A sua tarefa agora, neste laboratório, é que vamos lhe dar três programas - sort1, sort2 e sort3. Um deles usa a seleção de ordenação. Um deles usa o bubble sort. E um deles usa o merge sort, mas não estamos lhe dizendo qual é qual.

Sua tarefa será executar esses programas de ordenação em várias entradas diferentes - listas de números de tamanhos e ordens diferentes - e tentar determinar qual algoritmo corresponde a cada programa. Os arquivos que lhe damos serão estes: random5000.txt, por exemplo, que será um arquivo de texto que contém 5.000 números em ordem aleatória. Da mesma forma, random10000.txt e random50000.txt conterão, respectivamente, 10.000 e 50.000 números, todos em ordem aleatória.

Além dos arquivos em ordem aleatória, também lhe daremos arquivos chamados reversed5000.txt e reverse10000.txt e assim por diante, cada um dos quais também conterá números, mas desta vez em ordem inversa, do maior para o menor. E finalmente, também lhe damos sorted5000 e sorted10000.txt, que também serão arquivos de texto que contêm apenas números, um em cada linha, mas desta vez os números já estarão em ordem classificada do menor para o maior.

Vamos ver o que você pode fazer com esses arquivos. Aqui está o código distribuído para o laboratório de classificação. Você perceberá que temos nossos três programas - sort1, sort2 e sort3 - e também temos esses arquivos. Random5000.txt, por exemplo, será um arquivo com 5.000 linhas, cada uma com números, onde esses números não estão em nenhuma ordem específica.

Enquanto isso, reversed5000.txt será um arquivo de texto que também tem 5.000 números, mas desta vez estão em ordem inversa, do maior para o menor. E finalmente, arquivos como sorted5000.txt lhe darão 5.000 linhas de números, onde estão em ordem classificada em ordem crescente do menor até o maior.

Você pode então usar esses programas de classificação - sort1, sort2 e sort3 - para tentar ver como você classificaria e quanto tempo pode levar para classificar qualquer um desses arquivos. Por exemplo, eu poderia executar ./sort1 em, por exemplo, random5000.txt. E o que você verá quando eu executar esse programa é que o programa classificará esses números usando algum algoritmo de classificação e, em seguida, imprimirá esses números em ordem classificada do menor para o maior.

Agora, quanto tempo isso levou? Acontece que também existe um programa chamado "time" que pode medir o tempo que leva para outro programa ser executado. Então eu poderia dizer "time ./sort1", e em seguida random5000.txt, se eu executar isso, depois que tudo for classificado, vou ver que a quantidade de tempo que levou em tempo real foi de 0,168 segundos. E, dependendo do programa de classificação que uso e dependendo do arquivo em que executo esse algoritmo de classificação, e do número de valores que estão nesse arquivo, bem como da ordem em que esse arquivo já está, eu posso obter diferentes valores para a quantidade de tempo que leva para classificar e imprimir todos esses números.

Usando essas informações, seu desafio é resolver esse quebra-cabeça, descobrir qual algoritmo é usado no sort1, qual algoritmo é usado no sort2 e qual algoritmo é usado no sort3? Novamente, você pode testar qualquer um desses programas de classificação executando ./sort1 ou ./sort2 sort3 em um arquivo de texto que é fornecido como um argumento de linha de comando.

Por exemplo, neste caso, estamos executando sort1 em reversed10000.txt. E para medir quanto tempo leva para esses comandos, tudo o que você precisa fazer é preceder o comando "time" na frente do que quer que seja o comando que você gostaria de executar. Por exemplo, aqui estamos medindo quanto tempo leva para usar sort1 para classificar e imprimir todos os valores em reversed10000.txt.

Em última análise, você precisará testar e cronometrar cada um desses programas em alguns dos arquivos de amostra que lhe damos. Você não precisa testá-los em todos, mas provavelmente desejará testar em pelo menos alguns para ter uma ideia de como esses programas se comportam dependendo do tamanho da entrada e dependendo de quão bem-ordenados os valores dentro desse arquivo de texto já estão.

Usando essas informações, você deve ser capaz de determinar qual programa corresponde a qual algoritmo de classificação aproveitando o que sabe sobre os tempos de execução desses algoritmos de classificação. Se um algoritmo de classificação tiver um big omega muito melhor do que um big O, você pode esperar que ele seja muito mais rápido em um arquivo de texto que já está classificado, por exemplo.

E você pode examinar o que acontece com cada um desses programas enquanto tenta executá-los em entradas maiores e maiores de entradas que têm cada vez mais valores para ver quanto tempo isso leva em comparação com arquivos que têm menos valores. Usando todas essas informações como suas pistas e informações, você deve ser capaz de juntar e obter conclusões sobre qual desses algoritmos de classificação estamos usando em cada um desses programas.

Meu nome é Brian, e este foi o sort.