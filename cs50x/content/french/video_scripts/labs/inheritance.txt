Dans ce laboratoire, votre tâche sera d'écrire un programme en langage C qui simule l'hérédité des gènes de groupe sanguin au sein d'une famille. Pour donner un peu de contexte scientifique, votre groupe sanguin est déterminé par des allèles. Les allèles sont des versions différentes d'un gène. Et il existe trois allèles différents en ce qui concerne les groupes sanguins, appelés A, B et O.

Chaque personne a deux de ces allèles. Peut-être avez-vous deux A, deux B, deux O. Ou peut-être faites-vous une combinaison, avez-vous un A et un B, ou un B et un O, ou un A ou un O, par exemple.

Et lorsqu'un parent a un enfant, chaque parent transmet un de leurs allèles à leur enfant. Par exemple, si nous imaginons deux parents, l'un ayant un groupe sanguin AB et l'autre ayant un groupe sanguin OO, alors leur enfant va hériter d'un peu de sang de chacun de leurs parents. Par exemple, nous pourrions choisir au hasard A chez un parent et O chez l'autre parent, et finalement obtenir un groupe sanguin de AO. Mais nous aurions aussi pu obtenir un groupe sanguin de BO, par exemple. Lequel des deux allèles est transmis est simplement choisi au hasard.

Pour simuler ce type d'héritage à l'intérieur de notre programme, nous allons avoir besoin d'une sorte de structure de données qui nous permet de représenter la connexion entre les personnes et leurs parents, ainsi que les allèles qu'elles ont pour leur groupe sanguin. Et comme aucun type n'est intégré en C pour faire cela, nous pouvons créer un type à notre guise en utilisant un typedef. Ainsi, nous avons ici le typedef struct personne, où chaque personne sera représentée par ces deux champs.

Struct personne star * parents[2] signifie que chaque personne aura un tableau de 2 parents, chaque parent étant un pointeur vers une autre personne. Pendant ce temps, chaque personne aura également un tableau de deux caractères appelé allèles, représentant les deux allèles, A, B ou O, que cette personne a en particulier. Et parce que chaque personne a deux allèles, cela sera un tableau de taille 2 pour représenter ces deux allèles.

Donc, dans l'exemple que nous avons vu précédemment, pour cet enfant en particulier, nous pourrions avoir la lettre A stockée sur allèles 0 et 0 stockée sur allèles 1. Et entre-temps, parents[0] pointerait vers l'un des parents et parents[1] pointerait vers l'autre parent. Voyons maintenant comment toutes ces pièces s'emboîtent dans le code de distribution que nous vous donnons pour le laboratoire.

Il y a une bonne quantité de code de distribution que nous vous donnons déjà à l'intérieur de inheritance.c. Mais essayons d'en extraire juste l'essentiel. Nous remarquerons ce même typedef, où nous définissons une personne comme ayant des pointeurs vers deux parents dans ce tableau de 2 pointeurs et ayant également un tableau de deux caractères, représentant les deux allèles que cette personne a pour son groupe sanguin.

Ensuite, il y a cette variable pertinente appelée const int GENERATIONS, un entier constant, qui est défini comme le nombre 3. Et cela va représenter le nombre de générations de données que nous allons simuler la génération. Dans ce cas, nous attendons simplement trois générations de données pour les groupes sanguins, ce qui signifie que nous ne simulons pas seulement l'enfant unique, mais également la génération 2, ses parents, ainsi que la génération 3, les grands-parents de cet enfant également. Nous avons ensuite des prototypes de fonctions, mais passons à la fonction principale pour voir réellement ce que ce programme fait.

La fonction principale est déjà écrite pour vous. Vous n'avez rien à faire ici. Mais nous commençons par initialiser le générateur de nombres aléatoires, afin de pouvoir générer des nombres pseudo-aléatoires, ce qui va être utile. Parce que lorsque nous décidons de la manière dont les gènes sont hérités, nous voulons être en mesure de choisir au hasard quel gène sera transmis du parent à l'enfant.

Ensuite, nous appelons la fonction create_family pour créer une famille avec un nombre spécifié de générations, renvoyant alors un pointeur vers la génération la plus récente de personne dans cette famille. Donc, si nous créons une famille avec trois générations, nous obtiendrons un pointeur vers une personne. Mais en utilisant les pointeurs de leurs parents, nous pourrions accéder aux parents de cet enfant ainsi que les grands-parents de cet enfant, mais pas plus loin si nous ne regardons qu'une famille avec trois générations.

La fonction create_family sera à votre charge pour l'écrire. Mais nous écrirons la fonction print_family pour vous. Après avoir déjà créé une famille, nous avons déjà écrit pour vous une fonction qui prendra cette famille et les imprimera sous forme d'arbre généalogique hiérarchique, en imprimant le type sanguin de chacune des personnes de cette famille.

Enfin, vous écrirez la fonction free_family, qui libérera toute la mémoire que vous avez peut-être allouée dans le processus de création de cette famille. Car rappelez-vous que pour chacune des personnes que vous souhaitez représenter à l'intérieur de la mémoire de votre ordinateur, vous devrez probablement allouer de la mémoire pour eux en utilisant la fonction malloc pour allouer de la mémoire de manière dynamique. Mais chaque fois que vous allouez de la mémoire avec malloc, vous voudrez également libérer cette mémoire, la rendant à l'ordinateur pour qu'elle puisse être utilisée à d'autres fins.

Ici, dans la fonction create_family, vous allez donc mettre en œuvre l'allocation de mémoire pour une nouvelle personne, puis traiter deux cas possibles. L'un, s'il y a des parents potentiels que cet enfant a pour lesquels nous devons générer récursivement, sinon, si nous ne générons qu'une génération unique, générant juste une seule personne sans aucune information parentale.

Vous écrirez également la fonction free_family, qui prendra en entrée un pointeur vers une personne p. Et la tâche de cette fonction est de libérer p ainsi que tous les ancêtres de p. Ainsi, si la personne p a des parents ou des grands-parents ou d'autres ancêtres également, vous voudrez vous assurer de les libérer également.

La fonction print_family a été écrite pour vous. Aucune action à effectuer ici. Elle prend une personne et la parcourt pour ensuite imprimer son arbre généalogique complet avec leurs types sanguins. Et cette fonction d'allèle aléatoire que nous avons écrite peut vous être utile également. Elle choisit aléatoirement un allèle, A, B, ou O, ce qui peut être utile si vous en arrivez à un point où vous devez générer aléatoirement un allèle à stocker à l'intérieur du tableau de l'allèle.

Avec ce code de distribution en tête, examinons maintenant ce que votre programme fera. La première chose à faire est de compléter la fonction create_family pour créer une famille avec un nombre spécifié de générations. Pour ce faire, la première chose à faire est d'allouer de la mémoire pour une nouvelle personne, en appelant malloc, en passant la taille de personne pour vous assurer d'avoir suffisamment de mémoire pour une nouvelle personne. Et vous utiliserez cette personne pour générer éventuellement des ancêtres s'il y a plus de générations avec lesquelles vous devez travailler.

Si le nombre de générations est supérieur à 1, ce qui signifie qu'il existe plus de générations que vous devez générer, vous allez alors créer récursivement ces générations précédentes. Que signifie créer récursivement les générations précédentes ? Eh bien, si vous essayez de créer un enfant qui a deux génér