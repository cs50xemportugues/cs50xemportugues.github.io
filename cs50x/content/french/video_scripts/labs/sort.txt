Dans ce laboratoire, votre tâche sera de déterminer quel algorithme de tri différents programmes utilisent. Nous avons été présentés à trois différents algorithmes de tri - le tri par sélection, le tri à bulles et le tri fusion. Rappelons que dans le tri par sélection, l'algorithme fonctionne en prenant un tableau de nombres et en répétant un processus - le processus de recherche à travers tout le tableau de nombres pour essayer de trouver le plus petit élément de ce tableau entier, puis en apportant cet élément à la première position du tableau.

Ensuite, nous parcourons le reste du tableau, en cherchant le prochain élément le plus petit, et lorsque nous le trouvons, nous ramenons ce prochain plus petit élément au début du tableau, et nous répétons ce processus, en regardant continuellement la partie non triée restante du tableau, en trouvant l'élément le plus petit et en l'échangeant avec l'élément de la position suivante. Après avoir répété ce processus dans tout le tableau, nous obtiendrons un tableau trié.

Pendant ce temps, le tri à bulles fonctionne un peu différemment. Il fait également des passes à travers le tableau, mais il compare deux valeurs à la fois. Il regarde chaque paire de valeurs et essaie de déterminer si cette paire de nombres est dans l'ordre correct.

Cela signifie que si vous essayez de trier du plus petit au plus grand, en vous assurant que pour toute paire de deux nombres, le nombre le plus petit est à gauche du nombre le plus grand. Et ce que le tri à bulles fait, c'est s'il trouve deux nombres qui sont hors d'ordre, il les échange. Et le tri à bulles continuera constamment à travers ce processus de considérer des paires de valeurs et de les échanger si nécessaire, jusqu'à ce qu'il atteigne la fin du tableau.

Enfin, le tri fusion fonctionne fondamentalement différemment. Il fonctionne en prenant un tableau et en le divisant en une moitié gauche et une moitié droite, et en triant d'abord chacune de ces moitiés, puis après avoir trié chacune de ces moitiés de manière récursive, nous fusionnons ces moitiés ensemble. En répétant ce processus de manière récursive, nous pouvons construire très rapidement un tableau trié entier.

Chacun de ces algorithmes peut être analysé en termes de temps d'exécution, en termes de grand O - la borne supérieure sur le nombre d'étapes nécessaires pour effectuer le tri - ainsi que de grand oméga - la borne inférieure sur le nombre d'étapes nécessaires pour effectuer le tri. Dans ce cas, nous pouvons voir que pour un tri par sélection, il a à la fois un grand O et un grand oméga de n au carré. C'est-à-dire que s'il y a n nombres que nous essayons de trier, il pourrait falloir environ n au carré d'étapes pour effectuer cet algorithme de tri.

Trier à bulles, quant à lui, a également un grand O de n au carré. En tant que borne supérieure, cela peut prendre environ n au carré d'étapes pour trier n nombres, mais il a un grand oméga de n. Cela veut dire que si nous avons de la chance et que nous avons un tableau qui est déjà trié, par exemple, le tri à bulles pourrait trier n éléments en utilisant juste n étapes en faisant une passe à travers le tableau, en concluant qu'aucun échange n'est nécessaire, puis ne continuant pas avec quoi que ce soit d'autre, car le tableau est déjà trié.

Pendant ce temps, le tri fusion a un temps d'exécution de grand O de n log n et un grand oméga de n log n également, ce qui signifie que s'il y a n nombres que nous essayons de trier, cet algorithme va prendre environ n fois log n étapes pour trier tous ces nombres. C'est mieux que n au carré, mais pas aussi bon que grand oméga de n, par exemple.

Votre tâche maintenant, dans ce laboratoire, est que nous allons vous donner trois programmes - tri1, tri2 et tri3. L'un utilise le tri par sélection. L'un utilise le tri à bulles. Et l'un utilise le tri fusion, mais nous ne vous disons pas lequel utilise lequel.

Votre tâche sera de faire tourner ces programmes d'algorithmes de tri sur différents inputs - des listes de nombres de différentes tailles et ordres différents - et d'essayer de déterminer quel algorithme correspond à quel programme. Les fichiers que nous vous donnons seront ceux-ci. Nous vous donnerons un fichier appelé random5000.txt, par exemple, qui sera un fichier texte contenant 5 000 nombres dans un ordre aléatoire. De même, random10000.txt et random50000.txt contiendront respectivement 10 000 50 000 nombres, tous dans un ordre aléatoire.

En plus des fichiers dans un ordre aléatoire, nous vous donnerons également des fichiers appelés reversed5000.txt et reverse10000.txt, et ainsi de suite, qui contiendront également des nombres, mais cette fois-ci dans l'ordre inverse, du plus grand au plus petit. Et enfin, nous vous donnons également sorted5000 et sorted10000.txt, qui seront également des fichiers texte contenant des nombres, un par ligne, mais cette fois-ci les nombres seront déjà dans l'ordre trié du plus petit au plus grand.

Voyons ce que vous pouvez faire avec ces fichiers. Voici le code de distribution pour le laboratoire de tri. Vous remarquerez que nous avons nos trois programmes - tri1, tri2 et tri3 - et nous avons également ces fichiers. Random5000.txt, par exemple, sera un fichier avec 5 000 lignes, chacune avec des nombres, où ces nombres ne sont dans aucun ordre particulier.

Pendant ce temps, reversed5000.txt sera un fichier texte contenant également 5 000 nombres, mais cette fois-ci ils sont dans l'ordre inverse, du plus grand au plus petit. Et enfin, des fichiers tels que sorted5000.txt vous donneront 5 000 lignes de nombres, où ils sont triés dans l'ordre ascendant du plus petit au plus grand.

Vous pouvez ensuite utiliser ces programmes de tri - tri1, tri2 et tri3 - pour essayer de voir comment vous pourriez trier et combien de temps cela pourrait prendre pour trier n'importe lequel de ces fichiers. Par exemple, je pourrais exécuter ./tri1 sur, disons, random5000.txt. Et ce que vous verrez lorsque j'exécuterai ce programme, c'est que le programme triera ces nombres en utilisant un algorithme de tri, puis imprimera ces nombres dans l'ordre trié du plus petit au plus grand.

Maintenant, combien de temps cela a-t-il pris? Il s'avère qu'il y a également un programme appelé time qui peut chronométrer le temps qu'il faut pour qu'un autre programme s'exécute. Je pourrais donc dire time ./tri1 et ensuite random5000.txt, et si je fais cela, après que tout soit trié, je verrai que le temps que cela a pris en temps réel était de 0,168 secondes. Et selon l'algorithme de tri que j'utilise, selon le fichier sur lequel je lance cet algorithme de tri, et le nombre de valeurs qui sont dans ce fichier, ainsi que l'ordre dans lequel ce fichier est déjà, je pourrais obtenir différentes valeurs pour la quantité de temps nécessaire pour trier et imprimer toutes ces valeurs.

En utilisant ces informations, votre défi est de résoudre ce puzzle, de trouver quel algorithme utilise tri1, quel algorithme utilise tri2, et quel algorithme utilise tri3 ? Encore une fois, vous pouvez tester n'importe lequel de ces programmes de tri en exécutant ./tri1 ou ./tri2 tri3 sur un fichier texte qui est fourni en tant qu'argument de ligne de commande.

Par exemple, dans ce cas, nous exécutons tri1 sur reversed10000.txt. Et pour chronométrer combien de temps chacune de ces commandes prend, vous devez simplement ajouter la commande time devant la commande que vous souhaiteriez autrement exécuter. Par exemple, ici nous chronométrons combien de temps il faut pour utiliser tri1 pour trier et imprimer toutes les valeurs dans reversed10000.txt.

En fin de compte, ce que vous devrez faire est de tester et chronométrer chacun de ces programmes sur certains des fichiers d'exemple que nous vous donnons. Vous n'êtes pas obligé de tous les tester, mais vous voudrez probablement en tester au moins quelques-uns pour avoir une idée de la façon dont ces programmes se comportent en fonction de la taille de l'entrée, et en fonction de la façon dont les valeurs à l'intérieur de ce fichier texte sont déjà ordonnées.

En utilisant ces informations, vous devriez être en mesure de déterminer quel programme correspond à quel algorithme de tri en exploitant ce que vous savez sur les temps d'exécution de ces algorithmes de tri. Si un algorithme de tri a un grand oméga beaucoup plus grand que son grand O, alors vous pourriez vous attendre à ce qu'il soit beaucoup plus rapide sur un fichier texte déjà trié, par exemple.

Et vous pourriez examiner ce qui se passe avec chacun de ces programmes lorsque vous essayez de les exécuter sur des entrées plus grandes et plus grandes d'entrées qui ont de plus en plus de valeurs pour voir combien de temps cela prend par rapport à des fichiers qui ont moins de valeurs. En utilisant tout cela comme vos indices et informations, vous