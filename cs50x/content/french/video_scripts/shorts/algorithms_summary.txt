Donc dans CS50, nous avons appris divers algorithmes de tri et de recherche. Parfois, il peut être un peu difficile de suivre ce que chaque algorithme fait. En réalité, nous n'avons qu'effleuré la surface et il y a beaucoup d'autres algorithmes de recherche et de tri. Dans cette vidéo, nous allons prendre quelques minutes pour essayer de distiller chaque algorithme en ses éléments de base, afin que vous puissiez vous souvenir des informations les plus importantes sur chacun d'entre eux et pouvoir articuler les différences si nécessaire.

Le premier est le tri par sélection. L'idée de base derrière le tri par sélection est de trouver le plus petit élément non trié dans un tableau et de l'échanger avec le premier élément non trié de ce tableau. Nous avons dit que le pire temps d'exécution de cet algorithme était n au carré. Si vous souhaitez vous rappeler pourquoi, jetez un coup d'œil à la vidéo sur le tri par sélection. Le meilleur temps d'exécution est également n au carré.

Pour le tri à bulles, l'idée derrière cet algorithme est d'échanger les paires adjacentes. C'est la clé qui vous aide à vous souvenir de la différence ici. Le tri par sélection consiste à trouver le plus petit élément, tandis que le tri à bulles consiste à échanger les paires adjacentes d'éléments si elles sont hors ordre, ce qui fait effectivement remonter les éléments plus grands vers la droite, tout en faisant bouger les éléments plus petits vers la gauche. Le pire temps d'exécution pour le tri à bulles est n au carré. Le meilleur temps d'exécution est n car dans cette situation, nous n'avons peut-être pas besoin d'effectuer d'échanges du tout. Nous n'avons qu'à faire un passage à travers les n éléments.

Pour le tri par insertion, l'idée de base est le décalage. C'est le mot-clé du tri par insertion. Nous allons parcourir le tableau une fois de gauche à droite. Et alors que nous le faisons, nous allons décaler les éléments que nous avons déjà vus pour faire de la place pour ceux qui doivent être placés quelque part dans cette portion triée. Nous construisons donc le tableau trié élément par élément, de gauche à droite, et nous décalons les éléments pour faire de la place. Le pire temps d'exécution pour le tri par insertion est n au carré. Le meilleur temps d'exécution est n.

Pour le tri fusion, le mot-clé ici est la division et la fusion. Nous divisons le tableau complet, que ce soit avec six, huit ou dix mille éléments, en deux, en deux, en deux, jusqu'à ce que nous ayons un tableau de n tableaux d'un seul élément. Un ensemble de n tableaux d'un seul élément. Nous avons commencé avec un tableau de 1 000 éléments et nous sommes arrivés au point où nous avons 1 000 tableaux d'un élément chacun. Nous commençons ensuite à fusionner ces sous-tableaux dans le bon ordre. Nous prenons deux tableaux d'un seul élément et créons un tableau de deux éléments. Nous prenons deux tableaux de deux éléments et créons un tableau de quatre éléments, et ainsi de suite jusqu'à ce que nous ayons reconstruit un tableau d'un seul élément de n. 

Le pire temps d'exécution pour le tri fusion est n fois le logarithme de n. Nous avons n éléments, mais ce processus de recombinaison prend log n étapes pour revenir à un tableau complet. Le meilleur temps d'exécution est également n log n car ce processus ne se soucie pas vraiment de savoir si le tableau était trié ou non au départ. Le processus est le même et il n'y a pas de moyen de court-circuiter les choses. Donc n log n dans le pire des cas, n log n dans le meilleur des cas. 

Nous avons parlé de deux algorithmes de recherche. La recherche linéaire consiste à itérer. Nous parcourons le tableau une fois de gauche à droite en essayant de trouver le nombre que nous recherchons. Le pire temps d'exécution est de l'ordre de n. Il peut nous falloir itérer sur chaque élément pour trouver l'élément que nous recherchons, soit dans la dernière position, soit pas du tout. Mais nous ne pouvons pas le confirmer tant que nous n'avons pas regardé tout le tableau. Le meilleur temps d'exécution est immédiat. Le meilleur temps d'exécution de la recherche linéaire est de l'ordre de 1.

Enfin, il y avait la recherche binaire, qui nécessite un tableau trié. C'est une considération très importante lorsqu'on travaille avec une recherche binaire. C'est une condition préalable à son utilisation : le tableau que vous parcourez doit être trié. Sinon, le mot-clé est diviser pour mieux régner. Nous divisons le tableau par moitié et éliminons la moitié des éléments à chaque fois que nous avançons. En raison de cette approche de division et de conquête et de la division par deux, le pire temps d'exécution de la recherche binaire est logarithmique, ce qui est nettement mieux que la n de la recherche linéaire. Le meilleur temps d'exécution est de l'ordre de 1. Nous pourrions le trouver immédiatement la première fois que nous effectuons une division, mais souvenez-vous que, même si la recherche binaire est nettement meilleure que la recherche linéaire en étant log n contre n, vous devrez peut-être trier votre tableau au préalable, ce qui peut la rendre plus longue en fonction de la taille du tableau trié. 

Je suis Doug Lloyd, c'est CS50.