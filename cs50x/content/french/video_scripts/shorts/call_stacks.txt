Si vous avez vu notre vidéo sur la récursion, le processus a peut-être semblé un peu magique. Comment une fonction sait-elle attendre une autre fonction et transmettre ses données à quelque chose d'autre qui fonctionne en même temps? Cela peut sembler un peu magique au premier abord si vous ne comprenez pas exactement comment les fonctions sont appelées et fonctionnent en C. Et la façon dont elles fonctionnent utilise quelque chose appelé la pile d'appel. Et la façon dont la pile d'appel fonctionne est la suivante. Si vous appelez une fonction, ce qui se passe essentiellement, c'est qu'un gros bloc de mémoire est réservé quelque part dans le système pour cette fonction pour effectuer son travail. Par exemple, si vous appelez une fonction et que la première chose que vous faites est de déclarer quelques variables, ce qui va se passer, c'est qu'une trame de pile ou une trame de fonction sera créée, un gros bloc de mémoire et ces variables recevront de l'espace. Donc, s'il s'agit de trois entiers, vous obtiendrez trois morceaux de quatre octets, tout comme la taille d'un entier, ainsi que de l'espace pour effectuer des calculs et tout ce que la fonction pourrait nécessiter. Et c'est là que la fonction fera tout son travail. Maintenant, il est possible que plusieurs trames de fonctions puissent exister simultanément en mémoire. Par exemple, disons que la fonction principale appelle une autre fonction appelée déplacement. Et puis la fonction de déplacement appelle une autre fonction appelée direction. À ce stade, toutes les trois de ces fonctions ont des trames ouvertes. Mais en général, une seule de ces trames sera active. Seule une de ces fonctions est en cours d'exécution à un moment donné, même si toutes les trois ont de l'espace réservé et attendent de faire quelque chose. Maintenant, la façon dont ces trames sont disposées est ce que l'on appelle une pile. Et la trame pour la fonction récemment appelée est toujours celle en haut de la pile, et c'est ce qu'on appelle la trame active. Donc, encore une fois, si la fonction principale appelle le mouvement et que le mouvement appelle la direction, vous pouvez penser à cela comme une pile comme suit, où la fonction principale est en bas, le mouvement est au-dessus, la direction est en haut et la direction est la trame active. C'est la seule fonction qui fait quelque chose pour le moment, alors que le mouvement et la fonction principale attendent simplement de devenir la trame active. Ils attendent de devenir la trame qui est en haut de la pile. Lorsque vous appelez une nouvelle fonction, une nouvelle trame est ce qu'on appelle poussée en haut de la pile. Donc, si vous appelez une nouvelle fonction, cette fonction obtient immédiatement de l'espace et de la mémoire et est placée en haut de la pile d'appel. Et il devient la trame active. Et quoi que ce soit qui était la trame active, s'il y en avait une, est en pause. Il est simplement en attente. C'est un mode d'attente en attendant de devenir à nouveau la trame active. Lorsqu'une fonction termine son travail, comme en retournant, le plus couramment, ou peut-être en atteignant la fin de la ligne s'il s'agit d'une fonction vide, qui n'a pas de valeur de retour, cette trame est ce qu'on appelle retirée de la pile. Et ensuite, la trame qui était en deuxième place, puisque cette trame est maintenant partie, celle-ci devient la trame active. Elle reprend là où elle s'était arrêtée. Si vous appuyiez sur pause sur cette fonction, elle reprendra immédiatement là où elle s'était arrêtée. C'est la raison pour laquelle la récursion fonctionne, car toutes ces trames fonctionnent, mais une seule d'entre elles est en mouvement à un moment donné. Les autres fonctionnent toutes, mais elles sont en pause. Elles attendent simplement de devenir la nouvelle trame en haut de la pile. Si nous appelons une autre fonction, la trame active se met à nouveau en pause. La fonction qui vient d'être appelée est placée au sommet, et ainsi de suite jusqu'à ce que toutes les trames de fonctions soient terminées. Jetons un coup d'œil à une visualisation de cela, un exemple utilisant la fonction factorielle pour voir si nous pouvons aider à rendre cela un peu plus clair. Ainsi, voici l'intégralité d'un fichier factoriel, par exemple. Et à l'intérieur de ce fichier factoriel, j'ai deux fonctions, fact, qui sera une implémentation récursive de la factorielle, et main, qui appelle ou imprime simplement la valeur de la factorielle, dans ce cas, de 5. Nous commençons au début de main. Et la première chose que fait main est qu'il appelle une autre fonction. Il appelle printf. Dès qu'il le fait, main est en pause. Il pend ici et attend que printf fasse son travail. Que doit faire printf? Il suffit d'imprimer un nombre, mais il doit imprimer la factorielle de 5 sinon il ne connaît pas la factorielle de 5. Il doit faire un appel de fonction. Donc, printf passe ensuite en pause et attend que la factorielle de 5, qui devient maintenant la nouvelle trame active, fasse son travail. Ainsi, dans la trame factorielle de 5, que se passe-t-il? Nous passons la valeur 5 à la fonction fact. Ensuite, il va vérifier si n est égal à 1. Non. Donc, il va renvoyer n fois fact n moins 1. OK, donc maintenant la trame factorielle de 5 appelle essentiellement une nouvelle fonction, passant un autre appel à la factorielle, en passant 4 comme paramètre à la place. Ainsi, la trame factorielle de 5 est désormais en pause et une trame pour la factorielle de 4 devient la nouvelle trame active. Et le processus est le même. Est-ce que 4 est égal à 1? Non. Alors, au lieu de cela, il va renvoyer n fois, dans ce cas, 4 fois la factorielle de 3, un autre appel de fonction. La trame factorielle de 4 est en pause. La trame factorielle de 3 devient la nouvelle trame active. Et cela se répète encore pour la factorielle de 3, pour la factorielle de 2, et puis nous arrivons à la factorielle de 1. Donc, au tout début, lorsque la factorielle de 1 est appelée, il y a sept trames de fonction dans la pile d'appel. La factorielle de 2, 3, 4, 5 printf() et main sont toutes en pause aux lignes que vous voyez là-bas. Ils attendent simplement de devenir la nouvelle trame active. Mais ils ne se déplacent pas à partir de ces indicateurs fléchés. La trame pour la factorielle de 1 commence. Elle pose la question, est-ce que n est égal à 1? Eh bien, dans ce cas, la réponse est oui. Elle va renvoyer 1. Maintenant, rappelez-vous ce qui se passe lorsque qu'une fonction renvoie une valeur, cette trame est terminée. Elle disparaît. Et cela signifie qu'elle est retirée de la pile d'appel et ensuite la trame qui est en dessous d'elle deviendra la nouvelle trame active. La factorielle de 1 renvoie 1. À ce stade, sa trame est détruite et la factorielle de 2 peut maintenant être désactivée. Maintenant, la factorielle de 2 est cette ligne bleu foncé sur la gauche et elle attendait le résultat de retour de la factorielle de 1. Eh bien, la factorielle de 1 a dit, je t'ai renvoyé un 1. Donc la factorielle de 2 va renvoyer 2 fois 1, soit 2. Elle retourne 2 et lorsqu'elle retourne, elle est retirée de la pile. Sa trame de fonction est détruite et la factorielle de 3 devient la nouvelle trame active. La factorielle de 3 attendait la factorielle de 2, qui a renvoyé 2. Donc, elle va renvoyer 3 fois 2, soit 6, et retourne la valeur. Sa trame de fonction est retirée de la pile. Elle est détruite. La factorielle de 4 devient la nouvelle trame active. La factorielle de 4 attendait la factorielle de 3. Elle a obtenu sa réponse de 6. Donc, elle va renvoyer 4 fois 6, soit 24. Et elle va renvoyer cette valeur à la factorielle de 5, qui attendait que la factorielle de 4 termine son travail. Elle renvoie 5 fois 24, soit 120. Lorsque cette trame est détruite, nous reprenons maintenant avec printf(). Sa ligne rouge foncé est en bas. Elle attendait la factorielle de 5, qui vient de renvoyer 120. Donc, ce que printf() fait, c'est qu'elle imprime 120 et puis son travail est terminé. Elle ne doit rien retourner, mais elle n'a rien d'autre à faire. Elle ne doit pas