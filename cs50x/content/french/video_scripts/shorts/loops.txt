Très bien, parlons des boucles. Les boucles sont intéressantes car elles permettent à votre programme d'exécuter des lignes de code encore et encore sans avoir à les copier ou à les répéter autrement. Il existe trois types de boucles majeures que vous rencontrerez, et vous serez probablement amené à en utiliser chacune au fur et à mesure que vous progresserez dans CS50. Certaines de ces boucles vous sont également familières depuis Scratch, donc comme nous l'avons fait avec les conditionnelles, nous les mettrons côte à côte s'il y a une analogie à tirer.

La première est forever de Scratch, qui correspond à while (true). C'est ce que l'on appelle une boucle infinie. Les lignes de code entre les accolades, comme les pièces de puzzle qui s'insèrent dans le C du bloc forever, seront exécutées à répétition du haut vers le bas, encore et encore, pour toujours. Après tout, si vous vous souvenez de notre discussion sur les expressions booléennes, true est toujours vrai. Donc, si nous faisons quelque chose tant que true est vrai - cela semble un peu idiot - true est toujours vrai, donc cela fonctionnera toujours. Cela fonctionnera à l'infini jusqu'à ce que nous trouvions un moyen d'en sortir avec une instruction break, que nous avons vue il y a un moment lorsque nous avons parlé de switch.

Ou sinon, nous pouvons simplement tuer notre programme, ce qui, soit dit en passant, si vous vous trouvez dans une situation avec une boucle infinie et que vous ne savez pas comment arrêter votre programme de s'exécuter, appuyez simplement sur Ctrl et C, et cela tuera votre programme pour vous. Mais cela s'appelle encore une boucle infinie. C'est une boucle qui fonctionnera à l'infini. Maintenant, les boucles while ne sont pas toujours infinies, car nous pouvons également remplacer l'expression booléenne par quelque chose de plus utile que simplement true. Voici un autre exemple. While et une certaine expression booléenne, puis les accolades. C'est assez similaire au repeat until de Scratch. Bien que dans un instant, j'expliquerai la différence.

En C, si l'expression booléenne à l'intérieur de la boucle while est vraie, les lignes de code entre les accolades seront exécutées à répétition jusqu'à ce que l'expression booléenne évalue à false. Par exemple, vous pouvez avoir une sorte de compteur. Disons que vous commencez cette boucle par int x égal à zéro. Tant que x est inférieur à 100, faites quelques choses à l'intérieur de ces accolades, puis à la fin de votre boucle, vous dites x plus plus, vous incrémentez x. Finalement, x atteindra 100 et vous vous arrêterez car la condition x est inférieure à 100 ne sera plus vraie dès que x sera égal à 100. 100 n'est pas inférieur à 100.

Maintenant, de manière quelque peu confuse, le comportement du bloc Scratch est inversé. Soyez donc très prudent si c'est votre première incursion dans l'utilisation de boucles. Fondamentalement, le bloc repeat until dans Scratch répétera quelque chose encore et encore jusqu'à ce que l'expression, l'expression booléenne dans l'hexagone, soit vraie. Donc, il continuera à le faire jusqu'à ce que ce soit vrai. Pendant ce temps, la boucle while continuera à le faire jusqu'à ce que ce soit faux. Ils sont assez similaires, mais il y a cette petite distinction à laquelle il faut faire attention, surtout lorsque vous faites vos premières tentatives de transition de Scratch à C. Le dernier type de boucle est en réalité assez similaire. Il s'appelle la boucle do while. Cette boucle exécutera toutes les lignes de code entre les accolades une fois, puis elle vérifiera l'expression booléenne. Si l'expression booléenne est vraie, elle reviendra en arrière et répétera ce processus encore et encore jusqu'à ce que l'expression booléenne soit fausse. Donc, contrairement à une boucle while, cette boucle est garantie de s'exécuter au moins une fois. Cela peut être assez utile.

Enfin, nous avons une boucle for. Les boucles for sont un peu inesthétiques sur le plan syntaxique et il y a beaucoup de choses qui se passent ici, donc suivez-nous pendant que nous essayons de décomposer ces éléments. En général, l'utilisation d'une boucle for est lorsque vous voulez répéter quelque chose un nombre spécifique de fois. Dans cet exemple ici, j'ai le bloc repeat de Scratch, qui est analogue à la boucle for en C, répétant quelque chose 10 fois. Et la boucle for à gauche là-bas, qui est une boucle for qui ferait la même chose. Cela irait 10 fois. En commençant à compter à zéro, nous augmentons à chaque passage de la boucle. Et nous continuons à faire cela jusqu'à ce que i soit inférieur à 10.

Alors qu'est-ce qui se passe? Il y a beaucoup de code là-dedans. Analysons étape par étape ce qui se passe dans une boucle for. La première chose qui se passe est que la variable compteur est initialisée. Tout ce qui se trouve à gauche de ce premier point-virgule à l'intérieur de la parenthèse est exécuté. Dans ce cas, nous disons int i égal à zéro. En déclarant une nouvelle variable appelée i, cette variable est de type entier et nous disons que la valeur de cette variable va être zéro.

La deuxième chose que nous faisons est que nous évaluons immédiatement l'expression booléenne. L'expression booléenne se situe entre les deux points-virgules. i est inférieur à 10. C'est vrai ici, non? Nous venons de dire que i est égal à zéro, donc 0 est inférieur à 10, et donc cette condition est vraie et nous allons maintenant procéder à exécuter le corps de la boucle. Si c'était faux. Si, par exemple, je disais à la place de i égal à 0, je disais i égal à 15, int i égal à 15. Eh bien, 15 n'est pas inférieur à 10, alors nous n'entrerions jamais dans le corps de la boucle car l'expression booléenne serait évaluée comme étant fausse.

Après avoir parcouru du haut vers le bas, nous rencontrons cette accolade de fermeture, une troisième chose se produit. La variable compteur est incrémentée, ou plutôt, les lignes de code d'une instruction après le deuxième point-virgule à l'intérieur des parenthèses de la boucle for sont exécutées. Nous commençons donc en disant int i égal à 0. Puis nous vérifions si oui ou non l'expression booléenne est vraie. 0 est inférieur à 10, donc c'est vrai. Nous allons donc passer au corps de la boucle. Des choses se passeront à l'intérieur de la boucle, et lorsque nous rencontrerons cette accolade de fermeture, la prochaine chose que nous ferons est de dire i plus plus. i était zéro, maintenant i est un. Puis nous