D'accord. Donc si vous venez juste de finir cette vidéo sur les listes chaînées simples, désolé de vous avoir laissé en suspens. Mais je suis content que vous soyez là pour finir l'histoire des listes chaînées doubles. 

Donc si vous vous souvenez de cette vidéo, nous avons parlé de la façon dont les listes chaînées simples limitent notre capacité à traiter les informations où le nombre d'éléments ou le nombre d'éléments dans une liste peut augmenter ou diminuer. Nous pouvons maintenant traiter quelque chose comme ça, que nous ne pouvions pas traiter avec des tableaux. 

Mais ils souffrent d'une limitation critique, qui est qu'avec une liste chaînée simple, nous ne pouvons jamais nous déplacer que dans une seule direction de la liste. Et la seule situation réelle où cela peut poser un problème était lorsque nous essayions de supprimer un seul élément. Et nous n'avons même pas discuté de la façon de le faire dans une liste chaînée simple en pseudo-code. C'est certainement faisable, mais cela peut être un peu fastidieux. Donc si vous vous retrouvez dans une situation où vous essayez de supprimer des éléments individuels de la liste ou qu'il sera nécessaire de supprimer des éléments individuels de la liste, vous voudrez peut-être envisager d'utiliser une liste chaînée double plutôt qu'une liste chaînée simple. Parce que les listes chaînées doubles vous permettent de vous déplacer à la fois vers l'avant et vers l'arrière dans la liste au lieu de simplement avancer dans la liste, juste en ajoutant un élément supplémentaire à la définition de notre structure pour le nœud de liste chaînée double. 

Encore une fois, si vous ne vous apprêtez pas à supprimer des éléments individuels de la liste, car nous ajoutons un champ supplémentaire à la définition de notre structure, les nœuds eux-mêmes pour les listes chaînées doubles vont être plus grands. Ils vont prendre plus d'octets de mémoire. Et donc si ce n'est pas quelque chose que vous allez avoir besoin de faire, vous pourriez décider que cela ne vaut pas la peine de faire le compromis de devoir dépenser les octets supplémentaires de mémoire requis pour une liste chaînée double si vous n'allez pas supprimer des éléments individuels. Mais ils sont également cool pour d'autres choses aussi. 

Donc comme je l'ai dit, nous devons simplement ajouter un seul champ à notre définition de structure - cette notion d'un pointeur Précédent. Alors avec une liste chaînée simple, nous avons la valeur et le pointeur Suivant, donc la liste chaînée double a juste un moyen de se déplacer vers l'arrière aussi. 

Maintenant, dans la vidéo sur les listes chaînées simples, nous avons parlé de cinq des principales choses que vous devez être capable de faire pour travailler avec des listes chaînées. Et pour la plupart d'entre elles, le fait que c'est une liste chaînée double n'est pas vraiment une grande différence. Nous pouvons toujours rechercher en avançant de bout en bout. Nous pouvons toujours créer un nœud à partir de rien, à peu près de la même manière. Nous pouvons également supprimer des listes de la même manière. Les seules choses qui sont légèrement différentes, vraiment, sont l'insertion de nouveaux nœuds dans la liste, et nous parlerons enfin de la suppression d'un élément unique de la liste également. Encore une fois, presque les trois autres, nous n'allons pas en parler maintenant car ce ne sont que des réglages mineurs des idées discutées dans la vidéo sur les listes chaînées simples. 

Alors ajoutons un nouveau nœud à une liste chaînée double. Nous avons parlé de faire cela pour les listes chaînées simples aussi, mais il y a quelques captures supplémentaires avec les listes chaînées doubles. Nous passons la tête de la liste ici et une valeur arbitraire, et nous voulons sortir de cette fonction la nouvelle tête de la liste. C'est pourquoi elle renvoie un pointeur de type dllnode. Alors quelles sont les étapes? Elles sont, encore une fois, très similaires aux listes chaînées simples avec une addition supplémentaire. Nous voulons allouer de l'espace pour un nouveau nœud et vérifier qu'il est valide. Nous voulons remplir ce nœud avec les informations que nous voulons y mettre. La dernière chose que nous devons faire - la chose supplémentaire que nous devons faire - est de corriger le pointeur Précédent de l'ancienne tête de la liste. Rappelons que, grâce aux listes chaînées doubles, nous pouvons nous déplacer vers l'avant et vers l'arrière - ce qui signifie que chaque nœud pointe en fait vers deux autres nœuds au lieu d'un seul. Et donc nous devons corriger l'ancienne tête de la liste pour pointer vers l'arrière vers la nouvelle tête de la liste chaînée, ce qui était quelque chose que nous n'avions pas à faire auparavant. Et comme précédemment, nous retournons simplement un pointeur vers la nouvelle tête de la liste. 

Donc voici une liste. Nous voulons insérer 12 dans cette liste. Remarquez que le diagramme est légèrement différent. Chaque nœud contient trois champs - les données, un pointeur Suivant en rouge et un pointeur Précédent en bleu. Rien ne précède le nœud de 15, donc son pointeur Précédent est nul. C'est le début de la liste. Il n'y a rien avant lui. Et rien ne vient après le nœud de 10, donc son pointeur Suivant est également nul. 

Donc ajoutons 12 à cette liste. Nous avons besoin d'espace pour le nœud. Nous y mettons 12. Et encore une fois, nous devons être très prudents de ne pas casser la chaîne. Nous voulons réorganiser les pointeurs dans le bon ordre. Et parfois, cela peut signifier - comme nous le verrons particulièrement avec la suppression - que nous avons des pointeurs redondants, mais ce n'est pas grave. 

Que voulons-nous faire en premier? Je recommanderais probablement de remplir les pointeurs du nœud 12 avant de toucher qui que ce soit d'autre. Vers quoi va pointer 12 ensuite? 15. Qu'est-ce qui vient avant 12? Rien. Maintenant, nous avons rempli les informations supplémentaires dans 12 afin qu'il ait des pointeurs Précédent, Suivant et une valeur. 

Maintenant, nous pouvons avoir 15 - cette étape supplémentaire dont nous parlions - pointer vers 12 à partir de son pointeur Précédent. Et maintenant, nous pouvons déplacer la tête de la liste chaînée pour qu'elle soit également 12. C'est donc assez similaire à ce que nous faisions avec les listes chaînées simples, à l'exception de l'étape supplémentaire de connecter l'ancienne tête de la liste à la nouvelle tête de la liste chaînée. 

Maintenant, supposons que nous ayons une autre fonction qui