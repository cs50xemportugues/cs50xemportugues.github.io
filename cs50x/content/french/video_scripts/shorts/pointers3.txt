Alors, qu'est-ce qu'un pointeur? Un pointeur est un élément de données dont la valeur est une adresse mémoire. C'était cette "zero x eight zero" qui se produisait; c'était une adresse mémoire. C'était un emplacement dans la mémoire. Et le type d'un pointeur décrit le type de données que vous trouverez à cette adresse mémoire. Donc, il y a la partie "int étoile" là. Si je suis cette flèche, cela va me mener à un emplacement où je trouverai une boîte verte dans mon exemple. C'est un entier, c'est ce que je trouverai si je vais à cette adresse. Le type de données d'un pointeur décrit ce que vous trouverez à cette adresse mémoire. Alors voici la chose vraiment cool. Les pointeurs nous permettent de passer des variables entre les fonctions. Et en fait, de passer des variables et non des copies d'elles. Parce que si nous savons exactement où trouver une variable en mémoire, nous n'avons pas besoin d'en faire une copie, nous pouvons simplement aller à cet emplacement et travailler avec cette variable. En substance, les pointeurs rendent l'environnement informatique beaucoup plus proche du monde réel.

Alors voici une analogie. Disons que j'ai un carnet, et qu'il est rempli de notes. Et j'aimerais que vous le mettiez à jour. Vous êtes une fonction qui met à jour des notes. De la manière dont nous avons travaillé jusqu'à présent, vous allez prendre mon carnet, aller au magasin de photocopie, faire une copie Xerox de chaque page du carnet. Vous remettrez mon carnet sur mon bureau lorsque vous avez fini, vous allez barrer les choses dans mon carnet qui sont dépassées ou fausses, et ensuite vous me passerez la pile de pages Xerox qui est une réplique de mon carnet avec les modifications que vous avez apportées. Et à ce stade, c'est à moi en tant que fonction appelante de décider de prendre vos notes et de les intégrer à nouveau dans mon carnet. Il y a donc beaucoup d'étapes impliquées ici. Ne serait-il pas mieux si je disais juste: "Hé, pouvez-vous mettre à jour mon carnet pour moi?" Vous me donnez mon carnet, et vous prenez des choses et vous les croisez littéralement et mettez à jour mes notes dans mon carnet. Et ensuite vous me redonnez mon carnet. C'est un peu ce que les pointeurs nous permettent de faire. Ils rendent cet environnement beaucoup plus proche de la réalité.

D'accord, donc c'est ce qu'est un pointeur, parlons de la façon dont les pointeurs fonctionnent en C, et comment nous pouvons commencer à travailler avec eux. Il existe un pointeur très simple en C appelé pointeur nul. Le pointeur nul ne pointe sur rien. Cela semble probablement être en fait quelque chose qui n'est pas très utile, mais comme nous le verrons un peu plus tard, le fait que ce pointeur nul existe peut réellement être très utile. Et chaque fois que vous créez un pointeur, et que vous ne définissez pas sa valeur immédiatement- un exemple de réglage de sa valeur immédiatement sera un couple de diapositives en arrière où j'ai dit pk égale & k, pk obtient l'adresse de k, comme nous le verrons ci-dessous, nous verrons comment coder cela sous peu- si nous ne définissons pas sa valeur à quelque chose de significatif immédiatement, vous devriez toujours définir votre pointeur pour qu'il pointe sur null. Vous devriez le définir pour qu'il ne pointe sur rien.

C'est très différent de simplement laisser la valeur telle quelle et ensuite déclarer un pointeur et supposer simplement qu'il est null car c'est rarement vrai. Vous devriez toujours définir la valeur d'un pointeur sur null si vous ne définissez pas sa valeur sur quelque chose de significatif immédiatement. Vous pouvez vérifier si la valeur d'un pointeur est null en utilisant l'opérateur d'égalité (==), tout comme vous comparez n'importe quelle valeur entière ou caractère en utilisant (==) également. C'est une sorte de valeur constante spéciale que vous pouvez utiliser pour tester. Donc, c'était un pointeur très simple, le pointeur nul. Une autre façon de créer un pointeur est d'extraire l'adresse d'une variable que vous avez déjà créée, et vous le faites en utilisant l'opérateur & d'extraction d'adresse, que nous avons déjà vu dans le premier exemple de diagramme que j'ai montré. Donc, si x est une variable que nous avons déjà créée de type entier, alors &x est un pointeur vers un entier. &x- rappelons-nous, & va extraire l'adresse de la chose à droite. Et puisqu'un pointeur n'est qu'une adresse, &x est un pointeur vers un entier dont la valeur est l'endroit où x vit en mémoire. C'est l'adresse de x. Prenons cela un peu plus loin et connectons-le à quelque chose à quoi j'ai fait allusion dans une vidéo précédente. Si arr est un tableau de doubles, alors &arr crochet i est un pointeur vers un double. OK. arr crochet i, si arr est un tableau de doubles, alors arr crochet i est le i-ème élément de ce tableau, et &arr crochet i est où se trouve en mémoire le i-ème élément de arr.

Alors, quelle est l'implication ici? L'implication de tout cela est que le nom d'un tableau est en réalité lui-même un pointeur. Vous avez travaillé avec des pointeurs tout le temps à chaque fois que vous avez utilisé un tableau. Souvenez-vous de l'exemple sur la portée des variables, vers la fin de la vidéo, je présente un exemple où nous avons une fonction appelée "set int" et une fonction appelée "set array". Et votre défi est de déterminer si les valeurs que nous avons imprimées à la fin de la fonction, à la fin du programme principal, sont correctes ou non. 

Si vous vous souvenez de cet exemple ou si vous avez regardé la vidéo, vous savez que lorsque vous appelez "set int", cela ne fait effectivement rien. Mais l'appel à "set array" le fait. Et j'ai un peu passé sous silence pourquoi c'était le cas à l'époque. J'ai juste dit, eh bien c'est un tableau, c'est spécial, vous savez, il y a une raison. La raison en est que le nom d'un tableau n'est en réalité qu'un pointeur, et il y a cette syntaxe spéciale de crochets qui rend les choses beaucoup plus agréables à travailler. Et ils rendent l'idée d'un pointeur beaucoup moins intimidante, et c'est pourquoi ils sont présentés de cette manière. Mais les tableaux ne sont vraiment que des pointeurs. Et c'est pourquoi lorsque nous avons apporté une modification au tableau, lorsque nous avons passé un tableau en tant que paramètre à une fonction ou en tant qu'argument à une fonction, le contenu du tableau a en fait changé à la fois dans l'appelant et dans le destinataire. Ce qui n'était pas le cas pour tout autre type de variable que nous avons vu. Donc, c'est juste quelque chose à garder à l'esprit lorsque vous travaillez avec des pointeurs, le nom d'un tableau est en réalité un pointeur vers le premier élément de ce tableau.

D'accord, maintenant que nous avons tous ces faits, continuons, d'accord. Pourquoi nous soucions-nous de l'endroit où quelque chose vit? Eh bien, comme je l'ai dit, il est assez utile de savoir où quelque chose vit pour pouvoir y aller et le changer. Travailler avec lui et avoir réellement l'effet que vous voulez sur cette variable, et pas avoir cet effet sur une copie de celle-ci. Cela s'appelle la déréférenciation. Nous allons à la référence et nous changeons la valeur là-bas. Donc, si nous avons un pointeur appelé pc et qu'il pointe vers un caractère, alors nous pouvons dire *pc et *pc est le nom de ce que nous trouverons si nous allons à l'adresse pc. Ce que nous trouverons là-bas est un caractère et *pc est la façon dont nous référons aux données à cet emplacement. Nous pourrions donc dire quelque chose comme *pc=D ou quelque chose comme ça, et cela signifie que ce qui était précédemment à l'adresse mémoire pc, quel que soit le caractère qui était là avant, est maintenant D, si nous disons *pc=D. 

Donc nous revoilà avec cette chose bizarre en C, non? Nous avons vu * précédemment comme faisant partie du type de données, et maintenant elle est utilisée dans un contexte légèrement différent pour accéder aux données à un emplacement. Je sais que c'est un peu déroutant et que c'est en fait une partie de toute cette mythologie autour des pointeurs qui les rendent si complexes, c'est un problème de syntaxe, honnêtement. Mais * est utilisé dans les deux contextes, à la fois comme partie du nom de type, et nous verrons un peu plus tard quelque chose d'autre aussi. Et pour l'instant, c'est l'opérateur de déréférencement. Donc, il va à la référence, il accède