Si vous avez vu notre vidéo sur la récursivité, le processus peut sembler un peu magique. Comment une fonction sait-elle qu'elle doit attendre une autre fonction et passer ses données à quelque chose d'autre qui s'exécute en même temps ? Cela peut sembler un peu magique au départ si vous ne comprenez pas exactement comment les fonctions sont appelées et fonctionnent en C. Et la façon dont elles fonctionnent est en utilisant quelque chose appelé la pile d'appels. Et la façon dont la pile d'appels fonctionne est la suivante. Si vous appelez une fonction, fondamentalement ce qui se passe c'est qu'un gros morceau de mémoire est réservé quelque part dans le système pour que cette fonction exécute son travail. Donc par exemple, si vous appelez une fonction et que la première chose que vous faites est de déclarer quelques variables, ce qui va se produire, c'est un cadre de pile ou un cadre de fonction, sera créé, un gros morceau de mémoire, et ces variables se verront attribuer un espace. Donc si c'est trois entiers, vous obtiendrez trois blocs de quatre octets, tout comme la taille d'un entier, ainsi que de l'espace pour effectuer des calculs et tout ce dont la fonction pourrait avoir besoin. Et c'est là que la fonction fera tout son travail. Maintenant, il est possible que plusieurs cadres de fonctions puissent exister dans la mémoire à un moment donné. Alors par exemple, disons que la fonction principale appelle une autre fonction appelée déplacement. Et puis la fonction de déplacement appelle une autre fonction appelée direction. À ce stade, ces trois fonctions ont des cadres ouverts. Mais en général, une seule de ces cadres ne sera jamais active. Seule une de ces fonctions fonctionne à un moment donné, même si les trois ont de l'espace réservé et attendent de faire quelque chose. Maintenant, la façon dont ces cadres sont disposés, c'est dans ce qu'on appelle une pile. Et le cadre pour la fonction récemment appelée est toujours celui en haut de la pile, et cela s'appelle le cadre actif. Donc encore une fois, si la fonction principale appelle déplacement et que déplacement appelle direction, vous pouvez voir cela comme une pile où la fonction principale est en bas, le déplacement est au-dessus de celle-ci, la direction est au sommet et la direction est le cadre actif. C'est la seule fonction qui fait quelque chose pour le moment, alors que le déplacement et la fonction principale attendent de devenir le cadre actif. Ils attendent de devenir le cadre qui est en haut de la pile. Lorsque vous appelez une nouvelle fonction, un nouveau cadre est ce qu'on appelle poussé sur le dessus de la pile. Donc si vous appelez une nouvelle fonction, cette fonction obtient immédiatement de l'espace et de la mémoire et est mise au sommet de la pile d'appels. Et elle devient le cadre actif. Et quoi que ce soit qui était le cadre actif, s'il y en avait un, est en pause. Il est juste assis là. C'est une mise en attente, en attente de devenir le cadre actif à nouveau. Lorsqu'une fonction termine son travail, par exemple en retournant, le plus souvent, ou peut-être en atteignant la fin de la ligne s'il s'agit d'une fonction de type void, elle n'a pas de valeur de retour, ce cadre est ce qu'on appelle retiré de la pile. Puisque ce cadre est maintenant parti, le cadre qui était en deuxième position, devient le cadre actif. Il reprend là où il s'était arrêté. Si vous appuyez sur pause sur cette fonction, elle reprendra immédiatement là où elle s'était arrêtée. C'est en fait pourquoi la récursivité fonctionne parce que tous ces cadres s'exécutent, mais un seul d'entre eux se déplace à un moment donné. Les autres s'exécutent tous, mais ils sont en pause. Ils attendent juste de devenir le nouveau sommet de la pile. Si nous appelons une autre fonction, le cadre actif est à nouveau en pause. La fonction qui vient d'être appelée est mise au sommet, et ainsi de suite jusqu'à ce que tous les cadres de fonctions soient terminés. Regardons une visualisation de cela, un exemple en utilisant la fonction factorielle pour voir si nous pouvons aider à rendre cela un peu plus clair, ceci est l'intégralité d'un fichier factoriel, par exemple. Et à l'intérieur de ce fichier factoriel, j'ai deux fonctions, fact qui va être une implémentation récursive de factoriel, et main qui appelle simplement ou imprime la valeur de factoriel, dans ce cas de 5. Nous commençons au début de main. Et la première chose que main fait, c'est qu'elle appelle une autre fonction. Elle appelle printf(). Dès qu'elle le fait, main est en pause. Elle est ici et elle attend que printf() fasse son travail. Que doit faire printf() ? Elle doit simplement imprimer un nombre, mais elle doit imprimer factoriel de 5 ou elle ne connaît pas factoriel de 5. Elle doit faire un appel de fonction. Donc printf() va ensuite être en pause et attend que factoriel de 5 devienne le nouveau cadre actif. Ainsi, dans le cadre de la factorielle de 5, que se passe-t-il ? Nous passons la valeur 5 à la fonction fact. Ensuite, il va vérifier si n est égal à 1. Non. Donc ensuite, il va retourner n fois fact n moins 1. OK, donc maintenant le cadre factoriel 5 appelle essentiellement une nouvelle fonction, passant un autre appel à factoriel, passant 4 comme paramètre à la place. Donc le cadre de la factorielle de 5 est maintenant en pause et un cadre pour la factorielle de 4 devient le nouveau cadre actif. Et ça va traverser le même processus. Est-ce que 4 est égal à 1 ? Non. Donc au lieu de cela, il va retourner n fois, dans ce cas, ou quatre fois la factorielle de 3, un autre appel de fonction. Le cadre de la factorielle de 4 est en pause. Le cadre de la factorielle de 3 devient le nouveau cadre actif. Et répétez ce processus pour la factorielle de 3, pour la factorielle de 2, et ensuite on arrive à la factorielle de 1. Donc dès le début, lorsque la factorielle de 1 est appelée, il y a sept cadres de fonctions dans la pile d'appels. Les cadres factoriels 2, 3, 4, 5, printf() et main sont en pause aux lignes que vous voyez là. Ils traînent juste là, attendant de devenir le nouveau cadre actif. Mais ils ne bougent pas de ces indicateurs fléchés. Ainsi, le cadre de la factorielle de 1 commence. Il pose la question, n est-il pas égal à 1 ? Eh bien, dans ce cas, la réponse est oui. Il va retourner 1. Maintenant, rappelez-vous ce qui se passe lorsqu'une fonction renvoie une valeur, ce cadre est terminé. Il disparaît. Et cela signifie qu'il est retiré de la pile d'appels et que le cadre qui se trouve en dessous de lui devient le nouveau cadre actif. La factorielle de 1 renvoie 1. À ce stade, son cadre est détruit et la factorielle de 2 peut maintenant être relancée. Maintenant, la factorielle de 2 est cette ligne bleu foncé sur la gauche là et elle attendait la valeur de renvoi de la factorielle de 1. Eh bien, la factorielle de 1 a dit, je vous ai renvoyé un 1. Alors la factorielle de 2 va renvoyer 2 fois 1 ou 2. Elle retourne également, et lorsque qu'elle renvoie, elle est retirée de la pile. Son cadre de fonction est détruit et la factorielle de 3 devient le nouveau cadre actif. La factorielle de 3 attendait la factorielle de 2, qui a renvoyé un 2. Elle va donc renvoyer 3 fois 2, ou 6, renvoyer la valeur. Son cadre de fonction est retiré de la pile. Il est détruit. La factorielle de 4 devient le nouveau cadre actif. La factorielle de 4 attendait la factorielle de 3. Elle a obtenu sa réponse de 6. Elle va donc renvoyer 4 fois 6, ou 24. Et elle va renvoyer cette valeur à la factorielle de 5, qui attendait que la factorielle de 4 finisse son travail. Elle renvoie 5 fois 24, qui est 120. Lorsque ce cadre est détruit, nous reprenons maintenant à printf(). printf() a cette ligne rouge foncé en bas. Elle attendait la factorielle de 5, qui vient de renvoyer un 120. Donc ce que printf() fait, c'est qu'elle imprime 120 et ensuite son travail est terminé. Elle n'a rien d'autre à faire. Elle n'attend pas un autre appel de fonction et donc elle termine l'exécution. Elle ne renvoie rien, mais elle n'a rien d'autre à faire. Son cadre de fonction est détruit. Il est retiré de la pile. Et ensuite,