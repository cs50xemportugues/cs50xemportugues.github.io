Pointeurs, nous y voilà. C'est probablement le sujet le plus difficile dont nous parlerons dans CS50. Si vous avez déjà lu quelque chose sur les pointeurs, vous pourriez être un peu intimidé à l'idée de regarder cette vidéo. Il est vrai que les pointeurs vous permettent peut-être de faire des erreurs assez graves lors de la manipulation de variables et de données, et de faire planter votre programme. Mais ils sont en fait très utiles et nous permettent d'avoir une excellente façon de faire circuler des données entre les fonctions, que nous ne pourrions pas faire autrement.

Et donc, ce que nous voulons vraiment faire ici, c'est vous entraîner à avoir une bonne discipline de pointeur, afin que vous puissiez utiliser les pointeurs de manière efficace pour rendre vos programmes encore meilleurs. Comme je l'ai dit, les pointeurs nous donnent une manière différente de faire circuler des données entre les fonctions. Maintenant, si vous vous souvenez d'une vidéo précédente dans laquelle nous parlions de la portée des variables, j'ai mentionné que toutes les données que nous passons entre les fonctions en C sont passées par valeur. Et je n'ai peut-être pas utilisé ce terme, ce que je voulais dire, c'est que nous passons des copies de données. Lorsque nous passons une variable à une fonction, nous ne passons pas réellement la variable à la fonction, n'est-ce pas ? Nous passons une copie de ces données à la fonction. La fonction fait ce qu'elle doit faire et calcule une certaine valeur, et peut-être que nous utilisons cette valeur lorsqu'elle la renvoie.

Il y avait une exception à cette règle de passage par valeur, et nous reviendrons sur cette exception un peu plus tard dans cette vidéo. Si nous utilisons des pointeurs au lieu d'utiliser des variables ou des copies des variables, nous pouvons maintenant faire circuler les variables entre les fonctions d'une manière différente. Cela signifie que si nous apportons une modification dans une fonction, cette modification prendra effet dans une autre fonction. Encore une fois, c'est quelque chose que nous ne pouvions pas faire auparavant, et si vous avez déjà essayé d'échanger la valeur de deux variables dans une fonction, vous avez remarqué ce problème qui surgit, n'est-ce pas ?

Si nous voulons échanger X et Y, et que nous les passons à une fonction appelée swap, à l'intérieur de la fonction swap, les variables échangent effectivement leurs valeurs. L'une devient deux, deux devient un, mais nous ne changeons rien dans la fonction d'origine, dans l'appelant. Parce que nous ne pouvons pas, nous travaillons uniquement avec des copies d'elles. Avec les pointeurs, cependant, nous pouvons réellement passer X et Y à une fonction. Cette fonction peut faire quelque chose avec elles. Et les valeurs de ces variables peuvent réellement changer. C'est donc un changement assez important dans notre capacité à travailler avec les données.

Avant de nous plonger dans les pointeurs, je pense qu'il vaut la peine de prendre quelques minutes pour revenir aux bases ici. Et jeter un coup d'œil à la façon dont fonctionne la mémoire de l'ordinateur, car ces deux sujets vont être assez interdépendants. Comme vous le savez probablement, sur votre système informatique, vous avez un disque dur ou peut-être un disque à semi-conducteurs, un emplacement de stockage de fichiers. Il est généralement d'environ 250 gigaoctets à quelques téraoctets maintenant. Et c'est là que tous vos fichiers vivent ultimement, même lorsque votre ordinateur est éteint, vous pouvez le rallumer et vous retrouverez vos fichiers quand vous redémarrez votre système. Mais les disques, comme un disque dur, un HDD, ou un disque à semi-conducteurs, un SSD, ne sont que des espaces de stockage.

Nous ne pouvons pas réellement faire quoi que ce soit avec les données qui se trouvent sur le disque dur ou les disques à semi-conducteurs. Pour changer les données ou les déplacer, nous devons les déplacer dans la mémoire vive, la Random Access Memory ou RAM. Maintenant, la RAM, vous en avez beaucoup moins dans votre ordinateur. Vous pouvez avoir environ 512 mégaoctets si vous avez un vieil ordinateur, jusqu'à peut-être deux, quatre, huit, 16, peut-être même un peu plus de gigaoctets de RAM. Donc, c'est beaucoup plus petit, mais c'est là où toutes les données volatiles existent. C'est là que nous pouvons changer les choses. Mais lorsque nous éteignons notre ordinateur, toutes les données de la RAM sont détruites.

C'est pourquoi nous avons besoin du disque dur pour l'emplacement plus permanent, afin qu'il existe - ce serait vraiment mauvais si chaque fois que nous éteignions notre ordinateur, chaque fichier de notre système était effacé. Nous travaillons donc à l'intérieur de la RAM. Et chaque fois que nous parlons de mémoire, à peu près dans CS50, nous parlons de RAM, pas de disque dur.

Lorsque nous déplaçons des choses dans la mémoire, cela prend un certain espace. Tous les types de données avec lesquels nous avons travaillé prennent des quantités différentes d'espace dans la RAM. Donc, chaque fois que vous créez une variable entière, quatre octets de mémoire sont réservés dans la RAM pour que vous puissiez travailler avec cette variable entière. Vous pouvez déclarer l'entier, le changer, l'assigner à une valeur de 10 incrémentée de un, etc. Tout cela doit se passer dans la RAM, et vous obtenez quatre octets à travailler pour chaque entier que vous créez.

Chaque caractère que vous créez prend un octet. C'est juste la quantité d'espace nécessaire pour stocker un caractère. Chaque nombre réel ou flottant, prend quatre octets à moins qu'il ne s'agisse d'un nombre flottant à double précision, qui permet d'avoir plus de précision ou plus de chiffres après la décimale sans perdre de précision, qui prend huit octets de mémoire. Les entiers vraiment grands, appelés "long longs", prennent également huit octets de mémoire. Combien d'octets de mémoire les chaînes prennent-elles? Eh bien, mettons une épingle dans cette question pour l'instant, mais nous y reviendrons.