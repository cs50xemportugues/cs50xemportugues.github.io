Dans CS50, nous avons couvert de nombreuses structures de données différentes, non? Nous avons vu des tableaux, des listes chaînées, des tables de hachage, des essais, des piles et des files. Nous en apprendrons également un peu sur les arbres et les tas, mais tout cela ne fait que varier autour du même thème. Il y a vraiment ces quatre idées de base sur lesquelles tout peut se résumer: les tableaux, les listes chaînées, les tables de hachage et les essais. Et comme je l'ai dit, il existe des variations sur eux, mais cela résume pratiquement tout ce dont nous allons parler dans cette classe en termes de C. Mais comment toutes ces structures se mesurent-elles, non? Nous avons parlé des avantages et des inconvénients de chacune d'entre elles séparément sur des vidéos, mais il y a beaucoup de nombres qui sont jetés. Il y a beaucoup de pensées générales qui sont jetées. Essayons de les consolider en un seul endroit. Pesons les pour et les contre, et considérons quelle structure de données peut être la bonne structure de données pour votre situation particulière, peu importe le type de données que vous stockez. Vous n'avez pas toujours besoin d'utiliser l'insertion, la suppression et la recherche super rapides d'un essai si vous ne vous souciez pas vraiment de l'insertion et de la suppression. Si vous avez juste besoin d'un accès aléatoire rapide, peut-être qu'un tableau est meilleur. Donc, distillons cela. Parlons de chacun des quatre grands types de structures de données dont nous avons parlé, et voyons juste quand ils pourraient être bons, et quand ils pourraient ne pas être si bons. Commençons donc par les tableaux.

L'insertion, c'est assez mauvais. L'insertion à la fin d'un tableau est correcte, si nous construisons un tableau au fur et à mesure. Mais si nous devons insérer des éléments au milieu, pensez à l'insertion par tri, il y a beaucoup de décalages pour adapter un élément là-dedans. Et donc si nous allons insérer n'importe où, sauf à la fin d'un tableau, ce n'est probablement pas si génial.

De même, la suppression, sauf si nous supprimons à la fin d'un tableau, n'est probablement pas non plus si géniale si nous ne voulons pas laisser de trous vides, ce que nous ne voulons généralement pas. Nous voulons supprimer un élément, puis le faire correspondre à nouveau. Et donc la suppression d'éléments d'un tableau n'est pas non plus très bonne.

Cependant, la recherche est excellente. Nous avons un accès aléatoire, une recherche constante dans le temps. Nous disons simplement sept et nous allons à la septième relocation du tableau. Nous disons 20 et nous allons à la vingtième relocation du tableau. Nous n'avons pas à itérer à travers. C'est très bon.

Les tableaux sont également relativement faciles à trier. Chaque fois que nous avons parlé d'un algorithme de tri, tel que le tri par sélection, le tri par insertion, le tri à bulles, le tri fusion, nous avons toujours utilisé des tableaux pour le faire, car les tableaux sont assez faciles à trier, par rapport aux structures de données que nous avons vues jusqu'à présent.

Ils sont également relativement petits. Il n'y a pas beaucoup d'espace supplémentaire. Vous réservez exactement autant que vous avez besoin pour contenir vos données, et c'est à peu près tout. Ils sont donc assez petits et efficaces de cette manière. Mais un autre inconvénient est qu'ils ont une taille fixe. Nous devons déclarer exactement la taille que nous voulons que notre tableau soit, et nous n'avons qu'une seule chance. Nous ne pouvons pas le faire grandir et le faire rétrécir.

Si nous devons le faire grandir ou le faire rétrécir, nous devons déclarer un tout nouveau tableau, copier tous les éléments du premier tableau dans le deuxième tableau. Et si nous avons mal calculé cette fois, nous devons le refaire. Pas très cool. Donc, les tableaux ne nous donnent pas la flexibilité d'avoir un nombre variable d'éléments.

Avec une liste chaînée, l'insertion est assez facile. Nous venons de l'ajouter au début. La suppression est également assez facile. Nous devons trouver les éléments. Cela nécessite une recherche.

Mais une fois que vous avez trouvé l'élément que vous cherchez, tout ce que vous avez à faire est de changer un pointeur, éventuellement deux si vous avez une liste chaînée - une liste chaînée deux fois, plutôt - et ensuite vous pouvez simplement libérer le nœud. Vous n'avez pas à tout déplacer. Vous n'avez qu'à changer deux pointeurs, donc c'est assez rapide.

La recherche, en revanche, est mauvaise, non? Pour trouver un élément dans une liste chaînée, qu'elle soit à simple ou à double chaînage, nous devons effectuer une recherche linéaire. Nous devons commencer au début et nous déplacer jusqu'à la fin, ou commencer à la fin et nous déplacer vers le début. Nous n'avons plus d'accès aléatoire. Donc, si nous effectuons beaucoup de recherches, peut-être qu'une liste chaînée n'est pas aussi bonne pour nous.

Ils sont également très difficiles à trier, non? La seule façon de trier une liste chaînée est de la trier pendant que vous la construisez. Mais si vous la triez pendant que vous la construisez, vous ne faites plus d'insertions rapides. Vous ne faites pas que l'ajouter au début. Vous devez trouver le bon endroit pour le mettre, et ensuite votre insertion devient presque aussi mauvaise que l'insertion dans un tableau. Les listes chaînées ne sont donc pas très bonnes pour trier des données.

Ils sont également assez petits, en termes de taille. Les listes chaînées doubles sont légèrement plus grandes que les listes chaînées simples, qui sont légèrement plus grandes que les tableaux, mais ce n'est pas une énorme quantité d'espace gaspillé. Donc, si l'espace est à une prime, mais pas une prime vraiment intense, c'est peut-être la bonne voie à suivre.

Les tables de hachage. L'insertion dans une table de hachage est assez simple. C'est un processus en deux étapes. Tout d'abord, nous devons soumettre nos données à une fonction de hachage pour obtenir un code de hachage, puis nous insérons l'élément dans la table de hachage à cet emplacement de code de hachage.

La suppression, similaire à une liste chaînée, est facile une fois que vous avez trouvé l'élément. Vous devez le trouver d'abord, mais lorsque vous le supprimez, vous devez simplement échanger quelques pointeurs, si vous utilisez le chaînage séparé. Si vous utilisez la sonde, ou si vous n'utilisez pas de chaînage du tout dans votre table de hachage, la suppression est en fait très facile. Tout ce que vous avez à faire est de hacher les données, puis de vous rendre à cet emplacement. Et en supposant que vous n'ayez pas de collisions, vous serez capable de supprimer très rapidement.

Maintenant, la recherche est là où les choses deviennent un peu plus compliquées. En moyenne, c'est mieux que les listes chaînées. Si vous utilisez le chaînage, vous avez toujours une liste chaînée, ce qui signifie que vous avez toujours un effet de recherche de liste chaînée. Mais parce que vous prenez votre liste chaînée et que vous la divisez sur 100 ou 1 000 ou n éléments dans votre table de hachage, vous avez des listes chaînées qui sont toutes une fraction de la taille. Ils sont tous sensiblement plus petits. Vous avez des n listes chaîn