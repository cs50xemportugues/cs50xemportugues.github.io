Revenons maintenant à cette idée de la mémoire en tant que grande matrice de cellules de taille octet. C'est vraiment tout ce que c'est, une gigantesque matrice de cellules, tout comme n'importe quelle autre matrice que vous connaissez et voyez, sauf que chaque élément fait un octet de largeur. Et tout comme une matrice, chaque élément a une adresse. Chaque élément d'une matrice a un index, et nous pouvons utiliser cet index pour effectuer une recherche dite aléatoire sur la matrice. Nous ne devons pas commencer au début de la matrice, itérer sur chaque élément jusqu'à ce que nous trouvions ce que nous recherchons. Nous pouvons simplement dire, je veux atteindre le 15ème élément ou le 100ème élément. Et vous pouvez simplement passer ce numéro et obtenir la valeur que vous recherchez.

De même, chaque emplacement de la mémoire a une adresse. Ainsi, votre mémoire pourrait ressembler à ceci. Voici un tout petit morceau de mémoire, ce sont 20 octets de mémoire. Les 20 premiers octets car mes adresses en bas vont de 0 à 1, 2, 3, et ainsi de suite jusqu'à 19. Et lorsque je déclare des variables et que je commence à travailler avec elles, le système va me réserver de l'espace dans cette mémoire pour travailler avec mes variables. Je pourrais donc dire, char c égale H majuscule. Et qu'est-ce qui va se passer? Eh bien, le système va me réserver un octet. Dans ce cas, il a choisi l'octet numéro 4, l'octet à l'adresse 4, et il va y stocker la lettre H majuscule pour moi. Si je dis ensuite que int limite de vitesse égale à 65, il va me réserver quatre octets de mémoire. Et il va traiter ces quatre octets comme une seule unité parce que ce que nous manipulons ici est un entier. Et il va y stocker 65.

Maintenant, je vous mentirais presque déjà, non ? Parce que nous savons que les ordinateurs travaillent en binaire. Ils ne comprennent donc pas nécessairement ce qu'est une lettre H majuscule ou un 65, ils ne comprennent que le binaire, des zéros et des uns. Et donc, en réalité, ce que nous stockons là-dedans, ce ne sont pas la lettre H et le numéro 65, mais plutôt leurs représentations binaires, qui ressemblent un peu à ceci. Et en particulier, dans le contexte de la variable entière, cela ne va pas la traiter comme un seul bloc de quatre octets, il va effectivement la traiter comme quatre blocs d'un octet, qui pourraient ressembler à ceci. Et même cela n'est pas entièrement vrai non plus, en raison de quelque chose appelé endianness, que nous n'allons pas aborder maintenant, mais si vous êtes curieux, vous pouvez vous renseigner sur la taille d'octet à codage source variable. Mais pour les besoins de cet argument, pour les besoins de cette vidéo, supposons simplement que c'est en effet de cette façon que le nombre 65 serait représenté en mémoire sur chaque système, bien que ce ne soit pas tout à fait vrai.

Mais en fait, éliminons complètement le binaire et considérons juste H et 65, c'est beaucoup plus facile à comprendre pour un humain. Bon, il semble également peut-être un peu aléatoire que mon système ne m'ait pas donné les octets 5, 6, 7 et 8 pour stocker l'entier. Il y a une raison à cela aussi, que nous n'aborderons pas maintenant, mais il faut dire que ce que l'ordinateur fait ici est probablement une bonne chose de sa part. De ne pas me donner une mémoire qui est nécessairement dos à dos. Bien qu'il le fera maintenant si je veux obtenir une autre chaîne, appelée nom de famille, et que je veux y mettre Lloyd. Je vais avoir besoin de placer une lettre à chaque caractère et chaque lettre va nécessiter un caractère, un octet de mémoire. Donc si je pouvais mettre Lloyd dans mon tableau comme ça, je suis plutôt bon pour y aller, non ? Qu'est-ce qu'il manque ?

Rappelez-vous que chaque chaîne avec laquelle nous travaillons en C se termine par un backslash zéro, et nous ne pouvons pas omis cela ici non plus. Nous devons réserver un octet pour le contenir afin de savoir quand notre chaîne est terminée. Donc, encore une fois, cet arrangement de l'ordre dans lequel les choses apparaissent dans la mémoire peut être un peu aléatoire, mais c'est en fait ainsi que la plupart des systèmes sont conçus. Pour les aligner sur des multiples de quatre, pour des raisons que nous n'avons pas besoin d'aborder pour l'instant. Mais, donc, après ces trois lignes de code, voilà à quoi pourrait ressembler la mémoire. Si j'ai besoin des positions mémoire 4, 8 et 12 pour stocker mes données, voici ce que pourrait ressembler ma mémoire.

Et pour être particulièrement pointilleux ici, lorsqu'il s'agit d'adresses mémoire, nous le faisons généralement en utilisant des notations hexadécimales. Alors pourquoi ne pas convertir tout cela de la notation décimale à la notation hexadécimale juste parce que c'est généralement ainsi que nous nous référons à la mémoire. Au lieu d'être de 0 à 19, nous avons zéro x zéro à zéro x 1 trois. Ce sont les 20 octets de mémoire que nous avons ou que nous regardons dans cette image ci-dessus.

Tout cela étant dit, éloignons-nous un instant de la mémoire et revenons aux pointeurs. Voici la chose la plus importante à retenir lorsque nous commençons à travailler avec des pointeurs. Un pointeur n'est rien d'autre qu'une adresse. Je vais le dire à nouveau parce que c'est important, un pointeur n'est rien d'autre qu'une adresse. Les pointeurs sont des adresses vers des emplacements de mémoire où vivent les variables. Sachant cela, il devient évidemment un peu plus facile de travailler avec eux. Une autre chose que j'aime faire est d'avoir des diagrammes représentant visuellement ce qui se passe avec différentes lignes de code. Nous le ferons à plusieurs reprises en pointeurs et lorsque nous parlerons de l'allocation de mémoire dynamique également. Parce que je pense que ces diagrammes peuvent être particulièrement utiles.

Donc, si je dis par exemple, int k dans mon code, qu'est-ce qui se passe ? Eh bien, en gros, je me fais réserver de la mémoire, mais je n'aime même pas penser à cela, j'aime penser à cela comme une boîte. J'ai une boîte et elle est de couleur verte car je peux y mettre des nombres entiers dans les boîtes vertes. Si c'était un caractère, j'aurais une boîte bleue. Mais je dis toujours, si je crée une boîte qui peut contenir des entiers, alors cette boîte est de couleur verte. Et je prends un marqueur permanent et j'écris k sur le côté de la boîte. Donc, j'ai une boîte appelée k, dans laquelle je peux mettre des entiers. Donc, lorsque je dis int k, c'est ce qui se passe dans ma tête. Si je dis k égale 5, qu'est-ce que je fais ? Eh bien, je mets 5 dans la boîte, facile. C'est assez simple, si je dis int k, crée une boîte appelée k. Si je dis k égale 5, mets 5 dans la boîte. Espérons que ce n'est pas trop difficile à comprendre. 

Maintenant, voici où les choses deviennent un peu intéressantes. Si je dis int*p k, même si je ne sais pas nécessairement ce que cela signifie, il est clair que cela a quelque chose à voir avec un entier. Donc, je vais colorer cette boîte en vert, je sais que cela a quelque chose à voir avec un entier, mais ce n'est pas un entier lui-même. Parce que c'est une étoile int. Il y a quelque chose de légèrement différent à ce sujet. Un entier est impliqué, mais sinon ce n'est pas trop différent de ce dont nous parlions. C'est une boîte, elle a une étiquette, elle porte l'étiquette p k, et elle peut contenir des int étoiles, quoi que ce soit. Ils ont quelque chose à voir avec les entiers, évidemment. Voici cependant la dernière ligne. Si je dis pk=&k, qui, que se passe-t-il, non ? Ce nombre apparemment aléatoire est lancé dans la boîte là-bas. Tout ce que c'est, c'est que pk reçoit l'adresse de k. Donc, je colle là où vit k en mémoire, son adresse, l'adresse de ses octets. Tout ce que je fais c'est dire que je vais mettre cette valeur à l'intérieur de ma boîte appelée pk. Et parce que ces choses sont des pointeurs, et parce que regarder une chaîne comme zéro x huit zéro c sept quatre huit deux zéro n'est probablement pas très significatif. Lorsque nous visualisons généralement les pointeurs, nous le faisons