Que se passe-t-il si nous essayons de déréférencer un pointeur dont la valeur est nulle? Rappelons que le pointeur nul ne pointe sur rien. Donc, si vous essayez de déréférencer rien ou d'aller à une adresse nulle, que pensez-vous qu'il se passe? Si vous pensez que cela provoque une erreur de segmentation, vous avez raison. Si vous essayez de déréférencer un pointeur nul, vous subissez une erreur de segmentation. Mais attendez, ne vous ai-je pas dit que si vous n'alliez pas définir la valeur de votre pointeur sur quelque chose de significatif, vous devriez le définir sur null ? En fait, l'erreur de segmentation est une sorte de comportement souhaitable. 

Avez-vous déjà déclaré une variable sans lui attribuer une valeur immédiate ? Ainsi, vous dites simplement " int x ; " mais vous ne l'assignez à rien et plus tard, vous imprimez la valeur de x sans lui avoir attribué de valeur. Vous obtenez souvent zéro, mais parfois vous pouvez avoir un nombre aléatoire et vous n'avez aucune idée d'où il vient. Des choses similaires peuvent arriver avec les pointeurs. Lorsque vous déclarez un pointeur " int *pk ", par exemple, et que vous ne l'attribuez pas à une valeur, vous obtenez quatre octets de mémoire. N'importe lesquels, pourvu qu'ils aient une valeur significative. Il se peut qu'il y ait quelque chose qui était déjà là mais qui n'était plus nécessaire pour une autre fonction, donc vous obtenez simplement les données qui étaient là. 

Et si vous essayez de déréférencer une adresse sans qu'il n'y ait déjà des octets et des informations là-bas qui sont maintenant dans votre pointeur ? Si vous essayez de déréférencer ce pointeur, vous pourriez perturber une mémoire à laquelle vous n'aviez pas l'intention de toucher. En fait, vous pourriez faire quelque chose de vraiment dévastateur, comme casser un autre programme, une autre fonction ou faire quelque chose de malveillant que vous n'aviez pas du tout l'intention de faire. C'est pourquoi il est en réalité une bonne idée de définir vos pointeurs sur null si vous ne les définissez pas sur une valeur significative. C'est probablement mieux à la fin de la journée que votre programme se plante plutôt que de faire quelque chose qui perturbe un autre programme ou une autre fonction. Ce comportement est probablement encore moins idéal que juste planter. C'est pourquoi c'est en fait une bonne habitude de définir vos pointeurs sur null si vous ne les définissez pas sur une valeur significative immédiatement, une valeur que vous connaissez et que vous pouvez déréférencer en toute sécurité. 

Revenons maintenant et examinons la syntaxe générale de cette situation. Si je dis " int *p ; ", qu'est-ce que j'ai fait ? Ce que j'ai fait, c'est ceci. Je sais que la valeur de p est une adresse, car tous les pointeurs ne sont que des adresses. Je peux déréférencer p en utilisant l'opérateur "*". Dans ce contexte ici, en haut, rappelez-vous que "*" fait partie du type. Int * est un type de données. Mais je peux déréférencer p en utilisant l'opérateur "*" et si je le fais, si je vais à cette adresse, qu'y trouverai-je ? Je trouverai un entier. Ainsi, int* p, en substance, signifie que p est une adresse. Je peux déréférencer p et si je le fais, je trouverai un entier à cet emplacement de mémoire. 

D'accord, j'ai dit qu'il y avait une autre chose ennuyeuse avec les astérisques et voici où cette autre chose ennuyeuse avec les astérisques se trouve. Avez-vous déjà essayé de déclarer plusieurs variables du même type sur la même ligne de code ? Ainsi, pour une seconde, faites semblant que la ligne, le code que j'ai en vert n'est pas là et qu'il dit simplement " int x,y,z ; ". Cela créerait en fait trois variables entières pour vous, appelées x, y et z. C'est une façon de le faire sans avoir à diviser en trois lignes. 

C'est ici que les astérisques deviennent à nouveau ennuyeux car "*" fait en réalité partie du nom de type et du nom de variable. Et donc si je dis " int *px, py, pz ", ce que j'obtiens est un pointeur vers un entier appelé px et deux entiers, py et pz. Et ce n'est probablement pas ce que nous voulons, ce n'est pas bon. 

Ainsi, si je veux créer plusieurs pointeurs de même type sur la même ligne, avec des étoiles, ce dont j'ai réellement besoin est de dire " int *pa, *pb, *pc ". Maintenant, après avoir dit cela et maintenant que je vous dis cela, vous ne le ferez probablement jamais. Et c'est probablement une bonne chose honnêtement, car vous pourriez omettre involontairement une étoile, quelque chose comme ça. Il est probablement préférable de déclarer les pointeurs sur des lignes individuelles, mais c'est juste un autre de ces choses de syntaxe ennuyeuses avec les astérisques qui rendent les pointeurs si difficiles à travailler avec. Car c'est simplement ce désordre syntaxique que vous devez traverser. Avec la pratique, cela devient vraiment naturel. Je fais encore des erreurs même après avoir programmé pendant 10 ans, donc ne vous inquiétez pas si quelque chose vous arrive, c'est assez courant, et c'est en quelque sorte une faille de la syntaxe. 

D'accord, j'ai promis de revenir sur le concept de la taille d'une chaîne de caractères. Eh bien, si je vous dis qu'il n'y a pas de type de données appelé chaîne, on vous a menti depuis le début. En fait, j'ai mentionné cela dans l'une de nos premières vidéos sur les types de données, la chaîne était un type de données créé pour vous dans CS50.h. Vous devez inclure #include CS50.h pour l'utiliser. 

Eh bien, en réalité, la chaîne n'est qu'un alias pour quelque chose appelé char *, un pointeur sur un caractère. Les pointeurs, rappelons-le, ne sont que des adresses. Alors quelle est la taille en octets d'une chaîne ? Eh bien, c'est quatre ou huit. Et la raison pour laquelle je dis quatre ou huit, c'est parce que cela dépend en fait du système, si vous utilisez l'environnement CS50 ide, la taille de char * est de huit, c'est un système 64 bits. Chaque adresse en mémoire est longue de 64 bits. Si vous utilisez l'appliance CS50 ou une quelconque machine 32 bits, et que vous avez entendu le terme machine 32 bits, qu'est-ce qu'une machine 32 bits ? Eh bien, cela signifie simplement que chaque adresse en mémoire mesure 32 bits de long. Et donc 32 bits sont quatre octets. Ainsi, un char * fait quatre ou huit octets selon votre système. Et en réalité, les types de données, et un pointeur vers n'importe quel type de données, puisque tous les pointeurs ne sont que des adresses, font quatre ou huit octets. Revenons à ce diagramme et concluons cette vidéo par un petit exercice. Voici le diagramme où nous avons laissé la vidéo au début. Et donc ce qui se passe maintenant si je dis " * pk = 35 "? Que signifie lorsque je dis, * pk = 35 ? Prenez une seconde. pk, dans ce contexte, est l'opérateur de déréférencement. Donc, lorsque l'opérateur de déréférencement est utilisé, nous allons à l'adresse pointée par pk et nous changeons ce que nous trouvons. Ainsi, * pk = 35 fait en fait cela sur l'image. C'est essentiellement identique syntaxiquement à avoir dit k = 35. 

Encore un. Si je dis " int m ", je crée une nouvelle variable appelée " m ". Une nouvelle boîte, elle est verte car elle contiendra un entier, et elle est étiquetée m. Si je dis m=4, je mets un entier dans cette boîte. Si je dis " pk=&m ", comment ce diagramme change-t-il ? Pk=&m, vous souvenez-vous de ce que fait l'opérateur & ou de ce qu'il est appelé ? Souvenez-vous que & suivi d'un nom de variable est l'adresse d'un nom de variable. Donc, ce que nous disons, c'est que pk obtient l'adresse de m. Et donc, en fin de compte, ce qui se passe sur le diagramme, c'est que pk ne pointe plus sur k mais pointe sur m. 

Encore une fois, les pointeurs sont très difficiles à travailler avec et requièrent beaucoup de pratique, mais en raison de leur capacité à vous permettre de passer des données entre les fonctions et d'avoir ces modifications prendre effet, comprendre leur fonctionnement est vraiment important. C'est probablement le sujet le plus compliqué que nous abordons dans CS50, mais la valeur que vous tirez des pointeurs est bien supérieure aux complications qu'ils présentent à première vue. Donc, je vous souhaite bonne chance dans l'apprentissage des pointeurs. Je suis Doug Lloyd, ceci est CS50.