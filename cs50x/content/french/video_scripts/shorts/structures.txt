D'accord. Nous avons travaillé avec des entiers, nous avons travaille avec des caractères, des nombres à virgule flottante, des doubles, des chaînes de caractères et des booléens. Nous avons épuisé essentiellement tous les types disponibles jusqu'à présent. Mais maintenant, nous voulons aller plus loin. Comment faisons-nous ça ? Comment créons-nous différents types de données ? Nous pouvons le faire en utilisant des structures. Les structures nous permettent d'unifier des variables de types différents en une seule variable nouvelle à laquelle nous pouvons attribuer son propre nom de type. C'est une chose très puissante à faire, car nous pouvons maintenant regrouper des éléments de différents types de données ayant une connexion logique. Nous avons pu le faire avec des tableaux en quelque sorte, non ? Nous pouvons regrouper des variables du même type de données dans une grande unité de mémoire, un tableau.

Mais nous n'avons pas été en mesure de mélanger différents types de données ensemble. Nous ne pouvons pas, par exemple, associer un entier, un caractère et un double dans la même chose et appeler cela une seule unité. Mais avec les structures, ou fréquemment appelées structs, nous le pouvons effectivement. Une structure est une sorte de super-variable. C'est une variable qui contient d'autres variables à l'intérieur. Voici un exemple de structure très simple. Voici à quoi ressemblerait la syntaxe pour créer une structure pour une voiture. Maintenant, examinons la syntaxe ici. Struct, c'est le mot-clé qui indique que je crée un nouveau type de données ici. Plus précisément, le nom du type de données sera struct car, comme nous le verrons. Mais cela permet au compilateur de savoir que c'est un groupe de variables qui sera considéré comme faisant partie du même type. 

Cars, simplement le nom de la structure. Encore une fois, le type de données ici sera struct car, pas seulement car. Mais si vous avez plusieurs structs dans le même programme, vous devez faire la distinction entre struct et struct. A l'intérieur des accolades sont tous les soi-disant champs ou membres de la structure. Alors, quels sont certains des éléments inhérents à une voiture ? Eh bien, elle a généralement une année, un nom de modèle, une plaque d'immatriculation, un compteur kilométrique qui a généralement un certain nombre de miles et peut-être une taille de moteur. Et comme vous pouvez le voir, je mélange les entiers, les caractères et les doubles. Ils feront tous partie de ce nouveau type de données. 

Enfin, la dernière chose à faire, n'oubliez pas ce petit point-virgule à la fin. Après avoir fini de définir la structure, nous devons mettre un point-virgule à la fin. C'est une erreur syntaxique très courante, car avec une fonction, par exemple, vous auriez simplement des accolades ouvrantes et fermantes. Vous ne mettez pas de point-virgule à la fin de la définition d'une fonction. Cela ressemble à une définition de fonction, mais ce n'en est pas une, et le point-virgule est simplement un rappel que vous devez le mettre, sinon le compilateur ne saura pas quoi en faire. C'est une erreur très courante lorsque vous définissez des structures. 

D'accord. Nous définissons généralement nos structures tout en haut de nos programmes car elles seront probablement utilisées par plusieurs fonctions. Nous ne voulons pas définir une structure à l'intérieur d'une fonction, car alors la portée de la structure n'existe vraiment que à l'intérieur de cette fonction. Nous voudrions probablement définir une structure de sorte que nous puissions l'utiliser dans plusieurs fonctions, ou peut-être dans plusieurs fichiers qui sont liés ensemble pour créer notre programme unique. Parfois, au lieu de définir la structure tout en haut où vous mettez vos directives de préprocesseur tels que pound includes et pound defines, par exemple, vous pouvez les mettre dans des fichiers séparés .h, que vous incluez ensuite vous-même avec pound include. 

Nous avons donc des structures, mais maintenant nous devons entrer à l'intérieur. Comment entrons-nous dans une structure pour accéder à ces sous-variables, ces variables qui existent à l'intérieur de la structure ? Eh bien, nous avons quelque chose appelé l'opérateur point, qui nous permet d'accéder aux champs de la structure. Par exemple, disons que j'ai déclaré mon type de données de structure quelque part en haut de mon programme, ou peut-être dans un fichier .h que j'ai inclus. Si je veux ensuite créer une nouvelle variable de ce type de données, je peux dire struct car, my car, point-virgule. Tout comme je pourrais dire int x ou string name, point-virgule.

Le type de données ici est struct car, le nom de la variable est my car, et ensuite je peux utiliser l'opérateur point pour accéder aux différents champs de ma voiture. Je peux dire que my car dot year = 2011. C'est parfaitement correct. L'année, si vous vous souvenez, a été définie comme un champ entier à l'intérieur de ce type de données struct car. Donc, toute variable du type de données struct car, comme my car, je peux dire que my car dot year = et ensuite lui assigner une valeur entière, 2011, par exemple. My car dot plate égale à CS50. My car dot odometer égale à 50505 point-virgule. Tout cela est parfaitement correct, et c'est ainsi que nous accédons aux champs de la structure. 

Les structures n'ont pas besoin d'être créées sur la pile. Tout comme n'importe quelle autre variable, nous pouvons les allouer de manière dynamique. Si nous avons un programme qui peut générer de nombreuses structures, sans savoir combien nous en aurons besoin, alors nous devons allouer dynamiquement ces structures pendant que notre programme s'exécute. Et donc, si nous allons accéder aux champs d'une structure dans ce contexte, rappelons-nous que nous devons d'abord déréférencer le pointeur de la structure, et ensuite une fois que nous avons déréférencé le pointeur, nous pouvons ensuite accéder aux champs. Si nous n'avons qu'un pointeur vers la structure, nous ne pouvons pas simplement dire "pointeur dot nom du champ" et obtenir ce que nous cherchons. Il y a une étape supplémentaire de déréférencement. Donc, disons qu'au lieu de la précédente - tout comme la précédente - au lieu de la déclarer sur la pile, struct car, my car, point-virgule, je dis struct car, étoile, un pointeur vers un struct car appelé ma voiture, égale à malloc taille de struct car : taille de, nous déterminerons le nombre d'octets que votre nouveau type de données prend. Vous n'avez pas nécessairement besoin de n'utiliser que size of, avec int, char ou l'un des types de données intégrés. Le compilateur est assez intelligent pour déterminer le nombre d'octets requis par votre nouvelle structure. Donc, j'alloue dynamiquement une unité de mémoire suffisamment grande pour contenir une struct car, et je récupère un pointeur vers ce bloc de mémoire, et ce pointeur est affecté à ma voiture.

Maintenant, si je veux accéder aux champs de ma voiture, je déréférence d'abord ma voiture en utilisant l'opérateur de déréférence, star que nous avons vu dans les vidéos sur les pointeurs, et ensuite après avoir déréférencé ma voiture, je peux utiliser l'opérateur point pour accéder aux différents champs de ma voiture. Star my car dot year égale à 2011. Cela aurait l'effet que nous voulons dans ce cas, car nous avons alloué dynamiquement ma voiture.

C'est un peu ennuyeux, n'est-ce pas ? Il y a maintenant une étape en deux étapes. Maintenant, nous devons déréférencer - nous avons un opérateur étoile, et nous avons un opérateur de point. Et comme vous pouvez vous y attendre, parce que les programmeurs C adorent les moyens plus courts de faire les choses, il y a une manière plus courte de faire ceci. Il y a un autre opérateur appelé flèche, qui rend ce processus beaucoup plus facile. Le fonctionnement de la flèche est qu'elle déréférence d'abord le pointeur du côté gauche de l'opérateur, puis, après avoir déréférencé le pointeur du côté gauche, elle accède au champ du côté droit. Et donc, précédemment, nous avions cette sorte de star my car dot toutes ces choses, comme il y avait beaucoup de choses là-dedans. Mais ce que nous pouvons faire à la place, c'est ceci - ma voiture flèche année = 2011.

Encore une fois, qu'est-ce qui se passe ici ? Tout d'abord, je déréférence ma voiture. Qui, encore une fois, est un pointeur ici. Ensuite, après avoir déréférencé ma voiture, je peux ensuite accéder aux champs year, plate et odometer exactement comme je pouvais avant d'avoir d'abord utilisé l'étoile pour déréférencer ma voiture, et le point pour accéder au champ. Donc, vous pouvez avoir des structures, des pointeurs vers des structures, et vous avez des moyens d'accéder aux champs de ces structures, que vous ayez des pointeurs vers eux ou les variables elles-mêmes. Point ou flèche, selon la façon dont la variable a été déclarée.

Je suis Ramon Rodrigues. Ceci est CS50.