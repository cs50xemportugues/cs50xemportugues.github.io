Très bien, parlons des arguments en ligne de commande. Jusqu'à présent, dans le cours, pratiquement tous vos programmes ont probablement commencé comme ceci -- int main void. Nous avons collecté les entrées utilisateur dont nous avions besoin dans nos programmes, comme dans le programme Mario, par exemple, en utilisant des invites dans le programme. Nous n'avions pas besoin de modifier la déclaration de main, parce qu'à l'intérieur de main, nous disons simplement, vous pouvez l'appeler pour obtenir une entrée. De quelle taille voulez-vous la pyramide ? Ou vous pouvez l'appeler pour obtenir un flottant -- combien de monnaie dû-je rendre à l'utilisateur ?

Il y a cependant une autre façon, et si nous voulons que nos utilisateurs puissent fournir des données à notre programme au moment de son exécution plutôt que pendant que le programme s'exécute, une distinction subtile mais parfois très utile, nous avons besoin d'une nouvelle forme de déclaration de main. Nous ne pouvons pas utiliser int main void si nous voulons collecter d'autres données en ligne de commande lorsque l'utilisateur exécute le programme, d'où les arguments en ligne de commande.

Pour collecter ces arguments en ligne de commande de l'utilisateur, modifiez votre déclaration de main pour ressembler à cela -- int main, ouvrir la parenthèse, int argc, virgule, string argv, crochets carrés, puis ouvrir une accolade. Qu'est-ce que cela signifie déjà ? Eh bien, nous passons deux paramètres, ou arguments, ou entrées à main. L'un est un entier appelé argc, et l'autre est quoi ? C'est un tableau de chaînes, n'est-ce pas ? Nous voyons cette notation entre crochets carrés. C'est un tableau de chaînes. Ce n'est pas une chaîne individuelle, c'est un tableau de chaînes. Et ces deux arguments, argc et argv, vous permettent de savoir quelles données l'utilisateur a fournies en ligne de commande et combien d'entre elles ont été fournies en ligne de commande. Des choses assez utiles pour travailler avec.

Argc signifie compteur d'arguments, et vous devez savoir, d'ailleurs, que vous pourriez appeler argc comme vous le voulez. Vous pourriez appeler argv comme vous le vouliez. Ce ne sont que des noms conventionnels que nous utilisons pour eux -- compteur d'arguments, et comme nous le verrons dans un instant, vecteur d'arguments, argv. Mais vous n'êtes pas obligé de les appeler argc et argv si vous ne le voulez pas, mais de manière conventionnelle, c'est ce que nous faisons.

Alors argc, le compteur d'arguments. C'est une variable de type entier et donc, comme vous pourriez vous y attendre, si nous avons deux choses dont nous allons découvrir le type et combien de choses l'utilisateur a tapées, argc va nous dire combien de choses l'utilisateur a tapées. Donc cela vous donne un nombre d'arguments en ligne de commande que l'utilisateur a tapés lors de l'exécution du programme. Ainsi, si votre programme est exécuté avec dot slash greedy, et que dans votre fonction main de votre programme greedy vous avez la déclaration int main int argc, string argv crochets carrés, alors argc dans ce cas est égal à un. Remarquez maintenant que nous ne comptons pas combien de choses l'utilisateur a tapées après le nom du programme. Le nom du programme lui-même compte comme un argument en ligne de commande.

Ainsi, avec dot slash greedy, dans ce cas, argc est égal à un. Si l'utilisateur a tapé slash greedy 1024 CS50 en ligne de commande, argc dans ce cas serait égal à trois. Et nous le savons parce que la façon dont la division entre les chaînes est détectée est s'il y a un espace, ou une tabulation, ou quelque chose comme ça entre elles. Ainsi, toute quantité d'espace blanc, ainsi appelé, entre les valeurs tapées en ligne de commande indique combien il y en a. Ainsi, avec dot slash greedy espace 1024 espace CS50, argc, dans ce cas, est égal à trois.

Argv est le vecteur d'arguments. Vecteur, d'ailleurs, est juste un autre mot pour un tableau, et c'est un tableau qui stocke des chaînes. Une chaîne par élément, qui sont les chaînes que l'utilisateur a effectivement tapées en ligne de commande lorsque le programme a été exécuté. Maintenant, comme c'est le cas avec n'importe quel tableau, si vous vous souvenez de notre discussion sur les tableaux, le premier élément de argv sera toujours trouvé à argv crochets carrés zéro. C'est le premier index du tableau argv. Ainsi, et en fait, cela sera toujours le nom du programme, qui sera toujours situé à argv crochets carrés zéro.

Le dernier élément de argv se trouve toujours à argv crochets carrés argc moins un. Vous voyez pourquoi ? Souvenez-vous du nombre d'éléments qui existent dans ce tableau. Eh bien, nous savons que c'est argc éléments. Si l'utilisateur a tapé trois choses en ligne de commande, argc est égal à trois. Mais parce qu'en C, lorsque nous travaillons avec des tableaux, chaque élément du tableau, ou plutôt les indices du tableau, commencent à zéro. Si nous avons trois éléments dans notre tableau, nous avons un élément à argv zéro, un élément à argv un et un élément à argv deux. Il n'y a pas d'élément à argv trois, et un tableau de taille trois. C'est pourquoi le dernier élément de argv peut toujours être trouvé à argv crochets carrés argc moins un.

Supposons donc que l'utilisateur exécute le programme greedy comme suit -- s'il tape en ligne de commande dot slash greedy espace 1024 espace CS50, et pour une raison quelconque, nous avons déjà préparé notre programme greedy pour connaître et travailler avec ces arguments en ligne de commande. Nous ne l'avions pas fait précédemment lorsque nous avons travaillé sur le problème de codage greedy, mais disons que nous l'avons maintenant modifié de manière à traiter les arguments en ligne de commande d'une certaine manière. Dans ce cas, argv zéro est dot slash greedy. Qu'est-ce que argv un ? Eh bien, c'est 1024, n'est-ce pas ? C'est 1024, mais voici une distinction vraiment importante -- vous souvenez-vous du type de données de argv ?

Il stocke des chaînes, n'est-ce pas ? Mais il semble que 1024 soit une valeur entière. C'est une distinction vraiment importante, et c'est en fait quelque chose que vous pourriez rencontrer dans les problèmes ultérieurs. Tout ce qui est dans argv est stocké sous forme de chaîne. Le contenu de argv un est donc la chaîne un, zéro, deux, quatre, composée de ces quatre caractères. C'est comme si l'utilisateur avait tapé un, zéro, deux, quatre comme des lettres ou des caractères individuels. Ce n'est pas l'entier 1024, et donc vous ne pouvez pas travailler directement avec lui en disant int 1 000, ou plutôt int x égal à argv un moins 24.

Intuitivement, vous pourriez penser que c'est bon, c'est 1024 moins 24, donc x est égal à 1000. Mais en fait, ce n'est pas le cas, parce que argv un est une chaîne. La chaîne 1024. Maintenant, il existe une fonction qui peut être utilisée pour convertir les chaînes en entiers. Je ne vais pas vous la gâcher maintenant, mais je suis sûr que Zamyla sera heureuse de vous en parler dans la visite guidée d'un futur problème. Mais vous pouvez également trouver des fonctions qui font cela dans la référence 50, si vous allez dans le guide de référence, vous pouvez trouver une fonction qui fera cette conversion pour vous. Mais encore une fois, dans la visite guidée d'un problème futur, Zamyla sera heureuse de vous dire quelle fonction convertira la chaîne 1024 en l'entier 1024.

Très bien, continuons. Nous avons couvert notre argv zéro, nous avons couvert notre argv un. Qu'y a-t-il dans argv deux ? CS50. Celui-là est probablement assez explicite. Qu'y a-t-il dans argv trois ? Eh bien, encore une fois, nous ne le savons pas vraiment, n'est-ce pas ? Nous avons un tableau de taille trois, c'est le nombre d'éléments que l'utilisateur a tapés en ligne de commande, donc si nous allons à argv trois, nous dépassons maintenant les limites de notre tableau. Le compilateur nous permettra de le faire, il n'y a pas de problème intuitif avec cela, mais en termes de ce qui va se passer réellement, nous ne le savons pas vraiment. Cela dépend de ce qui est situé dans la mémoire où argv trois devrait être attendu. Et donc nous pourrions nous en sortir indemnes. Plus probablement, en particulier lorsque vous travaillez avec argv par opposition à tout autre tableau qui se trouve dans notre programme, nous allons probablement subir une violation de segmentation. Encore une fois, assurez-vous de ne pas dépasser les limites de vos tableaux, en particulier argv, étant donné son importance élevée dans vos programmes.

Je suis Doug Lloyd. C'est CS50.