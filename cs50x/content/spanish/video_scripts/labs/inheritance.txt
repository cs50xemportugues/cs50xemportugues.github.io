En este laboratorio, tu tarea será escribir un programa en C que simule la herencia de genes de tipo sanguíneo dentro de una familia. Para dar un poco de antecedentes científicos, el tipo de sangre se determina por alelos, que son diferentes versiones de un gen. Y hay tres alelos diferentes con respecto al tipo de sangre, llamados A, B y O.

Cada persona tiene dos de estos alelos. Puedes tener dos A, dos B, dos O o mezclarlos, tener un A y un B, o un B y un O, o un A y un O, por ejemplo.

Y cuando un padre tiene un hijo, cada padre transmite uno de sus alelos a su hijo. Por ejemplo, si imaginamos a dos padres, uno con un tipo de sangre AB y otro con tipo de sangre OO, entonces su hijo heredará un tipo sanguíneo de cada uno de sus padres. Podríamos elegir al azar A de un padre y O del otro, y llegar a un tipo sanguíneo de AO. Pero también podríamos haber obtenido el tipo sanguíneo BO, por ejemplo. Cuál de los dos alelos se transmite es simplemente elegido al azar.

Para simular este tipo de herencia dentro de nuestro programa, necesitamos algún tipo de estructura de datos que nos permita representar la conexión entre las personas y sus padres, así como los alelos que tienen para su tipo sanguíneo. Debido a que no hay un tipo incorporado en C para hacer exactamente eso, podemos crear nuestro propio tipo usando un typedef. Entonces, aquí tenemos typedef struct persona, donde cada persona será representada por estos dos campos.

Struct persona star *padres [2] significa que cada persona tendrá una matriz de 2 padres, donde cada uno de esos padres será un puntero a otra persona. Mientras tanto, cada persona también tendrá una matriz de dos caracteres llamados alelos, que representan los dos alelos A, B u O que tiene esa persona en particular. Y porque cada persona tiene dos alelos, esto será una matriz de tamaño 2 para representar ambos alelos.

Entonces, en el ejemplo que vimos antes, podríamos, para este niño en particular, haber almacenado la letra A en los alelos 0 del niño y 0 almacenado en los alelos 1. Y mientras tanto, padres [0] señalaría a uno de los padres y padres [1] señalaría al otro padre. Veamos ahora cómo estas piezas se unirían dentro del código de distribución que te damos para el laboratorio.

Hay una buena cantidad de código de distribución que ya te damos dentro de inheritance.c. Pero intentemos destilar lo que es más importante. Aquí notaremos ese mismo typedef, que definimos a una persona como teniendo punteros a dos padres en esta matriz de 2 punteros y también teniendo una matriz de dos caracteres, que representa los dos alelos que esta persona tiene para su tipo de sangre.

A continuación, está esta variable relevante llamada const int GENERATIONS, un entero constante, que se establece igual al número de 3. Y esto va a representar el número de generaciones de datos que vamos a simular generando. En este caso, simplemente esperamos tres generaciones de datos de tipos de sangre, lo que significa que no solo vamos a simular al hijo único, sino también a la generación 2, sus padres, y también la generación 3, los abuelos de ese niño. Luego tenemos algunos prototipos de funciones, pero saltaremos a la función principal para realmente ver lo que hace este programa.

La función principal ya está escrita para ti. No hay nada que necesites hacer aquí. Pero comenzamos sembrando el generador de números aleatorios, solo para que podamos generar números seudoaleatorios, lo que será útil. Debido a que cuando decidimos cómo se heredan los genes, queremos poder elegir al azar qué gen va a ser transmitido de padre a hijo.

A continuación, llamamos a la función create_family para crear una familia con un número especificado de generaciones, devolviendo un puntero a la generación de persona más reciente en esa familia. Entonces, si creamos una familia con tres generaciones, terminaremos con un puntero a una persona. Pero usando sus punteros a los padres, también podríamos acceder a los padres de ese hijo y a los abuelos de ese hijo, pero no más si solo estamos mirando una familia con tres generaciones.

La función create_family será tu tarea para escribir. Pero la función print_family la escribiremos por ti. Después de haber creado una familia, ya hemos escrito para ti una función que tomará esa familia y la imprimirá como un árbol genealógico jerárquico, imprimiendo qué tipo de sangre tiene cada una de las personas en esa familia.

Finalmente, escribirás la función free_family, que liberará toda la memoria que hayas podido asignar en el proceso de crear esta familia. Debido a que, recuerda que, para cada una de las personas que deseas representar dentro de la memoria de tu computadora, es probable que debas asignar memoria para ellas utilizando la función malloc para asignar memoria de manera dinámica. Pero cada vez que asignes memoria con malloc, también querrás liberar esa memoria, devolviéndola a la computadora para que pueda ser utilizada para otros fines.

Entonces, en la función create_family, esto será lo que implementarás, asignando memoria para una nueva persona y luego ocupándote de dos casos posibles. Uno, si hay posibles padres que este niño tiene que generar recursivamente, o bien, si solo estamos generando una sola generación, generando solo una persona sin datos de los padres.

También escribirás la función free_family, que toma como entrada un puntero a una persona p. Y la tarea de esta función es liberar p y cualquier ancestro de p. Entonces, si la persona p tiene padres o abuelos u otros ancestros, asegurándote de liberarlos también.

La función print_family la escribimos por ti. No necesitas hacer nada aquí. Toma a una persona y luego imprime todo su árbol genealógico, junto con sus tipos de sangre. Y esta función random_allele que escribimos puede ser útil también. Elije aleatoriamente un alelo, A, B u O, lo que puede ser útil si llegamos a un punto en el que necesitamos generar alelos al azar para almacenar dentro de la matriz de alelos.

Así que con ese código de distribución en mente, entonces, recorramos lo que tu programa va a hacer. Lo primero que debes hacer es completar la función create_family para crear una familia con un número específico de generaciones. Para hacerlo, lo primero que debes hacer es asignar memoria para una nueva persona, llamando a malloc, pasando el tamaño de persona para asegurarte de tener suficiente memoria para una nueva persona. Luego usarás esa persona para generar recursivamente ancestros si hay más generaciones con las que necesitas trabajar.

Entonces, si generations es mayor que 1, lo que significa que hay más generaciones que necesitas generar, entonces crearás recursivamente esas generaciones anteriores. ¿Qué significa crear recursivamente las generaciones anteriores? Bueno si intentas crear un niño que tiene dos generaciones de padres, entonces llamarás recursivamente la función create_family para cada uno de esos padres, donde cada uno de esos padres tendrá una generación de padres, y así sucesivamente.

Entonces, si generations es mayor que 1, querrás crear recursivamente esas generaciones anteriores. Y usando el valor de retorno que obtienes de esas funciones create_family, actualizarás los padres de esta nueva persona, estableciendo que los padres [0] son iguales al resultado de una llamada recursiva y estableciendo que los padres [1] son iguales al resultado de otra llamada recursiva. Después de establecer los padres de esa persona, recuerda que cada persona no solo tiene dos punteros a padres, sino también dos alelos.

Entonces, ahora necesitarás hacer el paso de herencia real, heredando un ale