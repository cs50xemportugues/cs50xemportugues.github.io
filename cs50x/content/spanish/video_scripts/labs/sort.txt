En este laboratorio, tu tarea es determinar qué algoritmo de ordenamiento utilizan varios programas diferentes. Hasta ahora, hemos sido presentados con tres algoritmos de ordenamiento diferentes: ordenamiento por selección, ordenamiento burbuja y ordenamiento por mezcla. Recordemos que en el ordenamiento por selección, el algoritmo funciona tomando una matriz de números y repitiendo el proceso de revisar toda la matriz de números para encontrar el elemento más pequeño en toda la matriz, y llevando ese elemento más pequeño al comienzo de la matriz. Luego, buscamos el siguiente elemento más pequeño en el resto de la matriz, lo llevamos de vuelta al principio de la matriz y repetimos el proceso, continuamente buscando en la porción no ordenada restante de la matriz, encontrando el elemento más pequeño e intercambiándolo con el elemento en la siguiente posición. Una vez que repetimos este proceso en toda la matriz, terminamos con una matriz ordenada.

Mientras tanto, el ordenamiento burbuja funciona un poco diferente. También realiza pasadas a través de la matriz, pero compara dos valores a la vez. Observa cada par de valores y trata de determinar si ese par de números está en el orden correcto. Es decir, si se está intentando ordenar de menor a mayor, lo que se busca es asegurarse de que para cualquier par de dos números, el número más pequeño esté a la izquierda del número más grande. Lo que hace el ordenamiento burbuja es que, si encuentra dos números que están fuera de orden, los intercambia. El ordenamiento burbuja continuará realizando este proceso de considerar pares de valores e intercambiarlos si es necesario, hasta llegar al final de la matriz.

Finalmente, el ordenamiento por mezcla funciona fundamentalmente de manera diferente. Funciona tomando una matriz y dividiéndola en una mitad izquierda y una mitad derecha, y ordenando cada una de esas mitades primero, y después de haber ordenado recursivamente cada una de esas mitades, volvemos a unir esas mitades. Repitiendo este proceso recursivamente una y otra vez, podemos construir rápidamente una matriz ordenada entera.

Cada uno de estos algoritmos puede ser analizado en términos de su tiempo de ejecución, en términos de big O; el límite superior en el número de pasos requeridos para completar la ordenación; y así como big omega, el límite inferior en el número de pasos requeridos para completar la ordenación. En este caso, podemos ver que para un ordenamiento por selección, tanto big O como big omega son cuadráticos. Es decir, si hay n números que estamos tratando de ordenar, podría tomar alrededor de n^2 pasos para completar realmente ese algoritmo de ordenamiento.

Mientras tanto, el ordenamiento burbuja también tiene un big O de n^2. Como límite superior, todavía podría tomar alrededor de n^2 pasos para ordenar n números, pero tiene un big omega de n. Es decir, si tuviéramos suerte y nos dieran una matriz que ya estuviera ordenada, por ejemplo, el ordenamiento burbuja podría ordenar n elementos y usándose sólo n pasos haciendo solo una revisión de la matriz, concluyendo que no son necesarios más intercambios, y luego no continuar con nada más, porque la matriz ya está ordenada.

Mientras tanto, el ordenamiento por mezcla tiene un tiempo de ejecución de big O de n log n, y big omega también de n log n, lo que significa que si hay n números que estamos tratando de ordenar, este algoritmo va a tomar alrededor de n veces log n pasos para ordenar todos esos números. Eso es mejor que n^2, aunque no tan bueno como el big omega de n, por ejemplo.

Tu tarea, en este laboratorio, es que te vamos a dar tres programas: sort1, sort2 y sort3. Uno de ellos usa ordenamiento por selección. Uno de ellos usa ordenamiento burbuja. Y uno de ellos usa ordenamiento por mezcla, pero no te diremos cuál es cuál. Tu tarea será ejecutar estos programas de ordenamiento en diferentes entradas, listas de números de diferentes tamaños y órdenes diferentes, y tratar de determinar qué algoritmo corresponde a qué programa.

Los archivos que te daremos serán random5000.txt, por ejemplo, que será un archivo de texto que contiene 5,000 números en un orden aleatorio. Asimismo, random10000.txt y random50000.txt contendrán 10,000 y 50,000 números, respectivamente, todos en orden aleatorio.

Además de los archivos en orden aleatorio, también te daremos archivos llamados reversed5000.txt y reversed10000.txt, y así sucesivamente, cada uno de los cuales también contendrá números, pero esta vez en orden inverso, desde el más grande al más pequeño. Y finalmente, también te damos sorted5000 y sorted10000.txt, que de nuevo serán archivos de texto que simplemente contienen números, uno en cada línea, pero esta vez los números ya estarán en orden de menor a mayor.

Ahora, lo que necesitas hacer es probar y cronometrar cada uno de estos programas en algunos de los archivos de ejemplo que te proporcionamos. No tienes que probar con todos, pero probablemente deberás probar con al menos unos pocos para darte una idea de cómo se comportan estos programas según el tamaño de la entrada y dependiendo de qué tan bien ordenados ya estén los valores dentro de ese archivo de texto. 

Usando esa información, deberías ser capaz de determinar qué programa corresponde a qué algoritmo de ordenamiento aprovechando lo que sabes sobre los tiempos de ejecución de esos algoritmos de ordenamiento. Si un algoritmo de ordenamiento tiene un big omega mucho mejor que su big O, entonces podrías esperar que fuera mucho más rápido en un archivo de texto que ya está ordenado, por ejemplo. 

Y podrías examinar lo que sucede con cada uno de estos programas al intentar ejecutarlos en entradas más grandes y más grandes con más y más valores para ver cuánto tiempo les lleva en comparación con los archivos que tienen menos valores. Usando toda esa información como pistas e información, deberías ser capaz de juntar y sacar conclusiones sobre qué algoritmos de ordenamiento estamos utilizando en cada uno de esos programas.

Yo soy Brian, y esto fue el ordenamiento.