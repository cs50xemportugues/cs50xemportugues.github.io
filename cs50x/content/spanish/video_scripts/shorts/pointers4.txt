¿Qué crees que sucede si intentamos desreferenciar un puntero cuyo valor es nulo? Recuerda que el puntero nulo no señala a nada. Entonces, si intentas desreferenciar la nada o ir a una dirección vacía, ¿qué crees que sucede? Bueno, si adivinaste que es un error de segmentación, tienes razón. Si intentas desreferenciar un puntero nulo, sufres un error de segmentación. Pero espera, ¿no te dije que si no vas a establecer el valor de tu puntero por algo significativo, deberías establecerlo como nulo? Sí, y en realidad, el error de segmentación es una especie de un buen comportamiento.

¿Alguna vez has declarado una variable y no has asignado su valor de inmediato? Así que simplemente dices int x; En realidad, no lo asignas a nada y luego, más adelante en tu código, imprimes el valor de x, aún sin asignar a nada. Con frecuencia, obtendrás cero, pero a veces puede obtener algún número aleatorio, y no tienes ni idea de dónde vino. De manera similar, pueden ocurrir cosas con punteros. Cuando declaras un puntero int *pk, por ejemplo, y no lo asignas a un valor, obtienes cuatro bytes de memoria. Cualquier cuatro bytes de memoria que el sistema pueda encontrar que tengan algún valor significativo. Y podría haber algo ya allí que ya no sea necesario por otra función, por lo que solo tienes los datos que había allí.

¿Qué sucede si intentas desreferenciar alguna dirección que no había ya bytes e información allí, que ahora está en tu puntero? Si intentas desreferenciar ese puntero, podrías estar manipulando parte de la memoria con la que no pretendías intervenir en absoluto. Y de hecho, podrías hacer algo realmente devastador, como romper otro programa, o romper otra función, o hacer algo malicioso que no pretendías hacer en absoluto. Y por eso en realidad es una buena idea establecer tus punteros como nulos si no los estableces en algo significativo. Probablemente sea mejor que al final del día su programa falla que hacer algo que arruine otro programa o otra función. Ese comportamiento probablemente es incluso menos ideal que simplemente fallar. Y por eso en realidad es una buena costumbre establecer tus punteros como nulos si no los estableces en un valor significativo de inmediato, un valor que conozcas y que puedas dereferenciar de forma segura.

Entonces, volvamos ahora y echemos un vistazo a la sintaxis general de la situación. Si digo int *p;, ¿qué acabo de hacer? Lo que he hecho es esto. Sé que el valor de p es una dirección porque todos los punteros son solo direcciones. Puedo desreferenciar p usando el operador *. En este contexto aquí, en la parte superior, recuerda que * es parte del tipo. Int * es el tipo de datos. Pero puedo desreferenciar p usando el operador * y si lo hago, si voy a esa dirección, ¿qué encontraré en esa dirección? Encontraré un número entero. Por lo tanto, int * p básicamente significa que p es una dirección. Puedo desreferenciar p y si lo hago, encontraré un número entero en esa ubicación de memoria.

Bueno, dije que había otra cosa molesta con las estrellas y aquí es donde vuelve a ser molesto, porque el * es en realidad parte del nombre del tipo y parte del nombre de la variable. Y así, si digo int * px, py, pz, lo que realmente obtengo es un puntero a un entero llamado px y dos enteros, py y pz. Y probablemente no es lo que queremos, no es bueno.

Entonces, si quiero crear múltiples punteros en la misma línea, del mismo tipo y estrellas, lo que realmente necesito hacer es decir int * pa, * pb, * pc. Ahora, al haber dicho esto y ahora decirte esto, probablemente nunca hagas esto. Y probablemente sea algo bueno, para ser honesto, porque podrías omitir involuntariamente una estrella, algo así. Probablemente sea mejor declarar punteros en líneas individuales, pero es solo otro de esos puntos de sintaxis molestos con los que tienes que trabajar. Con la práctica, realmente se convierte en algo natural. Todavía cometo errores después de programar 10 años, así que no te molestes si algo te sucede, es bastante común, en realidad es una falla en la sintaxis.

Bueno, prometí que volveríamos a visitar el concepto de cuán grande es una cadena. Bueno, si te dijera que una cadena, en realidad, te he estado mintiendo todo el tiempo. No hay un tipo de datos llamado cadena y, de hecho, mencioné esto en uno de nuestros primeros videos sobre tipos de datos, que la cadena era un tipo de datos que se creó para ti en CS50.h. Debes #include CS50.h para usarlo.

Bueno, la cadena es en realidad solo un alias para algo llamado char *, un puntero a un carácter. Bueno, los punteros, recuerda, son solo direcciones. Entonces, ¿cuál es el tamaño en bytes de una cadena? Bueno, son cuatro u ocho. Y la razón por la que digo cuatro u ocho es porque en realidad depende del sistema. Si estás utilizando CS50 ide, el tamaño de un char * es de ocho, es un sistema de 64 bits. Cada dirección en memoria es de 64 bits de largo. Si estás usando la aplicación CS50 o cualquier máquina de 32 bits, y has escuchado ese término, máquina de 32 bits, ¿qué es una máquina de 32 bits? Bueno, solo significa que cada dirección en memoria es de 32 bits de largo. Entonces, 32 bits son cuatro bytes. Entonces, un char * tiene cuatro u ocho bytes dependiendo de tu sistema. Efectivamente, cualquier tipo de datos y un puntero a cualquier tipo de datos, ya que todos los punteros son solo direcciones, son cuatro u ocho bytes. Por lo tanto, revisitemos este diagrama y concluyamos este video con un pequeño ejercicio aquí. Entonces, este es el diagrama que dejamos al principio del video. Entonces, ¿qué sucede ahora si digo * pk = 35? Entonces, ¿qué significa cuando digo * pk = 35? Tómese un segundo. * pk. En este contexto, * es el operador de desreferencia. Entonces, cuando se usa el operador de desreferencia, vamos a la dirección indicada por pk y cambiamos lo que encontramos. Entonces, * pk = 35 efectivamente hace esto con la imagen. Por lo tanto, es básicamente sintácticamente idéntico a haber dicho k = 35.

Uno más. Si digo int m, creo una nueva variable llamada m. Una nueva caja, es una caja verde porque va a contener un número entero, y está etiquetada como m. Si digo m = 4, pongo un número entero en esa caja. Si digo pk = & m, ¿cómo cambia este diagrama? Pk = & m, ¿recuerdas qué hace o se llama el operador &? Recuerda que & algún nombre de variable es la dirección de un nombre de variable. Entonces, lo que estamos diciendo es que pk obtiene la dirección de m. Y así, efectivamente lo que sucede con el diagrama es que pk ya no apunta a k, sino que apunta a m.

Nuevamente, los punteros son muy difíciles de manejar y requieren mucha práctica, pero debido a su capacidad para permitirte pasar datos entre funciones y tener esos cambios surtir efecto, comprenderlos es muy importante. Probablemente sea el tema más complicado que discutimos en CS50, pero el valor que obtienes al usar punteros supera con creces las complicaciones que surgen al aprenderlos. Así que te deseo la mejor de las suertes aprendiendo sobre punteros.

Soy Doug Lloyd, esto es CS50.