Entonces, los números hexadecimales, ¿como si necesitáramos otro esquema de números base, verdad? Bueno, la mayoría de las culturas occidentales, como probablemente ya sabe, usan el sistema decimal: la base 10, para representar datos numéricos. Tenemos los dígitos 0, 1, 2, 3, 5, 6, 7, 8, 9. Y si necesitamos representar valores superiores a nueve, podemos combinar esos dígitos usando la noción de valor posicional. Por lo tanto, para el número 10, tenemos un dígito 1 seguido de un cero, y entendemos intuitivamente que lo que estamos haciendo allí es multiplicar el primer 1 por 10, y luego agregar 0 para obtener un total de 10. Las computadoras hacen algo bastante similar, como seguramente estará familiarizado, con el sistema binario: la base 2. La diferencia allí es que solo hay 2 dígitos con los que trabajar: 0 y 1. Y por lo tanto, nuestros valores por posición, en lugar de ser uno, diez, cien, mil, como lo serían en el sistema decimal, son uno, dos, cuatro, ocho, y así sucesivamente. Aquí está la cosa, esos 0 y 1, especialmente si somos científicos de la computación y estamos haciendo mucha programación o trabajando con computadoras, vamos a ver muchos números binarios. Y esos 0 y 1 en largas cadenas pueden ser muy difíciles de analizar. No podemos simplemente mirar una cadena de 0 y 1 y saber exactamente lo que es. Pero sigue siendo útil poder expresar datos de la misma manera que lo hace una computadora. Tenemos esta noción del sistema hexadecimal, que es base 16 en lugar de base 10 o base 2. Lo que significa que tenemos 16 dígitos con los que trabajar en lugar de 10 o 2. Y es una forma mucho más concisa de expresar información binaria en un sistema informático, es mucho más comprensible para los humanos. Así que tenemos los dígitos del 0 al 9, y luego también tenemos estos seis dígitos extra: a, b, c, d, e y f, que representan 10, nuestra noción de 10, 11, 12, 13, 14 y 15, en decimal. A veces, por cierto, también verá estas a través de f en mayúsculas como A a través de F en mayúsculas, que es la forma en que suelo hacerlo. Es solo mi estilo preferido, pero ambos están bien, ambos representan prácticamente lo mismo. 

Entonces, ¿por qué es genial el hexadecimal? ¿Por qué necesitamos usar esta base adicional? Ya tenemos 2 y 10, ¿por qué necesitamos 16? Bueno, 16 es una potencia de 2, y cada dígito hexadecimal, del 0 al f, corresponde a un arreglo ordenado único de 4 dígitos binarios, 4 bits. Y en ese sentido, podemos expresar números binarios largos y complejos en hexadecimal de una manera mucho más concisa, sin perder información o tener que hacer conversiones especialmente complicadas en esos números.

Como acabo de decir, cada grupo de 4 dígitos binarios corresponde a un solo dígito hexadecimal, por lo que en realidad es muy fácil cambiar de un número hexadecimal a binario y viceversa. Si tiene esta larga cadena de dígitos binarios, todo lo que necesita hacer es comenzar a agruparlos de derecha a izquierda en grupos de 4. Y luego puede consolidarlos en números hexadecimales, limitando severamente la cantidad de dígitos que tiene que procesar mentalmente. En lugar de 32 0's y 1's, como veremos en un segundo, podría reducirlo a solo 8 dígitos hexadecimales, mucho más conciso.

Los cuadros de unas pocas diapositivas anteriores le ayudarán a descubrir este mapeo, aunque de nuevo lo memorizará bastante rápido. Pasaremos por un ejemplo ahora. Entonces, si tenemos un número como este, este número binario realmente grande, o lo que parece ser un número binario grande. Y la razón por la que lo digo es que es un monstruo, ¿verdad? Hay tantos 0 y 1 allí. Pero probablemente no tengamos una idea de cuál es realmente la magnitud de este número. No tenemos idea de lo que correspondía a un decimal. Y de hecho, ni siquiera veremos a qué corresponde en decimal en este momento. Podríamos expresarlo de una manera que nos dé más información sobre cuán grande es este número.

Entonces, vayamos a ese proceso de conversión. Lo primero que debemos hacer es queremos agrupar estos dígitos en grupos de 4, comenzando desde la derecha y trabajando hacia la izquierda. Hay 32 dígitos aquí, lo que significa que tenemos un buen punto de interrupción limpio de 8 grupos de 4. Recuerde que cada grupo de 4 aquí corresponde de manera única a un dígito hexadecimal. Entonces, comenzaremos nuevamente a construir nuestro número desde la derecha y trabajaremos hacia la izquierda. Bueno, ¿qué es 1101? Bueno, hacemos la matemática en nuestra cabeza, tenemos 1 en el lugar de los ocho, un 1 en el lugar de los cuatro, un 0 en el lugar de los dos y un 1 en el lugar de los unos. Eso es 8 más 4 más 1, que sabríamos como 13. Pero probablemente no escribiríamos 13, porque estamos trabajando con hexadecimal. Necesitamos convertirlo a la equivalencia hexadecimal de 13, que es d.

0011, bueno, eso es un 0 en el lugar de los ocho, un 0 en el lugar de los cuatro, un 1 en el lugar de los dos y un 1 en el lugar de los unos. Eso es 3. Sigue haciendo esto de nuevo, aquí tenemos 9. Y luego 11, pero eso es b, recuerde. 2, 10, o a, 6 y 4. Y así, esa cadena muy grande de 0 y 1 en la parte superior se expresa de manera más concisa en hexadecimal como 0x46a2b93d.

Bueno, vale, hemos aprendido una nueva habilidad genial, ¿cuál es el punto? Es posible que no usemos esto todo el tiempo, como pronto veremos, usamos hexadecimal bastante a menudo como programadores. No necesariamente con el propósito de hacer matemáticas con él, pero porque muchas veces las direcciones de memoria en nuestro sistema están representadas en hexadecimal. Es una forma realmente concisa de expresar números binarios, que de otra manera serían engorrosos. Y, nuevamente, es posible que no haga matemáticas con él, no multiplicará números hexadecimales entre sí ni hará nada raro como ese. Pero es una habilidad útil para tener para poder expresar y comprender direcciones de memoria y otras formas de usar datos en C. 

Soy Doug Lloyd, esto es CS50.