En CS50 aprendimos sobre una variedad de algoritmos de clasificación y búsqueda. A veces puede resultar un poco complicado seguir la pista de qué hace cada algoritmo. Realmente, solo hemos arañado la superficie. Hay muchos otros algoritmos de búsqueda y clasificación. Entonces, en este video, tomemos unos minutos para destilar cada algoritmo hasta sus elementos básicos para que pueda recordar la información más importante acerca de ellos y así poder articular las diferencias si es necesario.

El primero es el ordenamiento por selección. La idea básica detrás del ordenamiento por selección es encontrar el elemento no ordenado más pequeño en una matriz y cambiarlo por el primer elemento no ordenado de esa matriz. Dijimos que el tiempo de ejecución en el peor de los casos era n al cuadrado. Si desea recordar por qué, eche un vistazo al video sobre ordenamiento por selección. El tiempo de ejecución en el mejor de los casos de ordenamiento por selección también es n al cuadrado.

En el ordenamiento de burbuja, la idea detrás de este es intercambiar pares adyacentes. Este es el punto clave que te ayuda a recordar la diferencia. Ordenamiento por selección es, hasta ahora, encontrar el más pequeño - ordenamiento de burbuja es intercambiar pares adyacentes. Intercambiamos pares adyacentes de elementos si están fuera de orden, lo que efectivamente hace circular los elementos más grandes hacia la derecha, y al mismo tiempo comienza a mover los elementos más pequeños hacia la izquierda. El tiempo de ejecución en el peor de los casos del ordenamiento de burbuja es n al cuadrado. El tiempo de ejecución en el mejor de los casos del ordenamiento de burbuja es n. Porque en esa situación, no necesitamos hacer ningún intercambio en absoluto. Solo tenemos que hacer un recorrido a través de los n elementos.

En el ordenamiento por inserción, la idea básica aquí es el desplazamiento. Esa es la palabra clave para el ordenamiento por inserción. Vamos a pasar una vez por la matriz de izquierda a derecha. Y mientras lo hacemos, desplazamos los elementos que ya hemos visto para hacer espacio para los más pequeños que deben encajar en esa porción ordenada. Entonces construimos la matriz ordenada elemento a elemento, de izquierda a derecha, y movemos las cosas para hacer espacio. El tiempo de ejecución en el peor de los casos del ordenamiento por inserción es n al cuadrado. El tiempo de ejecución en el mejor de los casos del ordenamiento por inserción es n.

Ordenamiento por mezcla: la palabra clave aquí es dividir y mezclar. Dividimos la matriz completa, ya sean seis elementos, ocho elementos, 10.000 elementos, la dividimos a la mitad, a la mitad, a la mitad, hasta que tengamos una matriz completa de n conjuntos de matrices de un solo elemento. Un conjunto de n matrices de un solo elemento. Entonces empezamos a mezclar esas submatrices nuevamente en orden correcto. Tomamos dos matrices de un solo elemento y creamos una matriz de dos elementos. Tomamos dos matrices de dos elementos y creamos una matriz de cuatro elementos y así sucesivamente hasta que volvamos a construir una matriz de n elementos.

El tiempo de ejecución en el peor de los casos del ordenamiento por mezcla es n veces log n. Tenemos n elementos, pero este proceso de combinarlos toma log n pasos para regresar a una matriz completa. El tiempo de ejecución en el mejor de los casos también es n log n porque este proceso realmente no le importa si la matriz estaba ordenada o no para empezar. El proceso es el mismo, no hay forma de atajar las cosas. n log n en el peor de los casos, n log n en el mejor de los casos.

Hablamos de dos algoritmos de búsqueda. La búsqueda lineal se trata de iterar. Procedemos a través de la matriz una vez, de izquierda a derecha, tratando de encontrar el número que estamos buscando. El tiempo de ejecución en el peor de los casos es big O de n. Podría ser que tengamos que iterar a través de cada elemento para encontrar el elemento que estamos buscando, ya sea en la última posición o no en absoluto. Pero no podemos confirmar eso hasta que hayamos mirado todo. En el mejor de los casos, encontramos inmediatamente. El tiempo de ejecución en el mejor de los casos de la búsqueda lineal es omega de 1.

Por último, está la búsqueda binaria, que requiere una matriz clasificada. Recuerda que esa es una consideración muy importante al trabajar con búsqueda binaria. Es un requisito previo para usarla; la matriz por la que estás buscando debe estar ordenada. De lo contrario, la palabra clave es dividir y conquistar. Dividimos la matriz a la mitad y eliminamos la mitad de los elementos cada vez que avanzamos. Debido a este enfoque de dividir y conquistar y dividir las cosas a la mitad, el tiempo de ejecución en el peor de los casos de la búsqueda binaria es log n, lo cual es sustancialmente mejor que el tiempo de ejecución de la búsqueda lineal, que es n. El tiempo de ejecución en el mejor de los casos sigue siendo uno. Podríamos encontrarlo de inmediato la primera vez que hacemos una división, pero, nuevamente, recuerda que aunque la búsqueda binaria es sustancialmente mejor que la búsqueda lineal por ser log n versus n, es posible que tengas que ordenar primero la matriz, lo que podría hacerla menos efectiva dependiendo del tamaño de la matriz ordenada.
 
Soy Doug Lloyd, esto es CS50.