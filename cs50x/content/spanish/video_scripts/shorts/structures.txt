OK. Hemos trabajado con enteros, hemos trabajado con caracteres, hemos trabajado con flotantes, dobles, strings y bools. Hemos agotado prácticamente todos los tipos de datos que han estado disponibles hasta el momento. Pero ahora queremos hacer algo más. ¿Cómo lo hacemos? ¿Cómo creamos diferentes tipos de datos? Podemos hacerlo mediante el uso de estructuras. Las estructuras nos permiten unificar variables de diferentes tipos en una sola variable nueva, a la que podemos asignarle su propio nombre de tipo. Esto es realmente importante porque ahora podemos agrupar elementos de diferentes tipos de datos que tienen una conexión lógica. Hemos podido hacer esto con arrays de alguna manera, ¿verdad? Podemos agrupar variables del mismo tipo de datos juntas en una gran unidad de memoria, un array. 

Pero no hemos podido mezclar diferentes tipos de datos juntos. No podemos, por ejemplo, emparejar un entero, un carácter y un doble en la misma cosa y llamarla una sola unidad. Pero con las estructuras, o a menudo referidas como structs, en realidad podemos hacerlo. Entonces, una estructura es como una super variable. Es una variable que contiene otras variables dentro de ella. Aquí hay un ejemplo de una estructura muy sencilla. Así es como se vería la sintaxis para crear una estructura para un auto. Ahora, vamos a revisar la sintaxis aquí. Struct, esa es la palabra clave que indica que estoy creando un nuevo tipo de dato aquí. En particular, el nombre del tipo de dato va a ser struct car, como veremos. Pero esta es una especie de advertencia para el compilador de que este grupo de variables va a ser considerado parte del mismo tipo en un minuto. 

Cars, es solo el nombre de la estructura. De nuevo, el tipo de datos aquí va a ser struct car, no solo car. Pero si tienes diferentes structs en el mismo programa, necesitas distinguir entre struct y struct. Por lo tanto, struct car, también podría tener struct student, por ejemplo, en el mismo programa. Dentro de las llaves están todos los llamados campos o miembros de la estructura. Entonces, ¿qué son algunas de las cosas inherentes a un auto? Bueno, usualmente tiene un año, tiene un nombre de modelo, una placa, un odómetro que usualmente tiene algún número de millas y tal vez un tamaño de motor. Y como puedes ver, estoy mezclando enteros y caracteres y dobles. Todos van a ser parte de este nuevo tipo de datos. 

Por último, la última cosa que necesito hacer, no olvides este pequeño punto y coma al final. Después de que terminamos de definir la estructura, necesitamos poner un punto y coma al final. Es un error sintáctico muy común, porque con una función, por ejemplo, solo tendrías llave abierta, llave cerrada. No pones un punto y coma al final de la definición de una función. Esto parece una definición de función, pero no lo es, por lo que el punto y coma es solo un recordatorio de que necesitas ponerlo allí, porque el compilador de lo contrario no sabrá qué hacer con él. Es un error muy común que se comete al definir estructuras. 

OK. Por lo general, definimos nuestras estructuras en la parte superior de nuestros programas porque probablemente serán utilizadas por múltiples funciones. No queremos definir una estructura dentro de una función, porque entonces solo podemos... El ámbito de la estructura realmente solo existe dentro de esa función. Probablemente querríamos definir una estructura para que la podamos usar en múltiples funciones, o tal vez en múltiples archivos que se unen para crear nuestro programa. A veces, en lugar de definir la estructura en la parte superior donde coloca sus pound includes y sus pound defines, por ejemplo, puede colocarlas en archivos .h separados, que luego se pound include a sí mismos. 

Entonces, tenemos estructuras, pero ahora necesitamos ingresar en ellas. ¿Cómo ingresamos en una estructura para acceder a esas subvariables, esas variables que existen dentro de la estructura? Bueno, tenemos algo llamado el operador de punto, que nos permite acceder a los campos de la estructura. Por ejemplo, digamos que he declarado mi tipo de dato de estructura en algún lugar de la parte superior de mi programa, o tal vez en un archivo .h que he incluido. Si luego quiero crear una nueva variable de ese tipo de datos, puedo decir struct car, my car, punto y coma. Al igual que podría decir int x, o string name, punto y coma. 

El tipo de datos aquí es struct car, el nombre de la variable es my car, y luego puedo usar el operador de punto para acceder a los diferentes campos de my car. Puedo decir my car dot year igual a 2011. Eso es perfectamente aceptable. El año, si lo recuerda, se definió como un campo entero dentro de este nuevo tipo de datos struct car. Por lo tanto, cualquier variable de tipo struct car, como mi auto, puedo decir my car dot year igual y luego asignarle algún valor entero, 2011, por ejemplo. my car dot plate igual a CS50. my card dot odometer igual a 50505 punto y coma. Todo eso está perfectamente bien y así es como accedemos a los campos de la estructura. Las estructuras, sin embargo, no necesitan ser creadas en la stack. Al igual que cualquier otra variable, podemos asignarles dinámicamente. Si tenemos un programa que puede estar generando muchas estructuras, no sabemos cuántas necesitaremos, entonces necesitamos asignar dinámicamente esas estructuras mientras nuestro programa se ejecuta. Y así, si vamos a acceder a los campos de una estructura en ese contexto, recuerda que primero necesitamos desreferenciar el puntero a la estructura y, una vez que desreferenciamos el puntero, entonces podemos acceder a los campos. Si solo tenemos un puntero a la estructura, no podemos simplemente decir "puntero.nombre de campo" y obtener lo que estamos buscando. Hay un paso extra de desreferenciación. Digamos que en lugar de lo anterior, simplemente declararla en la stack, struct car, my car, punto y coma, digo struct car, star, un puntero a una struct car llamada my car, igual a malloc tamaño de struct car. Tamaño de struct car nos dirá cuántos bytes ocupa tu nuevo tipo de datos. No necesariamente solo necesitas usar tamaño de, ancho, int, o char, o cualquiera de los tipos de datos incorporados. El compilador es lo suficientemente inteligente como para entender cuántos bytes son requeridos por tu nueva estructura. Por lo tanto, asigno dynamicamente una unidad de memoria lo suficientemente grande como para contener una struct car, y obtengo un puntero de regreso a ese bloque de memoria, y ese puntero se asigna a my car. 

Ahora, si quiero acceder a los campos de my car, primero desreferencio my car usando el operador de desreferencia, el asterisco que hemos visto en los videos de punteros, y luego después de haber desreferenciado el puntero, puedo usar el operador de punto para acceder a los diferentes campos de my car. Estrella my car dot year igual a 2011. Eso tendría el efecto que queremos en este caso, porque hemos asignado dinámicamente my car. 

Pero eso es algo molesto, ¿verdad? Ahora hay un proceso de 2 pasos. Ahora tenemos un operador de estrella y un operador de punto. Y como puedes esperar, porque a los programadores de C les encanta formas más cortas de hacer las cosas, hay una forma más corta de hacerlo. Hay otro operador llamado flecha, que hace este proceso mucho más fácil. La forma en que funciona la flecha es que primero desreferencia el puntero en el lado izquierdo del operador, y luego, después de haber desreferenciado el puntero en el lado izquierdo, accede al campo del lado derecho. Y así, anteriormente teníamos esta especie de estrella mi car punto toda esta información, como que hay mucho pasando allí. Pero lo que podemos hacer en su lugar es esto - my car flecha año igual a 2011. 

Nuevamente, ¿qué está sucediendo aquí? Primero, estoy desreferenciando my car. Que es un puntero aquí. Luego, después de haber desreferenciado my car, puedo acceder a los campos year, plate y odometer, tal y como podría haber hecho antes de haber utilizado asterisco para desreferenciar my car y punto para acceder al campo. Así que puedes tener estructuras, puedes tener punteros a estructuras, y tienes formas de acceder a los campos de esas estructuras, ya sea que tengas punteros a ellas o las variables mismas. Punto o flecha, dependiendo de cómo se declaró la variable. Soy Doug Lloyd, esto es CS50.