Bueno, hablemos de bucles. Los bucles son geniales porque permiten que su programa ejecute líneas de código una y otra vez sin tener que copiar y pegar o repetirlos de otra manera. Hay tres tipos principales de bucles que verá. Probablemente tendrá la ocasión de usar cada uno de ellos a medida que avance en CS50. Algunos de estos bucles le sonarán de Scratch, por lo que, como hicimos con las condicionales, los pondremos uno al lado del otro si hay una analogía que podamos dibujar.

El primero es forever de Scratch, que es comparable a while (true). Esto es lo que llamamos un bucle infinito. Las líneas de código entre las llaves, al igual que las piezas de rompecabezas que encajan dentro de la C del bloque forever, se ejecutarán repetidamente de arriba abajo, una y otra vez para siempre. Después de todo, si recuerda nuestra discusión de expresiones booleanas, true siempre es true. Por lo tanto, si estamos haciendo algo siempre y cuando true sea true, parece un poco tonto. True siempre es true, por lo que siempre se ejecutará. Se ejecutará para siempre hasta que encontremos una manera de salir de él con una instrucción break, que nuevamente, vimos hace un tiempo mientras hablamos de la instrucción switch.

O simplemente mate nuestro programa, que, por cierto, si alguna vez se encuentra en una situación con un bucle infinito y no sabe cómo detener su programa, simplemente presione control y C y eso matará su programa por usted. Pero esto, nuevamente, se llama un bucle infinito. Es un bucle que se ejecutará para siempre. Ahora, los bucles while no siempre son infinitos porque también podemos reemplazar la expresión booleana con algo más útil que solo true. Aquí hay otro ejemplo. Mientras que y alguna expresión booleana y luego llaves. Eso es prácticamente análogo a repetir hasta en Scratch. Aunque en un segundo, explicaré la diferencia.

Entonces, en C, si la expresión booleana dentro del bucle while se evalúa como verdadera, las líneas de código entre las llaves se ejecutarán repetidamente hasta que la expresión booleana se evalúe como falsa. Por ejemplo, puede tener algún tipo de contador. Entonces, digamos que al comienzo de este bucle dice int x es igual a cero. Mientras x sea menor que 100, hacer un par de cosas dentro de esas llaves, luego al final de su bucle, dice x plus plus, está incrementando x. Eventualmente, x llegará a 100 y se detendrá porque la condición x es menor que 100 ya no será verdadera tan pronto como x sea igual a 100. 100 no es menor que 100.

Ahora, algo confusamente, el comportamiento del bloque Scratch está invertido. Así que tenga mucho cuidado si esta es su primera incursión en el uso de bucles. Básicamente, el bloque repetir hasta en Scratch repetirá algo una y otra vez hasta que la expresión, la expresión booleana en el hexágono sea verdadera. Entonces seguirá haciéndolo hasta que sea verdadero. Mientras tanto, el bucle while seguirá haciéndolo hasta que sea falso. Entonces son bastante similares, pero hay esa pequeña distinción por la que debemos tener cuidado, especialmente cuando hacemos nuestra primera incursión desde Scratch a C. El siguiente tipo de bucle es bastante similar. Se llama el bucle do-while. Este bucle ejecutará todas las líneas de código entre llaves una vez y luego verificará la expresión booleana. Si la expresión booleana se evalúa como verdadera, volverá y repetirá ese proceso una y otra vez hasta que la expresión booleana se evalúe como falsa. Entonces, a diferencia de un bucle while, se garantiza que este bucle se ejecutará al menos una vez. Eso puede ser bastante útil.

Por último, tenemos un bucle for. Los bucles for son un poco sintácticamente poco atractivos y hay mucho sucediendo aquí, así que aguántenos mientras tratamos de separar estas piezas. En general, el caso de uso de un bucle for es que desea repetir algo un número específico de veces. En este ejemplo aquí, tengo el bloque repetir desde Scratch, que es análogo al bucle for en C, repitiendo algo 10 veces. Y el bucle for allí a la izquierda, que es un bucle de cuatro que haría lo mismo. Esto iría 10 veces. Contando desde cero, incrementamos cada paso del bucle. Y seguimos haciendo eso hasta que i sea menor que 10.

¿Entonces, qué pasa? Hay mucho código allí. Desglosemos lo que está sucediendo paso a paso mientras cavamos a través de un bucle for. Lo primero que sucede es que se define la variable del contador. Todo a la izquierda de ese primer punto y coma dentro de los paréntesis se ejecuta. En este caso, estamos diciendo int i es igual a cero. Declarando una nueva variable llamada i, esa variable es de tipo entero y estamos diciendo que el valor dentro de esa variable va a ser cero.

La segunda cosa que hacemos es que inmediatamente evaluamos la expresión booleana. La expresión booleana está en el medio de los dos punto y coma. I es menos que 10. Esto es verdadero aquí ¿verdad? Acabamos de decir que i es igual a cero, por lo que 0 es menor que 10 y, por lo tanto, esa condición es verdadera y ahora procederemos a ejecutar el cuerpo del bucle. Si fuera falso. Si, por ejemplo, en lugar de i igual a 0 allí dije que i es igual a 15, int i es igual a 15. Bueno, 15 no es menos que 10, por lo que nunca ingresaríamos al cuerpo del bucle porque la expresión booleana allí se evaluaría como falsa.

Después de recorrer la parte superior de abajo, encontramos esa llave de cierre, ocurre una tercera cosa. El contador de la variable se incrementa, o mejor dicho, las líneas de código de una declaración después del segundo punto y coma dentro de los paréntesis de los bucles for se ejecutan. Entonces, comenzamos diciendo int i es igual a 0. Luego verificamos si la expresión booleana es verdadera o no. 0 es menor que 10. Por lo tanto, es cierto. Entonces, vamos a proceder en el cuerpo del bucle. Algo sucederá dentro del bucle, y cuando encontremos esa llave de cierre, la siguiente cosa que hacemos es decir i plus plus. i era cero, ahora i es uno. Entonces, verificamos nuevamente el valor de la expresión booleana en el medio. Uno es menor que 10. Por lo tanto, pasaremos por este proceso una y otra vez. Llegaremos a la llave de cierre nuevamente. Incrementaremos i de 1 a 2 y de 2 a 3. Y así sucesivamente hasta que el valor de i se convierte en 10. ¿Es 10 menor que 10? No. Contando desde cero, hemos pasado por 10 iteraciones de bucle. Hemos repetido 10 veces, así como lo hicimos en el bloque Scratch.

Ahora, quitando el código real y colocándolo en declaraciones generales básicas. Esto es lo que sucede. Todas las declaraciones en