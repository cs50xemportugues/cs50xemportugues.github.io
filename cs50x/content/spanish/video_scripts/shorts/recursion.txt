Si viste nuestro video sobre recursión, el proceso podría haber parecido un poco mágico. ¿Cómo sabe una función que debe esperar a otra función y pasar sus datos a otra cosa que está funcionando al mismo tiempo? Puede parecer un poco mágico al principio si no entiendes exactamente cómo se llaman las funciones y cómo funcionan en C. Y la forma en que funcionan es mediante algo llamado pila de llamadas o "call stack". La forma en que funciona la pila de llamadas es la siguiente: si llamas a una función, básicamente lo que ocurre es que se asigna un gran trozo de memoria en algún lugar del sistema para que esa función haga su trabajo. Por ejemplo, si llamas a una función y lo primero que haces es declarar un par de variables, se creará un marco de pila o función, y a esas variables se les dará espacio. Si son tres enteros, obtendrás tres fragmentos de cuatro bytes, igual que el tamaño de un entero, además de algún espacio para hacer algunos cálculos y lo que la función pueda necesitar. Y allí es donde la función hará todo su trabajo. 

Ahora, es posible que más de un marco de función exista en memoria en un momento dado. Por ejemplo, supongamos que la función main llama a otra función llamada mover. Y luego la función mover llama a otra función llamada dirección. En ese momento, todas esas tres funciones tienen marcos abiertos. Pero en general, solo uno de esos marcos será activo. Solo una de esas funciones se está ejecutando en un momento dado, aunque las tres tengan espacio apartado y estén esperando hacer algo. 

La forma en que se organizan estos marcos es en lo que se llama una pila. El marco de la función más llamada recientemente es siempre el que está en la parte superior de la pila, y ese se llama el marco activo. Por lo tanto, si main llama a mover y mover llama a dirección, puedes pensarlo como una pila de la siguiente manera, donde main está en la parte inferior, mover está por encima de él, dirección está en la parte superior, y dirección es el marco activo. Esa es la única función que está haciendo algo en el momento, mientras que mover y main están esperando para convertirse en el marco activo. Están esperando para convertirse en el marco que está en la parte superior de la pila. Cuando se llama a una nueva función, se crea un nuevo marco que se llama empujado a la parte superior de la pila. Por lo tanto, si llamas a una nueva función, esa función obtiene inmediatamente espacio y memoria y se coloca en la parte superior de la pila, y se convierte en el marco activo. Y lo que sea que era el marco activo, si había uno, está en espera. Solo está sentado allí. Es un patrón de espera, esperando a convertirse en el marco activo de nuevo. Cuando una función termina su trabajo, como devolver un valor, lo más común, o tal vez llegar al final de la línea si es una función void, que no tiene un valor de retorno, ese marco se llama retirado de la pila. Luego, el marco que estaba en segundo lugar, ya que este marco ahora ha desaparecido, se convierte en el marco activo. Se reanuda donde se detuvo. Si presionas pausa en esa función, retoma inmediatamente donde la dejaste. De hecho, así es como funciona la recursión porque todos estos marcos están funcionando, pero solo uno de ellos se está moviendo en un momento dado. El resto de ellos está corriendo, pero están en pausa. Solo están esperando convertirse en la nueva parte superior de la pila de nuevo. Si llamamos a otra función, el marco activo vuelve a estar en espera. La función que acabamos de llamar se coloca en la parte superior, y así sucesivamente, hasta que todos los marcos de función se hayan terminado. 

Veamos una visualización de esto, un ejemplo usando la función factorial para ver si podemos ayudar a que esto sea un poco más claro. Este es el contenido completo del archivo factorial, por ejemplo. Y dentro de ese archivo factorial, tengo dos funciones, fact, que será una implementación recursiva factorial, y main, que básicamente imprime el valor factorial, en este caso, de 5. Comenzamos al principio de main. Y lo primero que hace main es llamar a otra función, llama a printf(). Tan pronto como lo hace, main está en pausa. Está esperando a printf() que haga su trabajo. ¿Qué tiene que hacer printf()? Solo tiene que imprimir un número, pero tiene que imprimir el factorial de 5 o no conoce el factorial de 5. Tiene que hacer una llamada de función. Así que printf() luego queda en pausa y espera para factorial de 5, que ahora se convierte en el nuevo marco activo. Entonces, ¿qué está sucediendo en el marco factorial de 5? Estamos pasando el valor 5 a la función fact. Y luego verificará, bueno, ¿n es igual a 1? No. Entonces va a devolver n veces fact n menos 1. Ahora, el marco factorial 5 básicamente está llamando a una nueva función, pasando otra llamada a factorial, pasando 4 como parámetro. Así que el marco del factorial 5 queda en pausa y un marco para el factorial de 4 se convierte en el nuevo marco activo. Y va a pasar por el mismo proceso. ¿Es 4 igual a 1? No. Por lo tanto, devolverá n veces, en este caso, 4 veces factorial de 3, otra llamada de función. El marco factorial 4 se pausa. El marco factorial 3 se convierte en el nuevo marco activo. Repetimos este proceso de nuevo para el factorial de 3, para el factorial de 2, y luego llegamos al factorial de 1. Por lo tanto, al principio, justo cuando se llama al factorial 1, hay siete marcos de función en la pila de llamadas. El factorial 2, 3, 4, 5, printf() y main están esperando en las líneas que ves allí. Solo están esperando convertirse en el nuevo marco activo nuevamente. Pero no se mueven de esos indicadores de flechas. El marco del factorial 1 comienza. Hace la pregunta, ¿n es igual a 1? Bueno, en este caso, la respuesta es sí. Va a devolver 1. Ahora, recuerda lo que sucede cuando una función devuelve un valor, ese cuadro de función está listo. Se va. Y eso significa que se elimina de la pila de llamadas y el marco que está debajo de él se convierte en el nuevo marco activo. Por lo tanto, el número factorial de 1 devuelve 1. En este punto, su marco se destruye y el factorial de 2 ahora puede continuar. Ahora, el factorial de 2 es esa línea azul oscuro a la izquierda allí y estaba esperando el valor de retorno del factorial de 1. Bueno, el factorial de 1 dijo: "Te devolví un 1". Por lo tanto, el factorial de 2 devolverá 2 veces 1, o 2. Ahora también está devolviendo y, por lo tanto, cuando regresa, se elimina de la pila. Su marco de función se destruye y el marco del factorial de 3 se convierte en el nuevo marco activo. El factorial de 3 esperaba el factorial de 2, que devolvió un 2. Por lo tanto, va a devolver 3 veces 2, o 6. Devuelve el valor. Su marco de función se elimina de la pila. Es destruido. El marco factorial 4 se convierte en el nuevo marco activo. El factorial de 4 estaba esperando el factorial de 3. Recibió su respuesta de 6. Por lo tanto, va a devolver 4 veces 6, o 24. Y va a devolver ese valor a factorial de 5, que ha estado esperando que el factorial de 4 termine su trabajo. Retorna 5 veces 24, que son 120. Cuando ese cuadro se destruye, ahora reanudamos en printf(). Printf() tiene esa línea roja oscuro en la parte inferior allí. Estaba esperando al factorial de 5, que acaba de devolver un 120. Entonces, lo que hace printf() es imprimir 120 y luego su trabajo ha terminado. No tiene nada más que hacer. No está esperando otra llamada de función y, por lo tanto, termina de ejecutarse. No devuelve nada, pero no tiene nada más que hacer. Por lo tanto, su marco de función se destruye. Se elimina de la pila. Y solo tenemos que ver dónde se detuvo main. Bueno, eso es todo lo que tenía main. Y, por lo tanto, el marco de su función se elimina de la pila también y este programa habrá completado su trabajo imprimiendo 120. Espero que esa ilustración de la pila de llamadas haya ayudado a mostrar exactamente cómo funciona la recursión y cómo estas funciones están esperando e interactuando entre sí para permitir el proceso recursivo.

Soy Doug Lloyd. Esto es CS50.