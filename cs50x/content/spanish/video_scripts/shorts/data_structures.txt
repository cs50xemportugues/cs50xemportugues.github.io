Así que en CS50, hemos cubierto muchos tipos de estructuras de datos, ¿verdad? Hemos visto arreglos, listas enlazadas, tablas hash, tries, pilas y colas. Además, también aprenderemos un poco sobre árboles y heaps, pero en realidad, todos ellos son solo variaciones de un mismo tema. Hay realmente cuatro ideas básicas a las que todo se reduce: arreglos, listas enlazadas, tablas hash y tries. Y como dije, hay variaciones en ellos, pero esto resume prácticamente todo lo que vamos a hablar en esta clase en términos de C. Pero, ¿cómo se comparan estos todos, verdad? Hemos hablado de los pros y los contras de cada uno en videos separados, pero hay muchos números dando vueltas. Hay muchos pensamientos generales dando vueltas. Tratemos de consolidarlo todo en un solo lugar. Comparemos los pros con los contras y consideremos qué estructura de datos podría ser la adecuada para su situación en particular, sea cual sea el tipo de datos que está almacenando. No siempre necesitas usar la inserción, eliminación y búsqueda súper rápida de un trie si realmente no te importa insertar y eliminar demasiado. Si solo necesitas un acceso aleatorio rápido, quizás un arreglo sea mejor. Entonces, destilémoslo. Hablemos de cada uno de los cuatro tipos principales de estructuras de datos que hemos discutido y veamos cuándo podrían ser buenos y cuándo no tanto. Comencemos con los arreglos. Entonces, la inserción, eso es un poco malo.

La inserción al final de un arreglo está bien si estamos construyendo un arreglo a medida que avanzamos. Pero si necesitamos insertar elementos en el medio, pensemos en la inserción de ordenamiento, habrá muchas modificaciones para encajar un elemento allí. Y así, si vamos a insertar en cualquier lugar además del final de un arreglo, probablemente no sea tan bueno.

De manera similar, la eliminación, a menos que estemos eliminando del final de un arreglo, también probablemente no sea tan bueno si no queremos dejar espacios vacíos, lo que generalmente no hacemos. Queremos eliminar un elemento y luego colocarlo de nuevo. Y así, eliminar elementos de un arreglo tampoco es tan bueno.

La búsqueda, sin embargo, es excelente. Tenemos acceso aleatorio, una búsqueda constante de tiempo. Simplemente decimos siete y nos dirigimos a la séptima ubicación del arreglo. Decimos 20, vamos a la vigésima ubicación del arreglo. No tenemos que iterar en todo el arreglo. Eso es bastante bueno.

Los arreglos también son relativamente fáciles de ordenar. Cada vez que hablamos de un algoritmo de ordenamiento, como la selección de ordenamiento, la inserción de ordenamiento, la burbuja de ordenamiento, el ordenamiento de intercambio, siempre usamos arreglos para hacerlo, porque los arreglos son bastante fáciles de ordenar, en comparación con las estructuras de datos que hemos visto hasta ahora.

También son relativamente pequeños. No hay mucho espacio adicional. Simplemente reservas exactamente lo que necesitas para guardar tus datos y eso es prácticamente todo. Entonces son bastante pequeños y eficientes de esa manera. Pero otra desventaja es que son de tamaño fijo. Tenemos que declarar exactamente qué tan grande queremos que sea nuestro arreglo y solo tenemos un intento. No podemos hacerlo crecer ni encoger.

Si necesitamos hacerlo crecer o encoger, necesitamos declarar un arreglo completamente nuevo, copiar todos los elementos del primer arreglo en el segundo arreglo. Y si calculamos mal en ese momento, necesitamos hacerlo de nuevo. No tan bueno. Entonces, los arreglos no nos dan la flexibilidad de tener cantidades variables de elementos.

Con una lista enlazada, la inserción es bastante fácil. Simplemente pegamos al frente. La eliminación también es bastante fácil. Tenemos que encontrar los elementos. Eso implica alguna búsqueda.

Pero una vez que ha encontrado el elemento que está buscando, todo lo que necesita hacer es cambiar un puntero, posiblemente dos si tiene una lista enlazada, una lista enlazada doble, y luego simplemente puede liberar el nodo. No tiene que mover todo. Simplemente cambia dos punteros, por lo que es bastante rápido.

Sin embargo, la búsqueda es mala, ¿verdad? Para encontrar un elemento en una lista enlazada, ya sea de enlace único o de doble enlace, tenemos que buscar en ella de manera lineal. Tenemos que comenzar al principio y movernos al final, o comenzar al final y movernos al principio. Ya no tenemos acceso aleatorio. Entonces, si estamos haciendo muchas búsquedas, tal vez una lista enlazada no sea tan buena para nosotros.

También son realmente difíciles de ordenar, ¿verdad? La única forma en que realmente puedes ordenar una lista enlazada es ordenarla a medida que la construyes. Pero si la ordenas a medida que la construyes, ya no estás haciendo inserciones rápidas. Ya no solo las pegas al frente. Ahora tienes que encontrar el lugar correcto para ponerla y luego su inserción se convierte en algo casi tan malo como insertar en un arreglo. Entonces, las listas enlazadas no son tan buenas para ordenar datos.

También son bastante pequeñas, en cuanto a tamaño. Las listas enlazadas dobles ligeramente más grandes que las listas enlazadas simples, que son ligeramente más grandes que los arreglos, pero no es una cantidad enorme de espacio desperdiciado. Entonces, si el espacio es un problema, pero no es un problema muy intenso, este podría ser el camino a seguir.

Tabla Hash. La inserción en una tabla hash es bastante sencilla. Es un proceso de dos pasos. Primero necesitamos pasar nuestros datos a través de una función hash para obtener un código hash, y luego insertamos el elemento en la tabla hash en ese lugar de código hash.

La eliminación, similar a la lista enlazada, es fácil una vez que encuentras el elemento. Primero tienes que encontrarlo, pero luego, cuando lo eliminas, solo necesitas intercambiar un par de punteros, si estás usando encadenamiento separado. Si estás usando la sonda, o si no estás usando encadenamiento en absoluto en tu tabla hash, la eliminación es realmente fácil. Todo lo que necesitas hacer es codificar los datos y luego ir a esa ubicación. Suponiendo que no tienes colisiones, podrás eliminar muy rápidamente.

Ahora, la búsqueda es donde las cosas se complican un poco. En promedio es mejor que las listas enlazadas. Si estás usando encadenamiento, todavía tienes una lista enlazada, lo que significa que todavía tienes la desventaja de la búsqueda en una lista enlazada. Pero debido a que estás tomando tu lista enlazada y dividiéndola en 100 o 1000 o n elementos en tu tabla hash, tus listas enlazadas son todas una enésima parte del tamaño. Todas son sustancialmente más pequeñas. Tienes n listas enlazadas en lugar de una lista enlazada de tamaño n.

Y así, este factor de constante del mundo real, del que generalmente no hablamos en la complejidad temporal, realmente marca la diferencia aquí. Entonces, la búsqueda sigue siendo una búsqueda lineal si estás usando encadenamiento, pero la longitud de la lista por la que estás buscando es muy, muy corta en comparación. Nuevamente, si tu objetivo es ordenar, probablemente la tabla Hash no sea la forma adecuada de hacerlo. Simplemente usa un arreglo si la clasificación es realmente importante para ti.

Y pueden variar en tamaño. Es difícil decir si una tabla hash es pequeña o grande, porque realmente depende de cuán grande sea tu tabla hash. Si solo vas a almacenar cinco elementos en tu tabla hash y tienes una tabla hash con 10,000 elementos, probablemente estés desperdiciando mucho espacio. Si contrastas eso, también puedes tener tablas hash muy compactas, pero cuanto más pequeña sea tu tabla hash, mayores serán esas listas vincul