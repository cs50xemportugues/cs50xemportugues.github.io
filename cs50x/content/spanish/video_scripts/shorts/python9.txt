Muy bien, ahora algo completamente diferente. Hablemos de objetos. Los objetos no los hemos cubierto todavía en CS50. Y Python es un lenguaje de programación orientado a objetos. Lo más cercano que tenemos a un objeto es una estructura en C. Las estructuras en C, como recordarás, tienen varios campos en ellas. En un contexto orientado a objetos, podríamos llamar a esos campos propiedades. Pero esas propiedades nunca pueden existir independiente del conjunto definido por alguna estructura en C. Así que si defino una estructura en C aquí, como hago en la esquina superior derecha, una estructura de coche que tiene dos campos o dos propiedades, año y modelo, podría decir lo siguiente. "Struct car Herbie": estoy declarando una nueva variable de tipo "struct car" llamada "Herbie". Y estoy diciendo que "Herbie.year = 1963, Herbie.modelo = beetle", completamente correcto, ¿verdad? Porque en cada caso, donde estoy usando "year" y "model", los estoy asociando con alguna estructura de ese tipo de datos, en este caso "Herbie". Pero nunca podría decir esto. No es válido en C, al menos con lo que tenemos aquí, porque "year" y "model" no pueden simplemente existir de manera independiente. Están atados a lo que significa ser una "struct car". Así que siempre tenemos que asociarlos con una "struct car". Eso no funcionaría. Esa es la analogía de las propiedades del objeto a los campos de la estructura en C. Pero los objetos, además de tener propiedades, también tienen métodos. Ya me has escuchado usar esa palabra un par de veces en este video. Los métodos son básicamente funciones inherentes a lo que significa ser un objeto. No se puede llamar a esa función de manera aleatoria en cualquier cosa. Solo se puede llamar a esa función en objetos de ese tipo, en objetos donde esa función significa algo. Las propiedades y los métodos nunca existen de manera independiente. Siempre son parte de lo que significa ser un objeto. Debido a esto, los objetos son mucho más importantes. Si tienes estas propiedades y tienes estos métodos y siempre dependen de objetos, ahí es de donde proviene el término orientado a objetos. El objeto es lo más importante. No pasamos objetos a una función, llamamos métodos en objetos. Y esa es la sintaxis general que verás en muchos lenguajes de programación orientados a objetos, en algún objeto hay algún método, que es solo otra palabra para una función, que está asociado con este que estamos llamando en ese objeto. Vamos a ver un ejemplo de esto en solo un momento. Ahora los objetos no son necesariamente genéricos. De hecho, podemos crear nuestros propios tipos específicos de objetos, al igual que creamos nuestros propios tipos específicos de estructuras en C. Y la forma de hacerlo es usando la palabra clave "class". La palabra clave "class" introduce un nuevo tipo de objeto. Cada clase, así que cada nuevo tipo de objeto que creas, requiere una función de inicialización. No tuvimos que hacer esto en C. Pero básicamente lo que hace, y también escucharás este término como un constructor, que comúnmente se usa en lenguajes como C + +, por ejemplo, y básicamente lo que hace es crear un objeto para ti y asigna el valor de algunas propiedades automáticamente. Recuerda que en Python solo podemos declarar variables asignándoles un valor. Así que básicamente, esta es la idea análoga. Estamos creando un objeto de un tipo particular y estamos rellenando todas o muchas de las propiedades de ese objeto con algunos datos. Luego, además de definir las propiedades del objeto, también tenemos que definir funciones o métodos que se pueden aplicar al objeto. Cada método que definimos dentro de la clase tiene al menos un parámetro, y ese parámetro se llama canónicamente, aunque no es necesario llamarlo así, se llama "self", básicamente es una referencia al objeto para que siempre podamos saber de qué objeto estamos hablando. Entonces, cada función que escribas, cada método que escribas en una clase para definir algún nuevo tipo de objeto, siempre tendrá un parámetro más de lo que crees que necesitas, porque el primer parámetro siempre será "self". Tratemos de destilar esto en algún código real para que puedas ver lo que estamos haciendo aquí cuando hablamos de definir un nuevo tipo de clase, definir algunos métodos y luego veremos cómo podemos aplicar esos métodos a objetos en esa clase. Aquí está una clase muy simple llamada "Student". Entonces, la clase "Student" con "S" mayúscula, aparentemente significa que ahora voy a crear, siempre que quiera crear un nuevo objeto estudiante, usaré esa palabra clave "Student" con "S" mayúscula. Y estoy definiendo tres funciones. La primera es ese constructor, esa función de inicialización, que siempre se llama "__init__". Ahora, aparentemente, mi "Student" va a tener dos propiedades. Van a tener un nombre y un ID. Pero como estoy definiendo un método dentro de esa clase, siempre tengo que incluir ese parámetro "self" para que siempre sepa de qué objeto estoy hablando o qué objeto está siendo invocado aquí. Dentro de mi función de inicialización, estoy haciendo algo bastante sencillo. Simplemente estoy diciendo "self.name = name" y "self.ID = ID". Estoy asignando las propiedades de nombre e ID del objeto "Student" para que sean lo que sea que pase aquí. Y luego tengo otra función llamada "changeID", y aparentemente lo uso para cambiar la idea de un estudiante, el número de identificación de un estudiante después de haberlo creado. Porque estoy asignando el ID cuando lo inicializo, pero aquí aparentemente ya he creado el objeto "Student" y lo voy a cambiar. Entonces "changeID" toma dos parámetros, "self" para que sepa qué "Student" de "S" mayúscula, a qué objeto Student .... se refiere, y el número de ID al que quiero cambiarlo. Y luego tengo una función llamada "print", que toma solo un parámetro, "self". Aparentemente no va a tomar nada más, pero aún así siempre tengo que indicar el parámetro "self". Siempre debe ser parte de cualquier método que defina para una clase que cree. Y aparentemente lo que estoy haciendo aquí es imprimiendo "self.name" y "self.ID" con un pequeño guion entre ellos. Eso es lo que está sucediendo allí. Es solo alguna interpolación de variables como vimos antes. Solo estoy imprimiendo "self.name" - "self.ID". ¿Qué pasaría aquí? Creo una nueva variable, un nuevo objeto, llamado "Jane". Y esta es mi inicialización. Estoy llamando a la función de constructor. Jane = Student con "S" mayúscula, de nuevo, ese es el nombre de nuestra clase, y estoy pasando dos valores. Jane, que aparentemente quiero asignar a "self.name", y 10. Entonces, inmediatamente después de esto, lo que sucedería es que tendría un nuevo objeto de estudiante llamado Jane, y el campo de nombre de Jane sería Jane entre comillas, y el campo de ID de Jane sería 10. Entonces, si lo imprimiera, y en realidad puedes tomar este código y recrearlo en CS50 IDE y verlo por ti mismo, si luego lo imprimo, imprimiría Jane espacio - espacio 10. Luego, si ejecutara Jane.changeID 11, probablemente puedas adivinar lo que sucedería porque luego, cuando lo imprimo de nuevo, imprimiría Jane espacio - espacio 11. Así que es solo un ejemplo de cómo crear ... de como definimos una clase, definimos métodos, asignamos propiedades. De nuevo, todo esto es inherente a lo que significa trabajar en un lenguaje de programación orientado a objetos. Entonces, aunque esto puede ser muy desconocido y nuevo, especialmente si vienes de un lenguaje como C, esto, si avanzas y haces programación orientada a objetos en lenguajes como Python, como PHP, como JavaScript o como muchos, muchos otros, esta noción de métodos, propiedades y cómo trabajamos con ellos va a ser realmente importante sintetizar.