Hemos declarado funciones y las hemos definido, lo cual es muy bueno. Ahora comencemos a usar las funciones que hemos declarado y definido. Para llamar a una función, es bastante fácil. Solo necesitas pasar los argumentos apropiados, del tipo de datos que la función espera, y luego asignar el valor de retorno de esa función a algo del tipo correcto.

Veamos esto en práctica en un archivo llamado adder1.c, que tengo en mi CS50 IDE. Aquí está adder1.c. Al principio, puedes ver que tengo mis includes: #include <stdio.h> y #include <cs50.h>. Luego tengo mi declaración de la función. Aquí es donde le estoy diciendo al compilador que voy a escribir una función llamada "add two ints". Va a devolver una variable del tipo entero. Esa es esta parte aquí. Y luego tengo dos entradas, a y b, cada una de las cuales es un entero.

Dentro de main, le solicito al usuario la entrada preguntándoles: "dame un entero". Y se les solicita con la función "get_int", que está incluida en la biblioteca de CS50. Y eso se almacena en x, una variable entera. Luego, les pedimos otro número entero. Obtenemos otro número entero y lo almacenamos en y. Y luego, aquí en la línea 28, es donde hacemos nuestra llamada a la función. Estamos diciendo: "int z = add_two_ints (x, y)". ¿Ves por qué esto tiene sentido? x es una variable del tipo entero y y es otra. Así que eso está bien y tiene sentido con lo que parece nuestra declaración de la función en la línea 17. La lista de entradas separadas por comas espera dos enteros, a y b. En ese caso, podemos llamarlos como queramos. Simplemente espera dos enteros y x es un entero e y es un entero. Eso funciona.

Y sabemos que la función también va a devolver un entero. Y así, estamos almacenando la salida de la función "add two ints" en una variable del tipo entero, a la que llamamos z. Y luego podemos decir que "la suma de %i y %i es %i". X, y y z llenan respectivamente esos % i's. ¿Cómo se ve la definición de "add_two_ints"? Es bastante simple. Es una de las que vimos hace un segundo: int sum = a + b; return sum;. ¿Funciona esto? Guardemos el archivo. Y luego aquí, en mi terminal, voy a hacer "adder1" y limpio mi pantalla. Voy a hacer zoom porque sé que es un poco difícil de ver.

Así que compilamos este programa como "adder1". Podemos hacer "./adder1". "Dame un entero, 10". "Dame otro entero, 20". La suma de 10 y 20 es 30. Así que hicimos una llamada a función exitosa. Puedes correr la función de nuevo, con -10, 17, "la suma de -10 y 17 es 7". Esta función funciona. Tiene el comportamiento que esperamos. Y así, hemos declarado una función exitosamente, también definido una función exitosamente y también hecho una llamada exitosa a una función.

Hay un par de puntos misceláneos sobre las funciones antes de concluir esta sección. Recuerda de nuestra discusión previa sobre los tipos de datos, que a veces las funciones no necesitan entradas. Si ese es el caso, declaramos la función como teniendo una lista de argumentos vacía: "void". ¿Recuerdas cuál es la función más común que hemos visto hasta ahora que lleva una lista de argumentos vacía? Lo es "main". Recuerda además que las funciones a veces no tienen una salida real. En ese caso, declaramos la función como teniendo un tipo de retorno vacío: "void". Concluyamos esta sección abordando un problema práctico.

Aquí está el problema: quiero que escribas una función llamada "triángulo válido". Lo que esta función debería hacer es tomar tres números reales que representen las longitudes de los tres lados de un triángulo como sus parámetros, o sus argumentos, o sus entradas (otro conjunto de sinónimos que podrías encontrar). Esta función debería devolver "true" o "false" dependiendo de si es posible formar un triángulo con esas tres longitudes. ¿Recuerdas el tipo de datos que usamos para indicar "true" o "false"? Ahora, ¿cómo implementarlo? Bueno, hay un par de reglas con respecto a los triángulos que son útiles de saber. Un triángulo solo puede tener lados con longitud positiva. Eso tiene sentido. Probablemente estés diciendo: "claro". La otra cosa a tener en cuenta, sin embargo, es que la suma de las longitudes de cualquier par de lados del triángulo tiene que ser mayor que la longitud del tercer lado. Eso es cierto. No puedes tener un triángulo de lados 1, 2 y 4, por ejemplo, porque 1 más 2 no es mayor que 4. Estas son las reglas que determinan si los tres números de entrada pueden formar un triángulo concebiblemente. Así que toma un par de minutos para declarar y luego definir esta función llamada "triángulo válido", de modo que realmente tenga el comportamiento especificado aquí. 

Aquí está una implementación de "triángulo válido". No es la única. La tuya podría variar ligeramente. Pero esta tiene, de hecho, el comportamiento que esperamos. Declaramos nuestra función al principio, bool valid_triangle (float x, float y, float z). Entonces, esta función toma tres números reales como argumentos, variables de valores (valores que pueden tener decimales), y devuelve un valor verdadero o falso, que es un booleano, recuerda. Así es por qué el tipo de retorno es "bool". Luego, definimos la función. Lo primero que hacemos es comprobar que todos los lados sean positivos. Si x es menor o igual a 0, o si y es igual a 0, o si z es menor o igual a 0, eso no puede ser un triángulo. No tienen lados positivos. Y así podemos devolver "false" en esa situación. Luego verificamos que cada par de entradas sea mayor que el tercer lado.

Entonces, si x + y es menor o igual a z, o si x + z es menor o igual que y, o si y + z es menor o igual que x, tampoco puede ser un triángulo válido. Por lo tanto, volvemos a devolver "false". Suponiendo que pasamos ambas comprobaciones, entonces podemos devolver "true". Porque esos tres lados son capaces de crear un triángulo válido. Y eso es todo. Ahora has declarado y definido una función. Y tal vez puedas usar y llamar a esta función. Gran trabajo. Soy Doug Lloyd. Este es CS50."