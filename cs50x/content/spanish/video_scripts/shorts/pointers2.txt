Volviendo a la idea de la memoria como un gran arreglo de celdas del tamaño de un byte. Eso es realmente lo que es, es solo un enorme arreglo de celdas, como cualquier otro arreglo con el que estés familiarizado, pero cada elemento tiene un ancho de un byte. Y al igual que en un arreglo, cada elemento tiene una dirección. Cada elemento de un arreglo tiene un índice y podemos usar ese índice para acceder aleatoriamente al arreglo. No tenemos que empezar desde el inicio del arreglo, iterar a través de cada elemento para encontrar lo que buscamos. Podemos decir simplemente que quiero ir al decimoquinto elemento o al centésimo elemento. Y solo tienes que pasar ese número y obtener el valor que buscas. 

De manera similar, cada ubicación en la memoria tiene una dirección. Entonces, tu memoria podría verse así. Aquí hay un fragmento muy pequeño de memoria, son 20 bytes de memoria. Los primeros 20 bytes tienen direcciones desde 0, 1, 2, 3 y así sucesivamente hasta 19. Cuando declaro variables y empiezo a trabajar con ellas, el sistema va a apartar un espacio para mí en esta memoria para trabajar con mis variables. Puedo decir, por ejemplo, char c es igual a H mayúscula. ¿Qué va a pasar? Bueno, el sistema va a apartar para mí un byte. En este caso eligió el byte número cuatro, el byte en la dirección cuatro, y va a guardar la letra H mayúscula para mí. Si luego digo int límite de velocidad es igual a 65, apartará cuatro bytes de memoria para mí, y tratará estos cuatro bytes como una única unidad porque lo que estamos trabajando es un entero aquí, y almacenará 65 allí.

Ahora, de alguna manera ya te estoy mintiendo, ¿verdad? Porque sabemos que las computadoras trabajan en binario. No entienden necesariamente qué es una H mayúscula o el número 65, solo entienden ceros y unos. Y en realidad, lo que se está almacenando allí no es la letra H el número 65, sino las representaciones binarias de ellos, lo que se ve un poco así. Y en particular, en el contexto de la variable entera, no la dividirá en un solo fragmento de cuatro bytes, en realidad la tratará como cuatro fragmentos de un byte, lo que podría verse algo así. Y ni siquiera esto es del todo cierto, debido a algo llamado orden de bytes (endianness) , en lo que no nos meteremos ahora, pero si estás interesado puedes leer sobre ordenamientos pequeños y grandes. Pero por el bien de este argumento, para el bien de este video, supongamos que es, de hecho, cómo el número 65 se representaría en la memoria en todos los sistemas, aunque no es completamente cierto.

Pero de hecho, olvidemos todo lo respecto al binario y pensemos solo en H y 65, es mucho más fácil pensar en ellos como ser humano. Bien, también parece un poco aleatorio que mi sistema no me haya asignado los bytes 5, 6, 7 y 8 para almacenar el entero. Hay una razón para ello también, en la que no entraremos ahora, pero baste decir que lo que la computadora está haciendo aquí es probablemente una buena elección por su parte. Para no darme memoria que necesariamente esté junto a la otra. Aunque lo hará ahora si quiero obtener otra cadena, llamada apellido, y quiero colocar en ella Lloyd. Necesitaré caber una letra en cada, cada letra requerirá un byte de memoria. Entonces, si puedo poner a Lloyd en mi arreglo como esto, estoy bastante bien, ¿verdad? ¿Qué falta? 

Recuerda que cada cadena con la que trabajamos en C termina con contrabarra cero, y no podemos omitir eso aquí tampoco. Necesitamos apartar un byte de memoria para contener eso para saber cuándo termina nuestra cadena. Entonces, nuevamente, la disposición de la forma en que aparecen las cosas en la memoria puede ser un poco aleatoria, pero en realidad es cómo se diseñan la mayoría de los sistemas. Para alinearlos en múltiplos de cuatro, por razones que nuevamente no necesitamos entrar ahora. Pero, para resumir después de estas tres líneas de código, esto es lo que podría verse la memoria. Si necesito las ubicaciones de memoria 4, 8 y 12 para sostener mis datos, esto es lo que podría verse mi memoria 

Y para ser particularmente pedante aquí, cuando hablamos de direcciones de memoria generalmente lo hacemos utilizando notaciones hexadecimales. Entonces, ¿por qué no convertir todos estos de la notación decimal a la notación hexadecimal simplemente porque así es como generalmente nos referimos a la memoria? Entonces, en lugar de ser del 0 al 19, lo que tenemos es 0x0 a 0x13. Esos son los 20 bytes de memoria que tenemos o que estamos viendo en esta imagen aquí. 

Dicho todo esto, alejémonos de la memoria y volvamos a los punteros. Aquí está lo más importante que debes recordar al empezar a trabajar con los punteros. Un puntero no es más que una dirección. Lo diré de nuevo porque es tan importante, un puntero no es más que una dirección. Los punteros son direcciones a ubicaciones en la memoria donde viven las variables. Sabiendo eso, con suerte se vuelve un poco más fácil trabajar con ellos. Otra cosa que me gusta hacer es tener ciertos diagramas que representan visualmente lo que está sucediendo con varias líneas de código. Y haremos esto un par de veces en los punteros, y cuando hablemos de la asignación de memoria dinámica también. Porque creo que estos diagramas pueden ser particularmente útiles.

Entonces, si digo, por ejemplo, int k en mi código, ¿qué está sucediendo? Bueno, lo que sucede básicamente es que se me está apartando memoria, pero ni siquiera me gusta pensar en eso, me gusta pensar en esto como una caja. Tengo una caja y está de color verde porque puedo colocar enteros en cajas verdes. Si fuera un carácter, podría tener una caja azul. Pero siempre digo, si estoy creando una caja que puede contener enteros, esa caja es de color verde. Y tomo un marcador permanente y escribo k en uno de sus lados. Así que tengo una caja llamada k, en la que puedo colocar enteros. Entonces, cuando digo int k, eso es lo que sucede en mi cabeza. Si digo k es igual a cinco, ¿qué estoy haciendo? Bueno, estoy poniendo cinco en la caja, ¿verdad? Esto es bastante sencillo, si digo int k, crea una caja llamada k. Si digo k es igual a 5, coloca cinco en la caja. Con suerte ese no es un salto demasiado grande. Pero aquí es donde las cosas se vuelven un poco interesantes. Si digo int *pk, aunque no sé lo que esto significa necesariamente, está claro que tiene algo que ver con un entero. Entonces voy a colorear esta caja un poco verde, sé que tiene algo que ver con un entero, pero no es un entero en sí mismo, porque es un entero en estrella. Hay algo ligeramente diferente. Un entero está involucrado, pero de lo contrario no es demasiado diferente de lo que estábamos hablando. Es una caja, tiene una etiqueta, lleva una etiqueta que dice pk y es capaz de contener int estrellas, lo que sea que eso signifique para los enteros. Aquí está la última línea. Si digo pk = &k, ¿qué acaba de suceder, verdad? Entonces, este número aparentemente aleatorio se arroja a la caja allí. Todo lo que sucede es que pk obtiene la dirección de k. Así que estoy pegando donde vive k en la memoria, su dirección, la dirección de sus bytes. Todo lo que estoy haciendo es diciendo que ese valor es lo que voy a poner dentro de mi caja llamada pk. Y como estas cosas son punteros, y como mirar una cadena como 0x80c74 820 probablemente no tenga mucho sentido. Cuando visualizamos los punteros en general, lo hacemos como punteros. Pk nos da la información que necesitamos para encontrar k en memoria. Entonces, básicamente, pk tiene una flecha en ella. Y si caminamos la longitud de esa flecha, imagina que es algo por lo que puedes caminar, si caminamos a lo largo de la longitud de la flecha, en la punta de esa flecha, encontraremos la ubicación en la memoria donde vive k. Y eso es realmente importante porque una vez que sabemos dónde vive k, podemos comenzar a trabajar con los datos dentro de esa ubicación de memoria. Aunque estamos adelantando un poco en este momento.