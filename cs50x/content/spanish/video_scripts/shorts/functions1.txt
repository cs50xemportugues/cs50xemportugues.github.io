Muy bien. Ahora vamos a abordar un tema muy importante, funciones. Hasta ahora, en el curso, todos los programas que hemos estado escribiendo han sido escritos dentro de main. Son programas bastante simples. No necesitas tener todas estas ramas y cosas ocurriendo. Podemos ajustarlo todo dentro de main y no se vuelve demasiado abrumador. Pero a medida que el curso avanza y comienzas a desarrollar programas de forma independiente, seguramente comenzarán a tener mucho más de 10 o 15 líneas. Podrías obtener cientos, miles o decenas de miles de líneas de código. Y realmente no es una idea muy loca. Como tal, probablemente no sea una buena idea mantenerlo todo dentro de main. Puede resultar un poco difícil encontrar lo que buscas si haces eso. Afortunadamente, C, y prácticamente todos los demás lenguajes de programación con los que pueda trabajar, nos permiten escribir funciones. Y voy a hacer un pequeño paréntesis aquí para mencionar que las funciones son una área de la informática. Y verás muchas más de ellas en varios puntos a lo largo del curso y si continúas. Donde hay muchos sinónimos para la misma palabra. Así que las llamamos funciones. Pero también podrías escuchar que se refieren a ellas como procedimientos o métodos, especialmente si alguna vez has hecho programación orientada a objetos, y no te preocupes si no lo has hecho, no es algo importante. Pero en los lenguajes orientados a objetos se llaman frecuentemente métodos. A veces se llaman subrutinas. Pero realmente todos hacen referencia a la misma idea básica.

Vamos a ver qué es esa idea. ¿Qué es una función? Bueno, una función no es más que una caja negra. Una caja negra que tiene un conjunto de cero o más entradas y una salida única. Entonces, por ejemplo, esto podría ser una función. Esta es una función llamada func. Y toma tres entradas a, b y c. Y dentro de esa caja negra, no sabemos exactamente lo que hace, pero procesa las entradas de alguna manera y luego proporciona una salida única, en este caso, z. Ahora, para hacerlo un poco menos abstracto, podríamos decir que quizás tengamos una función llamada sumar que toma tres entradas a, b y c y procesa la salida de alguna manera dentro de la caja negra para producir una salida única. Entonces, en este caso, si sumar toma 3, 6 y 7. En algún lugar dentro de la función de suma, esperaríamos que se sumaran para producir la salida, que es 3 más 6 más 7 o 16.

De manera similar, tienes una función llamada multiplicar que toma dos entradas, a y b, las procesa de alguna manera de modo que la salida de la función es el producto de las dos entradas. Las dos entradas multiplicadas juntas. Si pasamos 4 y 5 a la función multiplicar, algo sucede, la salida que esperamos es 20. ¿Por qué lo llamamos una caja negra? Bueno, si no estamos escribiendo las funciones nosotros mismos, lo que hemos hecho hasta ahora en CS50. Hemos visto print f, por ejemplo, que es una función que no escribimos nosotros mismos, pero que usamos todo el tiempo. Si no estamos escribiendo las funciones nosotros mismos, realmente no necesitamos saber cómo se implementa exactamente debajo del capó.

Entonces, por ejemplo, la caja negra que acabo de mostrarte para la multiplicación, mult a, b podría definirse, y esto es solo un seudocódigo, como output a times b. ¿Tiene sentido, verdad? Si tenemos una función llamada mult que toma dos entradas, esperaríamos que la salida fuera la multiplicación de las dos entradas, a veces b. Pero la multiplicación también se podría implementar de esta manera, tendríamos una variable de contador que se establece dentro de mult en 0. Y luego repetimos este proceso b veces agregando a contador. Por ejemplo, si multiplicamos 3a por 5b, podríamos decir que se establece el contador en 0, se repite cinco veces, se agrega 3 al contador. Entonces, comenzamos en 0 y hacemos esto cinco veces 3, 6, 9, 12, 15. Es el mismo resultado. Todavía obtenemos 3 veces 5, solo que la implementación es diferente.

Eso es lo que queremos decir cuando decimos caja negra. Solo significa que no nos importa cómo se implementa debajo del capó siempre y cuando la salida sea lo que esperamos. De hecho, eso forma parte del contrato de uso de las funciones, especialmente las funciones que otros escriben. El comportamiento siempre va a ser típico, impredecible en función del nombre de la función. Y por eso es muy importante cuando escribes funciones o cuando otras personas escriben funciones que podrías usar, que esas funciones tengan nombres claros y relativamente obvios, y que estén bien documentados. Lo cual es ciertamente el caso de la función como print f.

Entonces, ¿por qué usamos funciones? Bueno, como dije antes, si escribimos todo nuestro código dentro de main, las cosas pueden volverse muy tediosas y realmente complicadas. Las funciones nos permiten la capacidad de organizar las cosas y dividir un problema muy complicado en partes mucho más manejables. Las funciones también nos permiten simplificar el proceso de codificación. Es mucho más fácil depurar una función de 10 líneas en lugar de una función de 100 líneas o una función de 1,000 líneas. Si solo tenemos que depurar pequeñas piezas a la vez o escribir pequeñas piezas a la vez, hace que esa experiencia de programación sea mucho mejor. Créeme en eso.

Por último, si escribimos funciones, podemos reutilizar esas diversas partes. Las funciones pueden ser recicladas. Se pueden usar en un programa u otro. Ya has escrito la función, todo lo que necesitas hacer es decirle a ese programa dónde encontrar esa función. Hemos estado reciclando y usando print f durante más de 40 años. Pero solo se escribió una vez. Bastante útil, ¿verdad?