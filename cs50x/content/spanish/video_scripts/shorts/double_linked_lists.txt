Muy bien. Así que si acabas de terminar ese video sobre las listas simplemente enlazadas, lo siento por dejarte en un poco de suspenso. Pero me alegra que estés aquí para terminar la historia sobre las listas doblemente enlazadas.

Si recuerdas de ese video, hablamos de cómo las listas simplemente enlazadas limitan nuestra capacidad de lidiar con información en la que el número de elementos o elementos en una lista pueden crecer o encogerse. Ahora podemos lidiar con algo así, donde no podríamos lidiar con ello con matrices.

Pero sufren de una limitación crítica que es que con una lista simplemente enlazada, solo podemos movernos en una sola dirección a través de la lista. Y la única situación real donde eso puede convertirse en un problema es cuando intentábamos eliminar un solo elemento. Y ni siquiera discutimos cómo hacerlo en una lista simplemente enlazada en pseudocódigo. Ciertamente se puede hacer, pero puede ser un poco problemático. Entonces, si te encuentras en una situación en la que estás tratando de eliminar elementos individuales de la lista o si se requerirá que elimines elementos individuales de la lista, es posible que desees considerar el uso de una lista doblemente enlazada en lugar de una lista simplemente enlazada. Debido a que las listas doblemente enlazadas te permiten moverte hacia adelante y hacia atrás a través de la lista en lugar de solo hacia adelante a través de la lista, simplemente agregando un elemento adicional a nuestra definición de estructura para el nodo de lista doblemente enlazada.

Nuevamente, si no vas a eliminar elementos individuales de la lista, porque estamos agregando un campo adicional a nuestra definición de estructura, los propios nodos para listas doblemente enlazadas serán más grandes. Tomarán más bytes de memoria. Y, por lo tanto, si esto no es algo que necesites hacer, puede que decidas que no vale la pena el intercambio de tener que gastar los bytes de memoria adicionales requeridos para una lista doblemente enlazada si no vas a eliminar elementos individuales. Pero también son geniales para otras cosas también.

Entonces, como dije, solo tenemos que agregar un solo campo a nuestra definición de estructura, la noción de un puntero Previous. Entonces, con una lista simplemente enlazada, tenemos el valor y el puntero Next, por lo que la lista doblemente enlazada simplemente tiene una manera de moverse hacia atrás también.

Ahora, en el video de la lista simplemente enlazada, hablamos de que estas son cinco de las cosas principales que necesitas poder hacer para trabajar con listas enlazadas. Y para la mayoría de estos, el hecho de que sea una lista doblemente enlazada no es realmente un gran salto. Todavía podemos buscar moviéndonos hacia adelante desde el principio hasta el final. Todavía podemos crear un nodo de la nada, casi de la misma manera. También podemos eliminar listas de manera bastante similar. Las únicas cosas que son sutilmente diferentes, en realidad, son insertar nuevos nodos en la lista y finalmente hablar de eliminar un elemento de la lista. De nuevo, casi los otros tres, no los vamos a hablar ahora porque son ajustes menores a las ideas discutidas en el video de la lista simplemente enlazada.

Entonces, insertemos un nuevo nodo en una lista doblemente enlazada. Hablamos de hacer esto también para listas simplemente enlazadas, pero hay un par de trampas extra con las listas doblemente enlazadas. Estamos pasando en la cabeza de la lista aquí y algún valor arbitrario, y queremos obtener la nueva cabeza de la lista fuera de esta función. Es por eso que devuelve una estrella dllnode. Entonces, ¿cuáles son los pasos? Son, nuevamente, muy similares a las listas simplemente enlazadas con una adición extra. Queremos asignar espacio para un nuevo nodo y verificar que sea válido. Queremos llenar ese nodo con cualquier información que queramos poner en él. Lo último que necesitamos hacer: lo extra que necesitamos hacer, en realidad, es arreglar el puntero Previous de la antigua cabeza de la lista. Recuerda que debido a las listas doblemente enlazadas, podemos movernos hacia adelante y hacia atrás, lo que significa que cada nodo apunta en realidad a otros dos nodos en lugar de solo uno. Y entonces necesitamos arreglar la antigua cabeza de la lista para apuntar hacia atrás a la nueva cabeza de la lista enlazada, algo que no teníamos que hacer antes. Y como antes, simplemente regresamos un puntero a la nueva cabeza de la lista.

Entonces, aquí hay una lista. Queremos insertar 12 en esta lista. Observa que el diagrama es un poco diferente. Cada nodo contiene tres campos: datos y un puntero Next en rojo y un puntero Previous en azul. Nada viene antes del nodo 15, por lo que su puntero Previous es nulo. Es el inicio de la lista. No hay nada antes de eso. Y nada viene después del nodo 10, por lo que su puntero Siguiente también es nulo.

Entonces agreguemos 12 a esta lista. Necesitamos espacio para el nodo. Pusimos 12 dentro de él. Y luego, nuevamente, necesitamos tener mucho cuidado de no romper la cadena. Queremos reorganizar los punteros en el orden correcto. Y a veces eso puede significar, como veremos particularmente con eliminar, que tenemos algunos punteros redundantes, pero está bien.

Entonces, ¿qué queremos hacer primero? Recomendaría que lo primero que debes hacer es llenar los punteros del nodo 12 antes de tocar a alguien más. ¿A qué va a apuntar 12 a continuación? A 15. ¿Qué hay antes de 12? Nada. Ahora hemos llenado la información adicional en 12 para que tenga Previous, Next y valor.

Ahora podemos tener 15: este paso adicional del que estábamos hablando: podemos hacer que 15 apunte hacia atrás a 12. Y ahora podemos mover la cabeza de la lista enlazada también a ser 12. Entonces es bastante similar a lo que estábamos haciendo con listas simplemente enlazadas, excepto por el paso adicional de conectar la antigua cabeza de la lista con la nueva cabeza de la lista.

Ahora finalmente eliminemos un nodo de una lista enlazada. Entonces, digamos que tenemos alguna otra función que está buscando un nodo que queremos eliminar y nos ha dado un puntero exactamente al nodo que queremos eliminar. Ni siquiera necesitamos: digamos que la cabeza todavía se declara globalmente. No necesitamos la cabeza aquí. Todo lo que esta función hace es que hemos encontrado un puntero exactamente al nodo que queremos eliminar. Eliminémoslo. Es mucho más fácil con listas doblemente enlazadas. Primero, son solo un par de cosas. Solo necesitamos arreglar los punteros de los nodos circundantes para que salten sobre el nodo que queremos eliminar. Y luego podemos eliminar ese nodo. Entonces nuevamente, simplemente vamos aquí. Aparentemente, hemos decidido que queremos eliminar el nodo X. Y lo que estoy haciendo aquí, por cierto, es un caso general para