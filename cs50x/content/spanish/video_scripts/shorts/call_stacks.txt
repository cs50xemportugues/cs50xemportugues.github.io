Si viste nuestro video sobre recursión, el proceso podría parecer un poco mágico. ¿Cómo sabe una función esperar a otra función y pasar sus datos a alguna otra cosa que se esté ejecutando al mismo tiempo? Puede parecer un poco mágico al principio si no entiendes exactamente cómo se llaman y operan las funciones en C. Y la forma en que operan es usando algo llamado pila de llamadas. Y la forma en que funciona la pila de llamadas es la siguiente: si llamas a una función, básicamente lo que sucede es que se reserva un gran bloque de memoria en algún lugar del sistema para que esa función haga su trabajo. Por ejemplo, si llamas a una función y lo primero que haces es declarar un par de variables, se creará un marco de pila o marco de función, un gran bloque de memoria, y se les dará espacio a esas variables. Así que si son tres enteros, obtendrás tres trozos de cuatro bytes, del mismo tamaño que un entero, y algún espacio para hacer algunos cálculos y lo que sea que pueda necesitar la función. Y ahí es donde la función hará todo su trabajo. Ahora, es posible que más de un marco de función exista en la memoria en un momento dado. Por ejemplo, digamos que la función principal llama a otra función llamada mover. Y luego la función mover llama a otra función llamada dirección. En ese momento, las tres funciones tienen marcos abiertos. Pero en general, solo uno de esos marcos estará activo. Solo una de esas funciones se está ejecutando en un momento dado, aunque las tres tengan espacio reservado y estén esperando para hacer algo. Ahora, la forma en que se organizan estos marcos es en lo que se llama una pila. Y el marco de función más recientemente llamado es siempre el que está en la parte superior de la pila, y ese es el marco activo. Así que, de nuevo, si main llamara a mover y mover llamara a dirección, puedes pensar en esto como una pila de la siguiente manera, donde main está en la parte inferior, mover está encima, dirección está en la parte superior y dirección es el marco activo. Esa es la única función que está haciendo algo en este momento, mientras que mover y main simplemente están esperando para convertirse en el marco activo. Están esperando para convertirse en el marco que está en la parte superior de la pila. Cuando llamas a una nueva función, se agrega un nuevo marco a la parte superior de la pila. Entonces, si llamas a una nueva función, esa función inmediatamente obtiene espacio en la memoria y se coloca en la parte superior de la pila de llamadas. Y se convierte en el marco activo. Y cualquier marco que estuviera activo, si había alguno, se pausa. Está simplemente sentado allí. Es un patrón de espera, esperando convertirse en el marco activo nuevamente. Cuando una función termina su trabajo, como devolver, lo más común, o quizás llegar al final de la línea si es una función sin valor de retorno, ese marco se elimina de la parte superior de la pila. Y luego el marco que estaba en segundo lugar, ya que este marco ya se fue, se convierte en el marco activo. Se reanuda donde lo dejó. Si hubieras presionado pausa en esa función, continuará inmediatamente donde lo dejó. Esto es en realidad por qué la recursión funciona porque todos estos marcos están en ejecución, pero solo uno de ellos se está moviendo en un momento dado. El resto de ellos se están ejecutando, pero están en pausa. Están esperando para convertirse en la nueva parte superior de la pila de nuevo. Si llamamos a otra función, el marco activo se pausa nuevamente. La función que acabamos de llamar se coloca en la parte superior y así sucesivamente hasta que se terminan todos los marcos de funciones. Así que echemos un vistazo a una visualización de esto, un ejemplo usando la función factorial para ver si podemos hacer esto un poco más claro. Así es como se ve un archivo completo de factorial, por ejemplo. Y dentro de ese archivo factorial, tengo dos funciones, fact y main. Fact será una implementación recursiva de factorial, y main básicamente llama o imprime el valor de factorial, en este caso, de 5. Así que comenzamos al comienzo de main. Y lo primero que hace main es llamar a otra función. Llama a printf(). Tan pronto como lo hace, main se detiene. Se queda aquí y está esperando a que printf() haga su trabajo. ¿Qué tiene que hacer printf()? Solo tiene que imprimir un número, pero tiene que imprimir factorial de 5 o no sabe factorial de 5. Tiene que hacer una llamada a función. Entonces, printf() luego se pausa y espera el factorial de 5, que ahora se convierte en el nuevo marco activo. Así que en el marco de factorial de 5, ¿qué está sucediendo? Estamos pasando el valor 5 a la función fact. Y luego se comprobará, bueno, ¿es n igual a 1? No. Entonces, regresará n veces fact n menos 1. Entonces, el marco de factorial 5 básicamente está llamando a una nueva función, pasando otra llamada a factorial, pasando 4 como parámetro en su lugar. Así que el marco de factorial de 5 se pausa y se convierte en el marco activo para factorial de 4. Y va a pasar por el mismo proceso. ¿Es 4 igual a 1? No. Así que en su lugar, va a regresar n veces, en este caso, o cuatro veces factorial de 3, otra llamada a función. Así que el marco de factorial 4 se pausa. El marco de factorial de 3 se convierte en el marco activo. Y repite este proceso nuevamente para el factorial de 3, para el factorial de 2 y luego llegamos al factorial de 1. Entonces, al comienzo, justo cuando se llama el factorial de 1, hay siete marcos de funciones en la pila de llamadas. Factorial de 2, 3, 4, 5, printf() y main están todos en pausa en las líneas que se ven allí. Simplemente están esperando para convertirse en el nuevo marco activo nuevamente. Pero no se mueven desde esos indicadores con flechas. Entonces, el marco del factorial 1 comienza. Pregunta, ¿es n igual a 1? Bueno, en este caso, la respuesta es sí. Va a devolver 1. Ahora, recuerda lo que sucede cuando una función devuelve un valor, ese marco se acaba. Se va. Y eso significa que se elimina de la pila de llamadas y luego el marco que está debajo de él se convierte en el nuevo marco activo. Así que el marco de factorial 1 devuelve un 1. En ese punto, su marco se destruye y el factorial de 2 ahora puede continuar. Ahora, el factorial de 2 es esa línea azul oscuro que se ve a la izquierda allí y estaba esperando en el valor de retorno del factorial de 1. Bueno, el factorial de 1 dijo, te devolví un 1. Entonces, el factorial de 2 va a devolver 2 veces 1 o 2. También está devolviendo y cuando devuelve, se elimina de la pila. Se destruye su marco de función y el factorial de 3 se convierte en el nuevo marco activo. El factorial de 3 estaba esperando en el factorial de 2, que devolvió un 2. Entonces, va a devolver 3 veces 2, o 6, devuelve el valor. Su marco de función se elimina de la pila. Se destruye y el marco de factorial de 4 se convierte en el nuevo marco activo. El marco de factorial 4 estaba esperando en el factorial de 3. Obtuvo su respuesta de vuelta de 6. Entonces, va a devolver 4 veces 6, o 24. Y va a devolver ese valor al factorial de 5, que ha estado esperando a que el factorial de 4 termine su trabajo. Devuelve 5 veces 24, que es 120. Cuando se destruye ese marco, ahora comenzamos en printf(). printf() tiene esa línea roja oscura en la parte inferior. Estaba esperando en el factorial de 5, que acababa de devolver un 120. Entonces, lo que printf() hace es imprimir 120 y luego su trabajo ha terminado. No tiene nada más que hacer. No está esperando otra llamada de función y termina su ejecución. No devuelve nada, pero no tiene nada más que hacer. Entonces, su marco de función se destruye. Se elimina de la pila de llamadas. Y luego todo lo que tenemos que hacer es ver dónde se detuvo main. Bueno, eso era todo lo que tenía main. Y así, el marco de su función también se elimina de la pila. Y este programa habrá completado su trabajo al imprimir 120. Ojalá esa ilustración de la pila de llamadas haya ayudado a mostrar exactamente cómo funciona la recursión y cómo estas funciones están esperando e interactuando entre sí para permitir que ocurra el proceso recursivo. Soy Doug Lloyd. Esto es CS50.