<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Corretor ortogr√°fico</h1>
<h2>Problema a resolver</h2>
<p>Para este problema, voc√™ implementar√° um programa que verifica a ortografia de um arquivo, como o abaixo, usando uma tabela hash.</p>
<h2>Demonstra√ß√£o</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-o01nuZNSBSH2khVokTs2GEPtP" src="https://asciinema.org/a/o01nuZNSBSH2khVokTs2GEPtP.js"></script>

<h2>C√≥digo de distribui√ß√£o</h2>
<p>Para este problema, voc√™ estender√° a funcionalidade do c√≥digo fornecido a voc√™ pela equipe do CS50.</p>
<p>Fa√ßa login em <a href="https://cs50.dev/">cs50.dev</a>, clique na sua janela de terminal e execute <code>cd</code> por conta pr√≥pria. Voc√™ ver√° que o prompt da janela do terminal se parece com o seguinte:</p>
<pre><code>  $
</code></pre>
<p>Em seguida, execute</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/5/speller.zip
</code></pre>
<p>para baixar um ZIP chamado <code>speller.zip</code> em seu espa√ßo de c√≥digo.</p>
<p>Em seguida, execute</p>
<pre><code>  unzip speller.zip
</code></pre>
<p>para criar uma pasta chamada <code>speller</code>. Voc√™ n√£o precisa mais do arquivo ZIP, ent√£o voc√™ pode executar</p>
<pre><code>  rm speller.zip
</code></pre>
<p>e responder com "s" seguido de Enter no prompt para remover o arquivo ZIP que voc√™ baixou.</p>
<p>Agora digite</p>
<pre><code>  cd speller
</code></pre>
<p>seguido de Enter para se mover para (ou seja, abrir) esse diret√≥rio. Seu prompt agora deve se parecer com o seguinte.</p>
<pre><code>  speller/ $
</code></pre>
<p>Execute <code>ls</code> por conta pr√≥pria e voc√™ dever√° ver alguns arquivos e pastas:</p>
<pre><code>  dictionaries/  dictionary.c  dictionary.h  keys/  Makefile  speller.c  speller50  texts/
</code></pre>
<p>Se voc√™ tiver algum problema, siga estas mesmas etapas novamente e veja se consegue determinar onde errou!</p>
<h2>Hist√≥rico</h2>
<div class="alert alert-danger" data-alert="danger" role="alert"><p><strong>Dados os muitos arquivos neste programa, √© importante ler esta se√ß√£o na √≠ntegra antes de come√ßar. Assim, voc√™ saber√° o que fazer e como fazer!</strong></p></div>

<p>Teoricamente, na entrada de tamanho <em>n</em>, um algoritmo com um tempo de execu√ß√£o de <em>n</em> √© "assintoticamente equivalente", em termos de <em>O</em>, a um algoritmo com um tempo de execu√ß√£o de <em>2n</em>. Na verdade, ao descrever o tempo de execu√ß√£o de um algoritmo, normalmente nos concentramos no termo dominante (ou seja, mais impactante) (ou seja, <em>n</em> neste caso, uma vez que <em>n</em> pode ser muito maior que 2). No mundo real, por√©m, o fato √© que <em>2n</em> parece duas vezes mais lento que <em>n</em>.</p>
<p>O desafio que voc√™ tem pela frente √© implementar a verifica√ß√£o ortogr√°fica mais r√°pida que puder! Por "mais r√°pido", no entanto, estamos falando de "tempo real", n√£o de tempo assint√≥tico.</p>
<p>Em <code>speller.c</code>, criamos um programa projetado para verificar a ortografia de um arquivo depois de carregar um dicion√°rio de palavras do disco para a mem√≥ria. Esse dicion√°rio, entretanto, √© implementado em um arquivo chamado <code>dictionary.c</code>. (Ele poderia ser implementado em <code>speller.c</code>, mas √† medida que os programas ficam mais complexos, geralmente √© conveniente dividi-los em v√°rios arquivos.) Os prot√≥tipos para as fun√ß√µes nele contidas, entretanto, n√£o s√£o definidos no pr√≥prio <code>dictionary.c</code>, mas em <code>dictionary.h</code>. Dessa forma, tanto <code>speller.c</code> quanto <code>dictionary.c</code> podem <code>#include</code> o arquivo. Infelizmente, n√£o conseguimos implementar a parte de carregamento. Ou a parte de verifica√ß√£o. Deixamos ambos (e um pouco mais) para voc√™! Mas primeiro, um passeio.</p>
<h3>Compreendendo</h3>
<h4><code>dictionary.h</code></h4>
<p>Abra o <code>dictionary.h</code> e voc√™ ver√° uma nova sintaxe, incluindo algumas linhas que mencionam <code>DICTIONARY_H</code>. N√£o precisa se preocupar com isso, mas, se estiver curioso, essas linhas apenas garantem que, embora <code>dictionary.c</code> e <code>speller.c</code> (que voc√™ ver√° em um momento) <code>#include</code> este arquivo, <code>clang</code> o compilar√° apenas uma vez.</p>
<p>Em seguida, observe como <code>#include</code> um arquivo chamado <code>stdbool.h</code>. Esse √© o arquivo no qual o pr√≥prio <code>bool</code> √© definido. Voc√™ n√£o precisava disso antes, pois a Biblioteca CS50 costumava <code>#include</code> isso para voc√™.</p>
<p>Observe tamb√©m nosso uso de <code>#define</code>, uma "diretiva de pr√©-processador" que define uma "constante" chamada <code>LENGTH</code> que tem um valor de <code>45</code>. √â uma constante no sentido de que voc√™ n√£o pode (acidentalmente) alter√°-la em seu pr√≥prio c√≥digo. Na verdade, <code>clang</code> substituir√° qualquer men√ß√£o a <code>LENGTH</code> em seu pr√≥prio c√≥digo por, literalmente, <code>45</code>. Em outras palavras, n√£o √© uma vari√°vel, apenas um truque de localizar e substituir.</p>
<p>Finalmente, observe os prot√≥tipos para cinco fun√ß√µes: <code>check</code>, <code>hash</code>, <code>load</code>, <code>size</code> e <code>unload</code>. Observe como tr√™s deles recebem um ponteiro como argumento, de acordo com <code>*</code>:</p>
<pre><code>  bool check(const char *word);
  unsigned int hash(const char *word);
  bool load(const char *dictionary);
</code></pre>
<p>Lembre-se de que <code>char *</code> √© o que costum√°vamos chamar de <code>string</code>. Portanto, esses tr√™s prot√≥tipos s√£o essencialmente apenas:</p>
<pre><code>  bool check(const string word);
  unsigned int hash(const string word);
  bool load(const string dictionary);
</code></pre>
<p>E <code>const</code>, entretanto, apenas diz que essas strings, quando passadas como argumentos, devem permanecer constantes; voc√™ n√£o poder√° alter√°-las, acidentalmente ou n√£o!</p>
<h4><code>dictionary.c</code></h4>
<p>Agora abra <code>dictionary.c</code>. Observe como, no topo do arquivo, definimos um <code>struct</code> chamado <code>node</code> que representa um n√≥ em uma tabela hash. E declaramos uma matriz de ponteiros globais, <code>table</code>, que (em breve) representar√° a tabela hash que voc√™ usar√° para controlar as palavras no dicion√°rio. A matriz cont√©m <code>N</code> ponteiros de n√≥, e definimos <code>N</code> igual a <code>26</code> por enquanto, para corresponder √† fun√ß√£o <code>hash</code> padr√£o conforme descrito abaixo. Voc√™ provavelmente desejar√° aumentar isso dependendo de sua pr√≥pria implementa√ß√£o de <code>hash</code>.</p>
<p>Em seguida, observe que implementamos <code>load</code>, <code>check</code>, <code>size</code> e <code>unload</code>, mas apenas o suficiente para o c√≥digo compilar. Observe tamb√©m que implementamos <code>hash</code> com um algoritmo de amostra baseado na primeira letra da palavra. Seu trabalho, em √∫ltima an√°lise, √© reimplementar essas fun√ß√µes da forma mais inteligente poss√≠vel para que este verificador ortogr√°fico funcione conforme anunciado. E r√°pido!</p>
<h4><code>speller.c</code></h4>
<p>Certo, agora abra <code>speller.c</code> e passe um tempo examinando o c√≥digo e os coment√°rios inclu√≠dos. Voc√™ n√£o precisar√° alterar nada neste arquivo e n√£o √© preciso entender a sua totalidade, no entanto, tente entender a sua funcionalidade. Observe como, atrav√©s de uma fun√ß√£o chamada <code>getrusage</code>, n√≥s estaremos "benchmarkando" (ou seja, cronometrando a execu√ß√£o de) as suas implementa√ß√µes de <code>check</code>, <code>load</code>, <code>size</code> e <code>unload</code>. Observe tamb√©m como passamos <code>check</code>, palavra por palavra, o conte√∫do de alguns arquivo a ser verificado. Finalmente, relatamos cada palavra mal escrita naquele arquivo juntamente com um monte de estat√≠sticas.</p>
<p>Observe, incidentalmente, que definimos o uso de <code>speller</code> como:</p>
<pre><code>  Uso: speller [dicion√°rio] texto
</code></pre>
<p>onde <code>dicion√°rio</code> √© assumido como um arquivo contendo uma lista de palavras em min√∫sculas, uma por linha, e <code>texto</code> √© um arquivo a ser verificado. Como as chaves sugerem, fornecer <code>dicion√°rio</code> √© opcional; se este argumento for omitido, <code>speller</code> usar√° <code>diccion√°rios/grande</code> por padr√£o. Em outras palavras, executar</p>
<pre><code>  ./speller texto
</code></pre>
<p>ser√° equivalente a executar</p>
<pre><code>  ./speller dicion√°rios/grande texto
</code></pre>
<p>onde <code>texto</code> √© o arquivo que voc√™ deseja verificar. Basta dizer que o primeiro √© mais f√°cil de digitar! (Claro, <code>speller</code> n√£o ser√° capaz de carregar nenhum dicion√°rio at√© que voc√™ implemente <code>load</code> em <code>dictionary.c</code>! At√© ent√£o, voc√™ ver√° <code>N√£o foi poss√≠vel carregar</code>.)</p>
<p>Dentro do dicion√°rio padr√£o, lembre-se, existem 143.091 palavras, todas as quais devem ser carregadas na mem√≥ria! Na verdade, d√™ uma olhada nesse arquivo para ter uma no√ß√£o de sua estrutura e tamanho. Observe que todas as palavras naquele arquivo aparecem em min√∫sculas (mesmo, para simplificar, nomes pr√≥prios e acr√¥nimos). De cima para baixo, o arquivo √© classificado lexicograficamente, com apenas uma palavra por linha (cada uma terminando com <code>\n</code>). Nenhuma palavra tem mais de 45 caracteres e nenhuma palavra aparece mais de uma vez. Durante o desenvolvimento, voc√™ pode achar √∫til fornecer <code>speller</code> com um <code>dicion√°rio</code> seu pr√≥prio que contenha muito menos palavras, para que voc√™ n√£o tenha dificuldade em depurar uma estrutura enorme na mem√≥ria. Em <code>dicion√°rios/pequeno</code> existe um dicion√°rio assim. Para us√°-lo, execute:</p>
<pre><code>  ./speller dicion√°rios/pequeno texto
</code></pre>
<p>onde <code>texto</code> √© o arquivo que voc√™ deseja verificar. N√£o prossiga at√© ter certeza de que entendeu como o pr√≥prio <code>speller</code> funciona!</p>
<p>Provavelmente, voc√™ n√£o passou tempo suficiente examinando <code>speller.c</code>. Volte uma casa e examine-o novamente!</p>
<h4><code>textos/</code></h4>
<p>Para que voc√™ possa testar sua implementa√ß√£o do <code>speller</code>, tamb√©m fornecemos v√°rios textos, entre eles o roteiro de <em>La La Land</em>, o texto do Affordable Care Act, tr√™s milh√µes de bytes de Tolst√≥i, alguns trechos de <em>The Federalist Papers</em> e Shakespeare e muito mais. Para que voc√™ saiba o que esperar, abra e examine cada um desses arquivos, todos os quais est√£o em um diret√≥rio chamado <code>textos</code> no diret√≥rio <code>pset5</code>.</p>
<p>Agora, como voc√™ deve saber por ter lido cuidadosamente <code>speller.c</code>, a sa√≠da de <code>speller</code>, se executado com, digamos,</p>
<pre><code>  ./speller textos/lalaland.txt
</code></pre>
<p>eventualmente se parecer√° com o abaixo.</p>
<p>Veja a seguir parte da sa√≠da que voc√™ ver√°. Para fins informativos, extra√≠mos alguns exemplos de ‚Äúerros ortogr√°ficos‚Äù. E para n√£o estragar a divers√£o, omitimos nossas pr√≥prias estat√≠sticas por enquanto.</p>
<pre><code>  PALAVRAS COM ERROS DE ORTOGRAFIA

  [...]
  AHHHHHHHHHHHHHHHHHHHHHHHHHHHT
  [...]
  Shangri
  [...]
  noivo
  [...]
  Sebastian
  [...]

  PALAVRAS COM ERROS DE ORTOGRAFIA:
  PALAVRAS NO DICION√ÅRIO:
  PALAVRAS NO TEXTO:
  TEMPO EM load:
  TEMPO EM check:
  TEMPO EM size:
  TEMPO EM unload:
  TEMPO TOTAL:
</code></pre>
<p><code>TEMPO EM load</code> representa o n√∫mero de segundos que <code>speller</code> gasta executando sua implementa√ß√£o de <code>load</code>. <code>TEMPO EM check</code> representa o n√∫mero de segundos que <code>speller</code> gasta, no total, executando sua implementa√ß√£o de <code>check</code>. <code>TEMPO EM size</code> representa o n√∫mero de segundos que <code>speller</code> gasta executando sua implementa√ß√£o de <code>size</code>. <code>TEMPO EM unload</code> representa o n√∫mero de segundos que <code>speller</code> gasta executando sua implementa√ß√£o de <code>unload</code>. <code>TEMPO TOTAL</code> √© a soma dessas quatro medi√ß√µes.</p>
<p><strong>Observe que esses tempos podem variar um pouco entre as execu√ß√µes do <code>speller</code>, dependendo do que mais o seu codespace est√° fazendo, mesmo que voc√™ n√£o altere o seu c√≥digo.</strong></p>
<p>Incidentalmente, para deixar claro, por ‚Äúerro de ortografia‚Äù queremos dizer simplesmente que alguma palavra n√£o est√° no <code>dicion√°rio</code> fornecido.</p>
<h4><code>Makefile</code></h4>
<p>E, por √∫ltimo, lembre-se de que <code>make</code> automatiza a compila√ß√£o do seu c√≥digo para que voc√™ n√£o precise executar <code>clang</code> manualmente junto com um monte de chaves. No entanto, conforme seus programas crescem em tamanho, <code>make</code> n√£o ser√° mais capaz de inferir do contexto como compilar seu c√≥digo; voc√™ precisar√° come√ßar a dizer ao <code>make</code> como compilar seu programa, principalmente quando envolvem v√°rios arquivos de origem (ou seja, <code>.c</code>), como no caso deste problema. Assim, utilizaremos um <code>Makefile</code>, um arquivo de configura√ß√£o que diz ao <code>make</code> exatamente o que fazer. Abra <code>Makefile</code> e voc√™ ver√° quatro linhas:</p>
<ol>
<li>A primeira linha diz ao <code>make</code> para executar as linhas subsequentes sempre que voc√™ executar <code>make speller</code> (ou apenas <code>make</code>).</li>
<li>A segunda linha diz ao <code>make</code> como compilar <code>speller.c</code> para c√≥digo de m√°quina (ou seja, <code>speller.o</code>).</li>
<li>A terceira linha diz ao <code>make</code> como compilar <code>dictionary.c</code> para c√≥digo de m√°quina (ou seja, <code>dictionary.o</code>).</li>
<li>A quarta linha diz ao <code>make</code> para vincular <code>speller.o</code> e <code>dictionary.o</code> em um arquivo chamado <code>speller</code>.</li>
</ol>
<p><strong>Certifique-se de compilar <code>speller</code> executando <code>make speller</code> (ou apenas <code>make</code>). Executar <code>make dictionary</code> n√£o funcionar√°!</strong></p>
<h2>Especifica√ß√£o</h2>
<p>Muito bem, o desafio que voc√™ tem agora √© implementar, em ordem, <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> e <code>unload</code> o mais eficientemente poss√≠vel usando uma tabela hash de tal forma que <code>TIME IN load</code>, <code>TIME IN check</code>, <code>TIME IN size</code> e <code>TIME IN unload</code> sejam todos minimizados. Para ter certeza, n√£o √© √≥bvio o que significa minimizar, uma vez que estes valores de refer√™ncia certamente variar√£o conforme voc√™ alimenta <code>speller</code> com valores diferentes para <code>dictionary</code> e para <code>text</code>. Mas a√≠ reside o desafio, sen√£o a divers√£o, deste problema. Este problema √© a sua chance para projetar. Embora o convidemos a minimizar espa√ßo, seu maior inimigo √© o tempo. Mas antes que voc√™ mergulhe, algumas especifica√ß√µes nossas.</p>
<ul>
<li>Voc√™ n√£o pode alterar <code>speller.c</code> ou <code>Makefile</code>.</li>
<li>Voc√™ pode alterar <code>dictionary.c</code> (e, de fato, deve a fim de completar as implementa√ß√µes de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> e <code>unload</code>), mas voc√™ n√£o pode alterar as declara√ß√µes (ou seja, prot√≥tipos) de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> ou <code>unload</code>. Voc√™ pode, no entanto, adicionar novas fun√ß√µes e vari√°veis (locais ou globais) para <code>dictionary.c</code>.</li>
<li>Voc√™ pode alterar o valor de <code>N</code> em <code>dictionary.c</code>, assim sua tabela hash pode ter mais baldes.</li>
<li>Voc√™ pode alterar <code>dictionary.h</code>, mas n√£o pode alterar as declara√ß√µes de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> ou <code>unload</code>.</li>
<li>Sua implementa√ß√£o de <code>check</code> deve ignorar o caso. Em outras palavras, se <code>foo</code> est√° no dicion√°rio, ent√£o <code>check</code> deve retornar verdadeiro dado qualquer capitaliza√ß√£o dela; nenhuma de <code>foo</code>, <code>foO</code>, <code>fOo</code>, <code>fOO</code>, <code>fOO</code>, <code>Foo</code>, <code>FoO</code>, <code>FOo</code> e <code>FOO</code> deve ser considerada mal escrita.</li>
<li>Tirando a capitaliza√ß√£o, sua implementa√ß√£o de <code>check</code> deve retornar <code>true</code> apenas para palavras que estejam realmente no <code>dicion√°rio</code>. Cuidado com palavras comuns codificadas com for√ßa (p. ex., <code>the</code>), para que n√£o passemos para sua implementa√ß√£o um <code>dicion√°rio</code> sem essas mesmas palavras. Al√©m disso, os √∫nicos possessivos permitidos s√£o aqueles realmente no <code>dicion√°rio</code>. Em outras palavras, mesmo que <code>foo</code> esteja no <code>dicion√°rio</code>, <code>check</code> deve retornar <code>false</code> dado <code>foo's</code> se <code>foo's</code> tamb√©m n√£o estiver no <code>dicion√°rio</code>.</li>
<li>Voc√™ pode assumir que qualquer <code>dicion√°rio</code> passado ao seu programa ser√° estruturado exatamente como o nosso, ordenado alfabeticamente de cima para baixo com uma palavra por linha, cada uma das quais termina com <code>\n</code>. Voc√™ tamb√©m pode assumir que <code>dictionary</code> conter√° pelo menos uma palavra, que nenhuma palavra ter√° mais de caracteres <code>LENGTH</code> (uma constante definida em <code>dictionary.h</code>), que nenhuma palavra aparecer√° mais de uma vez, que cada palavra conter√° apenas caracteres alfab√©ticos min√∫sculos e, possivelmente, ap√≥strofos, e que nenhuma palavra come√ßar√° com ap√≥strofo.</li>
<li>Voc√™ pode assumir que <code>check</code> s√≥ receber√° palavras que contenham caracteres alfab√©ticos (mai√∫sculos ou min√∫sculos) e, possivelmente, ap√≥strofos.</li>
<li>Seu corretor ortogr√°fico pode receber apenas <code>text</code> e <code>dictionary</code> como entrada. Embora voc√™ possa estar inclinado (particularmente se for mais confort√°vel) a ‚Äúpr√©-processar‚Äù nosso dicion√°rio padr√£o a fim de derivar uma ‚Äúfun√ß√£o hash ideal‚Äù para ele, voc√™ n√£o pode salvar a sa√≠da de nenhum desses pr√©-processamento em disco para carreg√°-la de volta na mem√≥ria em execu√ß√µes subsequentes do seu corretor ortogr√°fico para obter vantagem.</li>
<li>Seu corretor ortogr√°fico n√£o deve vazar nenhuma mem√≥ria. Certifique-se de verificar vazamentos com <code>valgrind</code>.</li>
<li><strong>A fun√ß√£o hash que voc√™ escreve deve ser sua, n√£o uma que voc√™ procure online.</strong></li>
</ul>
<p>Muito bem, pronto para come√ßar?</p>
<ul>
<li>Implemente o <code>load</code>.</li>
<li>Implemente o <code>hash</code>.</li>
<li>Implemente o <code>size</code>.</li>
<li>Implemente o <code>check</code>.</li>
<li>Implemente o <code>unload</code>.</li>
</ul>
<h2>Dicas</h2>
<h3>Implemente o <code>load</code></h3>
<p>Complete a fun√ß√£o <code>load</code>. <code>load</code> deve carregar o dicion√°rio na mem√≥ria (em particular, em uma tabela hash!). <code>load</code> deve retornar <code>true</code> se for bem-sucedido e <code>false</code> em caso contr√°rio.</p>
<p>Considere que este problema √© composto apenas de problemas menores:</p>
<ol>
<li>Abra o arquivo do dicion√°rio</li>
<li>Leia cada palavra no arquivo
    1. Adicione cada palavra na tabela hash</li>
<li>Feche o arquivo do dicion√°rio</li>
</ol>
<p>Escreva algum pseudoc√≥digo para se lembrar de fazer exatamente isso:</p>
<pre><code>  bool load(const char *dictionary)
  {
      // Abra o arquivo do dicion√°rio

      // Leia cada palavra no arquivo

          // Adicione cada palavra na tabela hash

      // Feche o arquivo do dicion√°rio
  }
</code></pre>
<p>Considere primeiro como abrir o arquivo do dicion√°rio. <a href="https://manual.cs50.io/3/fopen"><code>fopen</code></a> √© uma escolha natural. Voc√™ pode usar o modo <code>r</code>, dado que precisa apenas <em>ler</em> palavras no arquivo do dicion√°rio (n√£o <em>escrever</em> ou <em>acrescentar</em> elas).</p>
<pre><code>  bool load(const char *dictionary)
  {
      // Abra o arquivo do dicion√°rio
      FILE *source = fopen(dictionary, "r");

      // Leia cada palavra no arquivo

          // Adicione cada palavra na tabela hash

      // Feche o arquivo do dicion√°rio
  }
</code></pre>
<p>Antes de continuar, voc√™ deve escrever o c√≥digo para verificar se o arquivo foi aberto corretamente. Isso depende de voc√™! Tamb√©m √© melhor garantir que voc√™ feche todos os arquivos que abrir, ent√£o agora √© um bom momento para escrever o c√≥digo para fechar o arquivo do dicion√°rio:</p>
<pre><code>  bool load(const char *dictionary)
  {
      // Abra o arquivo do dicion√°rio
      FILE *source = fopen(dictionary, "r");

      // Leia cada palavra no arquivo

          // Adicione cada palavra na tabela hash

      // Feche o arquivo do dicion√°rio
      fclose(source);
  }
</code></pre>
<p>O que resta √© ler cada palavra no arquivo e adicionar cada palavra na tabela hash. Retorne <code>true</code> quando toda a opera√ß√£o for bem-sucedida e <code>false</code> se falhar. Considere seguir o passo a passo deste problema e continuar a dividir os subproblemas em problemas menores ainda. Por exemplo, adicionar cada palavra na tabela hash pode ser apenas uma quest√£o de implementar alguns passos menores ainda:</p>
<ol>
<li>Crie espa√ßo para um novo n√≥ da tabela hash</li>
<li>Copie a palavra no novo n√≥</li>
<li>Hash a palavra para obter seu valor hash</li>
<li>Insira o novo n√≥ na tabela hash (usando o √≠ndice especificado pelo seu valor hash)</li>
</ol>
<p>Claro, h√° mais de uma maneira de abordar este problema, com suas pr√≥prias compensa√ß√µes de design. Por esse motivo, o restante do c√≥digo fica a seu crit√©rio!</p>
<h3>Implemente o <code>hash</code></h3>
<p>Complete a fun√ß√£o <code>hash</code>. <code>hash</code> deve pegar uma string, <code>word</code>, como entrada e retornar um <code>int</code> ‚Äún√£o assinado‚Äù positivo.</p>
<p>A fun√ß√£o hash fornecida a voc√™ retorna um <code>int</code> entre 0 e 25, inclusive, com base no primeiro caractere de <code>word</code>. No entanto, h√° muitas maneiras de implementar uma fun√ß√£o hash al√©m de usar o primeiro caractere (ou <em>caracteres</em>) de uma palavra. Considere uma fun√ß√£o hash que use uma soma de valores ASCII ou o tamanho de uma palavra. Uma boa fun√ß√£o hash reduz ‚Äúcolis√µes‚Äù e tem uma distribui√ß√£o (na maior parte!) uniforme entre os ‚Äúbaldes‚Äù da tabela hash.</p>
<h3>Implementando <code>size</code></h3>
<p>Complete a fun√ß√£o <code>size</code>. <code>size</code> deve retornar o n√∫mero de palavras carregadas no dicion√°rio. Considere duas abordagens para este problema:</p>
<ul>
<li>Conte cada palavra na medida em que ela for carregada no dicion√°rio. Retorne essa contagem quando <code>size</code> for chamada.</li>
<li>A cada vez que <code>size</code> for chamada, itere pelas palavras na tabela hash para cont√°-las. Retorne essa contagem.</li>
</ul>
<p>Qual parece mais eficiente para voc√™? Independente do que voc√™ escolher, deixaremos o c√≥digo por sua conta.</p>
<h3>Implementando <code>check</code></h3>
<p>Complete a fun√ß√£o <code>check</code>. <code>check</code> deve retornar <code>true</code> se uma palavra for localizada no dicion√°rio, caso contr√°rio <code>false</code>.</p>
<p>Considere que este problema tamb√©m √© composto por problemas menores. Se voc√™ implementou uma tabela hash, encontrar uma palavra leva apenas alguns passos:</p>
<ol>
<li>Fa√ßa o hash da palavra para obter o seu valor de hash</li>
<li>Pesquise a tabela hash na localiza√ß√£o especificada pelo valor de hash da palavra
    1. Retorne <code>true</code> se a palavra for encontrada</li>
<li>Retorne <code>false</code> se nenhuma palavra for encontrada</li>
</ol>
<p>Para comparar duas strings sem distin√ß√£o de mai√∫sculas e min√∫sculas, voc√™ pode achar √∫til <a href="https://man.cs50.io/3/strcasecmp"><code>strcasecmp</code></a> (declarado em <code>strings.h</code>)! Voc√™ provavelmente tamb√©m desejar√° garantir que sua fun√ß√£o hash n√£o fa√ßa distin√ß√£o entre mai√∫sculas e min√∫sculas, de modo que <code>foo</code> e <code>FOO</code> tenham o mesmo valor de hash.</p>
<h3>Implementando <code>unload</code></h3>
<p>Complete a fun√ß√£o <code>unload</code>. Certifique-se de <code>free</code> em <code>unload</code> qualquer mem√≥ria que tenha sido alocada em <code>load</code>!</p>
<p>Lembre-se de que o <code>valgrind</code> √© o seu melhor amigo de agora em diante. Saiba que o <code>valgrind</code> observa se h√° vazamentos enquanto o seu programa est√° realmente em execu√ß√£o, portanto certifique-se de fornecer argumentos de linha de comando se quiser que o <code>valgrind</code> analise o <code>speller</code> enquanto voc√™ usa um <code>dicion√°rio</code> e/ou texto espec√≠fico, como o abaixo. √â melhor usar um texto pequeno, entretanto, sen√£o o <code>valgrind</code> pode levar um bom tempo para rodar.</p>
<pre><code>  valgrind ./speller texts/cat.txt
</code></pre>
<p>Se voc√™ executar o <code>valgrind</code> sem especificar um <code>texto</code> para o <code>speller</code>, suas implementa√ß√µes de <code>load</code> e <code>unload</code> n√£o ser√£o realmente chamadas (e, portanto, analisadas).</p>
<p>Se n√£o tiver certeza de como interpretar o output do <code>valgrind</code>, basta pedir ajuda ao <code>help50</code>:</p>
<pre><code>  help50 valgrind ./speller texts/cat.txt
</code></pre>
<h2>Guia</h2>
<div class="alert alert-danger" data-alert="danger" role="alert"><p><strong>Observe que h√° 6 v√≠deos nesta lista de reprodu√ß√£o.</strong></p></div>

<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/_z57x5PGF4w?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T382T4b6jjwX_qbU23E_Unwcz"></iframe></div>

<h2>Como testar</h2>
<p>Como verificar se o seu programa est√° exibindo as palavras erradas? Bem, voc√™ pode consultar as "chaves de respostas" que est√£o dentro do diret√≥rio <code>keys</code> que est√° dentro do seu diret√≥rio <code>speller</code>. Por exemplo, dentro de <code>keys/lalaland.txt</code> est√£o todas as palavras que o seu programa <em>deveria</em> considerar erradas.</p>
<p>Portanto, voc√™ pode executar o seu programa em algum texto em uma janela, como abaixo:</p>
<pre><code>  ./speller texts/lalaland.txt
</code></pre>
<p>E voc√™ pode ent√£o executar a solu√ß√£o da equipe no mesmo texto em outra janela, como abaixo:</p>
<pre><code>  ./speller50 texts/lalaland.txt
</code></pre>
<p>E ent√£o voc√™ pode comparar as janelas visualmente lado a lado. Isso pode se tornar tedioso rapidamente. Ent√£o, voc√™ pode querer "redirecionar" o output do seu programa para um arquivo, como abaixo:</p>
<pre><code>  ./speller texts/lalaland.txt &gt; student.txt
  ./speller50 texts/lalaland.txt &gt; staff.txt
</code></pre>
<p>Voc√™ pode ent√£o comparar os dois arquivos lado a lado na mesma janela com um programa como <code>diff</code>, como abaixo:</p>
<pre><code>  diff -y student.txt staff.txt
</code></pre>
<p>Alternativamente, para economizar tempo, voc√™ pode simplesmente comparar o output do seu programa (assumindo que voc√™ redirecionou para, por exemplo, <code>student.txt</code>) com uma das chaves de resposta sem executar a solu√ß√£o da equipe, como abaixo:</p>
<pre><code>  diff -y student.txt keys/lalaland.txt
</code></pre>
<p>Se o output do seu programa corresponder ao da equipe, o <code>diff</code> exibir√° duas colunas que devem ser id√™nticas, exceto, talvez, pelos tempos de execu√ß√£o na parte inferior. Se as colunas forem diferentes, voc√™ ver√° um <code>&gt;</code> ou <code>|</code> onde elas diferem. Por exemplo, se voc√™ vir</p>
<pre><code>  MISSPELLED WORDS                                                MISSPELLED WORDS

  TECHNO                                                          TECHNO
  L                                                               L
                                                                &gt; Thelonious
  Prius                                                           Prius
                                                                &gt; MIA
  L                                                               L
</code></pre>
<p>isso significa que o seu programa (cujo output est√° √† esquerda) n√£o considera <code>Thelonious</code> ou <code>MIA</code> com erros, embora o output da equipe (√† direita) considere, como √© impl√≠cito pela aus√™ncia de, digamos, <code>Thelonious</code> na coluna da esquerda e pela presen√ßa de <code>Thelonious</code> na coluna da direita.</p>
<p>Por fim, certifique-se de testar com os dicion√°rios padr√£o grande e pequeno. Tenha cuidado para n√£o presumir que se a sua solu√ß√£o for executada com sucesso com o dicion√°rio grande, ela tamb√©m ser√° executada com sucesso com o pequeno. Veja como tentar o dicion√°rio pequeno:</p>
<pre><code>  ./speller dictionaries/small texts/cat.txt
</code></pre>
<h3>Corre√ß√£o</h3>
<pre><code>  check50 cs50/problems/2024/x/speller
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 dictionary.c
</code></pre>
<h2>Solu√ß√£o da equipe</h2>
<p>Como avaliar qu√£o r√°pido (e correto) o seu c√≥digo √©? Bem, como sempre, sinta-se √† vontade para mexer com a solu√ß√£o da equipe, como abaixo, e comparar os seus n√∫meros com os seus.</p>
<pre><code>  ./speller50 texts/lalaland.txt
</code></pre>
<h2>Como enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/speller
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>