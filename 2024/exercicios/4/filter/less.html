<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Filtro</h2>
<p><img alt="Harvard Yard em escala de cinza" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/yard-grayscale.bmp" /></p>
<h2>Problema a resolver</h2>
<p>Talvez a maneira mais simples de representar uma imagem seja com uma grade de pixels (ou seja, pontos), cada um dos quais pode ser de uma cor diferente. Para imagens em preto e branco, precisamos, portanto, de 1 bit por pixel, pois 0 poderia representar preto e 1 poderia representar branco, como abaixo.</p>
<p><img alt="um bitmap simples" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/bitmap.png" /></p>
<p>Nesse sentido, ent√£o, uma imagem √© apenas um bitmap (ou seja, um mapa de bits). Para imagens mais coloridas, voc√™ simplesmente precisa de mais bits por pixel. Um formato de arquivo (como <a href="https://en.wikipedia.org/wiki/BMP_file_format">BMP</a>, <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a> ou <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>) que suporte "cores de 24 bits" usa 24 bits por pixel. (O BMP na verdade suporta cores de 1, 4, 8, 16, 24 e 32 bits.)</p>
<p>Um BMP de 24 bits usa 8 bits para significar a quantidade de vermelho na cor de um pixel, 8 bits para significar a quantidade de verde na cor de um pixel e 8 bits para significar a quantidade de azul na cor de um pixel. Se voc√™ j√° ouviu falar da cor RGB, bem, a√≠ est√°: vermelho, verde, azul.</p>
<p>Se os valores R, G e B de algum pixel em um BMP s√£o, digamos, <code>0xff</code>, <code>0x00</code> e <code>0x00</code> em hexadecimal, aquele pixel √© puramente vermelho, pois <code>0xff</code> (tamb√©m conhecido como <code>255</code> em decimal) implica "muito vermelho", enquanto <code>0x00</code> e <code>0x00</code> implicam "sem verde" e "sem azul", respectivamente. Neste problema, voc√™ manipular√° esses valores R, G e B de pixels individuais, criando, em √∫ltima an√°lise, seus pr√≥prios filtros de imagem.</p>
<p>Em um arquivo chamado <code>helpers.c</code> em uma pasta chamada <code>filter-less</code>, escreva um programa para aplicar filtros em BMPs.</p>
<h2>Demonstra√ß√£o</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-QnLel70SPmbW9nswXTb9Yu9ZD" src="https://asciinema.org/a/QnLel70SPmbW9nswXTb9Yu9ZD.js"></script>

<h2>C√≥digo de distribui√ß√£o</h2>
<p>Para este problema, voc√™ estender√° a funcionalidade do c√≥digo fornecido a voc√™ pela equipe do CS50.</p>
<p>Fa√ßa login em <a href="https://cs50.dev/">cs50.dev</a>, clique na janela do terminal e execute <code>cd</code> sozinho. Voc√™ deve descobrir que o prompt da janela do seu terminal se assemelha ao seguinte:</p>
<pre><code>  $
</code></pre>
<p>Em seguida, execute</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/filter-less.zip
</code></pre>
<p>para baixar um ZIP chamado <code>filter-less.zip</code> em seu espa√ßo de c√≥digo.</p>
<p>Ent√£o execute</p>
<pre><code>  unzip filter-less.zip
</code></pre>
<p>para criar uma pasta chamada <code>filter-less</code>. Voc√™ n√£o precisa mais do arquivo ZIP, ent√£o voc√™ pode executar</p>
<pre><code>  rm filter-less.zip
</code></pre>
<p>e responda com ‚Äúy‚Äù seguido de Enter no prompt para remover o arquivo ZIP que voc√™ baixou.</p>
<p>Agora digite</p>
<pre><code>  cd filter-less
</code></pre>
<p>seguido por Enter para se mover (ou seja, abrir) aquele diret√≥rio. Seu prompt agora deve se assemelhar ao seguinte.</p>
<pre><code>  filter-less/ $
</code></pre>
<p>Execute <code>ls</code> sozinho e voc√™ ver√° alguns arquivos: <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code> e <code>Makefile</code>. Voc√™ tamb√©m ver√° uma pasta, <code>images/</code>, com quatro arquivos BMP. Se voc√™ tiver algum problema, siga os mesmos passos novamente e veja se consegue determinar em que errou!</p>
<h2>Hist√≥rico</h2>
<h3>Um pouco(mapa) mais t√©cnico</h3>
<p>Lembre-se de que um arquivo √© apenas uma sequ√™ncia de bits, organizados de alguma forma. Um arquivo BMP de 24 bits, ent√£o, √© essencialmente apenas uma sequ√™ncia de bits, (quase) cada 24 dos quais representam a cor de algum pixel. Mas um arquivo BMP tamb√©m cont√©m alguns "metadados", informa√ß√µes como a altura e a largura de uma imagem. Esses metadados s√£o armazenados no in√≠cio do arquivo na forma de duas estruturas de dados geralmente chamadas de "cabe√ßalhos", que n√£o devem ser confundidas com os arquivos de cabe√ßalho do C. (Ali√°s, esses cabe√ßalhos evolu√≠ram ao longo do tempo. Este problema usa a √∫ltima vers√£o do formato BMP da Microsoft, 4.0, que estreou com o Windows 95.)</p>
<p>O primeiro desses cabe√ßalhos, chamado <code>BITMAPFILEHEADER</code>, tem 14 bytes de comprimento. (Lembre-se de que 1 byte √© igual a 8 bits.) O segundo desses cabe√ßalhos, chamado <code>BITMAPINFOHEADER</code>, tem 40 bytes de comprimento. Imediatamente ap√≥s esses cabe√ßalhos est√° o bitmap real: uma matriz de bytes, triplos dos quais representam a cor de um pixel. No entanto, o BMP armazena esses triplos ao contr√°rio (ou seja, como BGR), com 8 bits para azul, seguidos por 8 bits para verde e 8 bits para vermelho. (Alguns BMPs tamb√©m armazenam o bitmap inteiro ao contr√°rio, com a primeira linha da imagem no final do arquivo BMP. Mas n√≥s armazenamos os BMPs deste conjunto de problemas conforme descrito aqui, com a primeira linha de cada bitmap primeiro e a √∫ltima linha por √∫ltimo .) Em outras palavras, se convert√™ssemos o smiley de 1 bit acima para um smiley de 24 bits, substituindo o vermelho pelo preto, um BMP de 24 bits armazenaria este bitmap da seguinte forma, onde <code>0000ff</code> significa vermelho e <code>ffffff</code> significa branco; destacamos em vermelho todas as inst√¢ncias de <code>0000ff</code>.</p>
<p><img alt="sorriso vermelho" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/red_smile.png" /></p>
<p>Como apresentamos esses bits da esquerda para a direita, de cima para baixo, em 8 colunas, voc√™ pode realmente ver o smiley vermelho se der um passo para tr√°s.</p>
<p>Para ser claro, lembre-se de que um d√≠gito hexadecimal representa 4 bits. Consequentemente, <code>ffffff</code> em hexadecimal na verdade significa <code>111111111111111111111111</code> em bin√°rio.</p>
<p>Observe que voc√™ poderia representar um bitmap como uma matriz bidimensional de pixels: onde a imagem √© uma matriz de linhas, cada linha √© uma matriz de pixels. De fato, √© assim que escolhemos representar imagens de bitmap neste problema.</p>
<h3>Filtragem de Imagem</h3>
<p>O que significa filtrar uma imagem? Voc√™ pode pensar em filtrar uma imagem como pegar os pixels de alguma imagem original e modificar cada pixel de tal forma que um efeito particular seja aparente na imagem resultante.</p>
<h2>Entendendo</h2>
<p>Vamos agora dar uma olhada em alguns dos arquivos fornecidos a voc√™ como c√≥digo de distribui√ß√£o para entender o que h√° dentro deles.</p>
<h3><code>bmp.h</code></h3>
<p>Abra <code>bmp.h</code> (clicando duas vezes nele no navegador de arquivos) e d√™ uma olhada.</p>
<p>Voc√™ ver√° as defini√ß√µes dos cabe√ßalhos que mencionamos (<code>BITMAPINFOHEADER</code> e <code>BITMAPFILEHEADER</code>). Al√©m disso, esse arquivo define <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code> e <code>WORD</code>, tipos de dados normalmente encontrados no mundo da programa√ß√£o do Windows. Observe como eles s√£o apenas apelidos para primitivas com as quais voc√™ (espero) j√° est√° familiarizado. Parece que <code>BITMAPFILEHEADER</code> e <code>BITMAPINFOHEADER</code> fazem uso desses tipos.</p>
<p>Talvez o mais importante para voc√™, este arquivo tamb√©m define uma <code>struct</code> chamada <code>RGBTRIPLE</code> que, muito simplesmente, "encapsula" tr√™s bytes: um azul, um verde e um vermelho (a ordem, lembre-se, na qual esperamos encontrar os triplos RGB realmente no disco).</p>
<p>Por que essas <code>structs</code> s√£o √∫teis? Bem, lembre-se de que um arquivo √© apenas uma sequ√™ncia de bytes (ou, em √∫ltima an√°lise, bits) no disco. Mas esses bytes s√£o geralmente ordenados de tal forma que os primeiros representam algo, os pr√≥ximos representam outra coisa e assim por diante. "Formatos de arquivo" existem porque o mundo padronizou o que os bytes significam. Agora, poder√≠amos simplesmente ler um arquivo do disco para a RAM como um grande array de bytes. E poder√≠amos apenas lembrar que o byte em <code>array[i]</code> representa uma coisa, enquanto o byte em <code>array[j]</code> representa outra. Mas por que n√£o dar a alguns desses bytes nomes para que possamos recuper√°-los da mem√≥ria mais facilmente? Isso √© precisamente o que as structs em <code>bmp.h</code> nos permitem fazer. Em vez de pensar em algum arquivo como uma longa sequ√™ncia de bytes, podemos pensar nele como uma sequ√™ncia de <code>structs</code>.</p>
<h3><code>filter.c</code></h3>
<p>Agora, vamos abrir <code>filter.c</code>. Este arquivo j√° foi escrito para voc√™, mas h√° alguns pontos importantes dignos de nota aqui.</p>
<p>Primeiro, observe a defini√ß√£o de <code>filters</code> na linha 10. Essa string informa ao programa quais s√£o os argumentos de linha de comando permitidos para o programa: <code>b</code>, <code>g</code>, <code>r</code> e <code>s</code>. Cada um deles especifica um filtro diferente que podemos aplicar √†s nossas imagens: desfoque, tons de cinza, reflexo e s√©pia.</p>
<p>As pr√≥ximas linhas abrem um arquivo de imagem, certificam-se de que √© realmente um arquivo BMP e l√™em todas as informa√ß√µes de pixel em um array 2D chamado <code>image</code>.</p>
<p>Role para baixo at√© a instru√ß√£o <code>switch</code> que come√ßa na linha 101. Observe que, dependendo de qual <code>filter</code> escolhemos, uma fun√ß√£o diferente √© chamada: se o usu√°rio escolher o filtro <code>b</code>, o programa chama a fun√ß√£o <code>blur</code>; se <code>g</code>, ent√£o <code>graycale</code> √© chamado; se <code>r</code>, ent√£o <code>reflect</code> √© chamado; e se <code>s</code>, ent√£o <code>sepia</code> √© chamado. Observe tamb√©m que cada uma dessas fun√ß√µes recebe como argumentos a altura da imagem, a largura da imagem e a matriz 2D de pixels.</p>
<p>Estas s√£o as fun√ß√µes que voc√™ (em breve!) implementar√°. Como voc√™ pode imaginar, o objetivo √© que cada uma dessas fun√ß√µes edite a matriz 2D de pixels de forma que o filtro desejado seja aplicado √† imagem.</p>
<p>As demais linhas do programa pegam a <code>image</code> resultante e as escrevem em um novo arquivo de imagem.</p>
<h3><code>helpers.h</code></h3>
<p>Em seguida, d√™ uma olhada em <code>helpers.h</code>. Este arquivo √© bem curto e apenas fornece os prot√≥tipos de fun√ß√£o para as fun√ß√µes que voc√™ viu anteriormente.</p>
<p>Aqui, observe o fato de que cada fun√ß√£o recebe um array 2D chamado <code>image</code> como argumento, onde <code>image</code> √© um array de <code>height</code> de linhas e cada linha √© outro array de <code>width</code> de <code>RGBTRIPLE</code>s. Ent√£o, se <code>image</code> representa a imagem inteira, ent√£o <code>image[0]</code> representa a primeira linha e <code>image[0][0]</code> representa o pixel no canto superior esquerdo da imagem.</p>
<h3><code>helpers.c</code></h3>
<p>Agora, abra <code>helpers.c</code>. Aqui √© onde ficam as implementa√ß√µes das fun√ß√µes declaradas em <code>helpers.h</code>. Mas note que, agora, as implementa√ß√µes est√£o ausentes! Esta parte √© sua responsabilidade.</p>
<h3><code>Makefile</code></h3>
<p>Finalmente, vamos ver <code>Makefile</code>. Este arquivo especifica o que deve acontecer quando executamos um comando de terminal como <code>make filter</code>. Considerando que os programas que voc√™ pode ter escrito antes estavam confinados a um √∫nico arquivo, <code>filter</code> parece usar v√°rios arquivos: <code>filter.c</code> e <code>helpers.c</code>. Portanto, precisaremos dizer ao <code>make</code> como compilar este arquivo.</p>
<p>Tente compilar <code>filter</code> por voc√™ mesmo indo at√© seu terminal e executando</p>
<pre><code>  $ make filter
</code></pre>
<p>Ent√£o, voc√™ pode executar o programa executando:</p>
<pre><code>  $ ./filter -g images/jardim.bmp saida.bmp
</code></pre>
<p>que pega a imagem em <code>images/jardim.bmp</code> e gera uma nova imagem chamada <code>saida.bmp</code> ap√≥s executar os pixels pela fun√ß√£o <code>grayscale</code> (escala de cinza). No entanto, <code>grayscale</code> ainda n√£o faz nada, ent√£o a imagem de sa√≠da deve parecer igual ao jardim original.</p>
<h2>Especifica√ß√£o</h2>
<p>Implemente as fun√ß√µes em <code>helpers.c</code> para que um usu√°rio possa aplicar filtros de escala de cinza, s√©pia, reflex√£o ou desfoque √†s suas imagens.</p>
<ul>
<li>A fun√ß√£o <code>grayscale</code> (escala de cinza) deve receber uma imagem e transform√°-la em uma vers√£o em preto e branco da mesma imagem.</li>
<li>A fun√ß√£o <code>sepia</code> deve receber uma imagem e transform√°-la em uma vers√£o s√©pia da mesma imagem.</li>
<li>A fun√ß√£o <code>reflect</code> deve receber uma imagem e refleti-la horizontalmente.</li>
<li>Finalmente, a fun√ß√£o <code>blur</code> deve receber uma imagem e transform√°-la em uma vers√£o desfocada da mesma imagem.</li>
</ul>
<p>Voc√™ n√£o deve modificar nenhuma das assinaturas de fun√ß√£o, nem deve modificar nenhum outro arquivo al√©m de <code>helpers.c</code>.</p>
<h2>Dicas</h2>
<h3>Implementar <code>grayscale</code></h3>
<p>Um filtro comum √© o filtro "escala de cinza", onde pegamos uma imagem e queremos convert√™-la em preto e branco. Como isso funciona?</p>
<ul>
<li>Lembre-se de que se os valores de vermelho, verde e azul forem todos definidos como <code>0x00</code> (hexadecimal para <code>0</code>), o pixel ficar√° preto. E se todos os valores forem definidos como <code>0xff</code> (hexadecimal para <code>255</code>), o pixel ficar√° branco. Contanto que os valores de vermelho, verde e azul sejam todos iguais, o resultado ser√° v√°rios tons de cinza no espectro preto e branco, com valores mais altos significando tons mais claros (mais pr√≥ximos ao branco) e valores mais baixos significando tons mais escuros (mais pr√≥ximos ao preto).</li>
<li>Ent√£o, para converter um pixel em escala de cinza, voc√™ s√≥ precisa garantir que os valores de vermelho, verde e azul sejam todos o mesmo valor. Mas como voc√™ sabe qual valor definir para eles? Bem, provavelmente √© razo√°vel esperar que, se os valores originais de vermelho, verde e azul forem todos muito altos, o novo valor tamb√©m deva ser muito alto. E se os valores originais fossem todos baixos, o novo valor tamb√©m deveria ser baixo.</li>
<li>Na verdade, para garantir que cada pixel da nova imagem ainda tenha o mesmo brilho ou escurid√£o geral da imagem antiga, voc√™ pode fazer a <strong>m√©dia</strong> dos valores vermelho, verde e azul para determinar em que tom de cinza fazer o novo pixel.</li>
</ul>
<p>Se voc√™ aplicar o algoritmo acima a cada pixel da imagem, o resultado ser√° uma imagem convertida para escala de cinza. Escreva algum pseudoc√≥digo para ajud√°-lo a resolver esse problema.</p>
<pre><code>  void grayscale(int altura, int largura, RGBTRIPLE imagem[altura][largura])
  {
      // Loop em todos os pixels

          // Faz a m√©dia de vermelho, verde e azul

          // Atualiza os valores dos pixels
  }
</code></pre>
<p>Primeiro, como voc√™ pode percorrer todos os pixels? Lembre-se de que os pixels da imagem s√£o armazenados na matriz bidimensional <code>image</code>. Para iterar sobre uma matriz bidimensional, voc√™ precisar√° de dois loops, um aninhado dentro do outro.</p>
<pre><code>  void grayscale(int altura, int largura, RGBTRIPLE imagem[altura][largura])
  {
      // Loop em todos os pixels
      for (int i = 0; i &lt; altura; i++)
      {
          for (int j = 0; j &lt; largura; j++)
          {
              // Faz a m√©dia de vermelho, verde e azul

              // Atualiza os valores dos pixels
          }
      }
  }
</code></pre>
<p>Agora, voc√™ pode usar <code>image[i][j]</code> para acessar qualquer pixel individual da imagem. Mas como obter a m√©dia dos elementos vermelho, verde e azul? Lembre-se de que cada elemento de <code>image</code> √© um <code>RGBTRIPLE</code>, que √© a <code>struct</code> definida em <code>bmp.h</code> para representar um pixel. A sintaxe usual para acessar membros de uma <code>struct</code> se aplica, em que <code>image[i][j].rgbtRed</code> lhe dar√° acesso ao valor vermelho do <code>RGBTRIPLE</code>, <code>image[i][j].rgbtGreen</code> lhe dar√° acesso ao seu valor verde e assim por diante.</p>
<p>Ao calcular a m√©dia, lembre-se de que os valores dos componentes <code>rgbtRed</code>, <code>rgbtGreen</code> e <code>rgbtBlue</code> de um pixel s√£o todos inteiros. Portanto, certifique-se de <a href="https://manual.cs50.io/3/round">arredondar</a> quaisquer n√∫meros de ponto flutuante para o inteiro mais pr√≥ximo ao atribu√≠-los a um valor de pixel! E por que voc√™ pode querer dividir a soma desses inteiros por 3,0 e n√£o por 3?</p>
<p>Depois de calcular a m√©dia dos valores vermelho, verde e azul do pixel em uma √∫nica cor de escala de cinza resultante, v√° em frente e atualize os valores vermelho, verde e azul do pixel. A esta altura, voc√™ j√° est√° familiarizado com a sintaxe de atribui√ß√£o!</p>
<h3>Implementando <code>sepia</code></h3>
<p>A maioria dos programas de edi√ß√£o de imagem suporta um filtro "s√©pia", que d√° √†s imagens uma sensa√ß√£o antiga ao fazer com que toda a imagem pare√ßa um pouco marrom avermelhada.</p>
<ul>
<li>Uma imagem pode ser convertida em s√©pia pegando cada pixel e calculando novos valores vermelho, verde e azul com base nos valores originais dos tr√™s.</li>
<li>
<p>H√° uma s√©rie de algoritmos para converter uma imagem em s√©pia, mas para este problema, pediremos que voc√™ use o seguinte algoritmo. Para cada pixel, os valores da cor s√©pia devem ser calculados com base nos valores da cor original conforme abaixo.
<code>sepiaRed = .393 _ originalRed + .769 _ originalGreen + .189 _ originalBlue
sepiaGreen = .349 _ originalRed + .686 _ originalGreen + .168 _ originalBlue
sepiaBlue = .272 _ originalRed + .534 _ originalGreen + .131 \* originalBlue</code></p>
</li>
<li>
<p>Claro, o resultado de cada uma dessas f√≥rmulas pode n√£o ser um n√∫mero inteiro, mas cada valor pode ser arredondado para o n√∫mero inteiro mais pr√≥ximo. Tamb√©m √© poss√≠vel que o resultado da f√≥rmula seja um n√∫mero maior que 255, o valor m√°ximo para um valor de cor de 8 bits. Nesse caso, os valores vermelho, verde e azul devem ser limitados a 255. Como resultado, podemos garantir que os valores vermelho, verde e azul resultantes ser√£o n√∫meros inteiros entre 0 e 255, inclusive.</p>
</li>
</ul>
<p>Escreva um pseudoc√≥digo para ajud√°-lo a resolver este problema e relembre o uso de <code>for</code> aninhados para visitar cada pixel.</p>
<p>```
void sepia(int height, int width, RGBTRIPLE image[height][width])
{
    // Loop sobre todos os pixels
    for (int i = 0; i &lt; height; i++)
    {
        for (int j = 0; j &lt; width; j++)
        {
            // Calcula valores de s√©pia</p>
<pre><code>          // Atualiza pixel com valores de s√©pia
      }
  }
</code></pre>
<p>}
```</p>
<p>Para calcular os valores <code>sepia</code>, revise os marcadores acima. Voc√™ tem uma f√≥rmula para calcular os valores de s√©pia, mas ainda h√° alguns detalhes a serem considerados. Em particular, voc√™ precisar√°...</p>
<ul>
<li>Arredondar o resultado de cada c√°lculo para o n√∫mero inteiro mais pr√≥ximo</li>
<li>Garantir que o valor resultante n√£o seja maior que 255</li>
</ul>
<p>Como uma fun√ß√£o que retorna o menor de dois inteiros pode ser √∫til ao implementar <code>sepia</code>, particularmente quando voc√™ precisa garantir que o valor de uma cor n√£o seja maior que 255? Fique √† vontade para escrever uma fun√ß√£o auxiliar para fazer exatamente isso!</p>
<h3>Implementando <code>reflect</code></h3>
<p>Alguns filtros tamb√©m podem mover pixels para outros lugares. Inverter uma imagem, por exemplo, √© um filtro em que a imagem resultante √© o que voc√™ obteria se colocasse a imagem original na frente de um espelho.</p>
<ul>
<li>Quaisquer pixels no lado esquerdo da imagem devem terminar no lado direito e vice-versa.</li>
<li>Observe que todos os pixels originais da imagem original ainda estar√£o presentes na imagem refletida, apenas esses pixels podem ter sido reorganizados para estarem em um lugar diferente na imagem.</li>
</ul>
<p>Assim, na fun√ß√£o <code>reflect</code>, voc√™ precisar√° trocar os valores dos pixels em lados opostos de uma linha. Escreva um pseudoc√≥digo para ajud√°-lo a come√ßar:</p>
<p><code>void reflect(int height, int width, RGBTRIPLE image[height][width])
{
    // Loop sobre todos os pixels
    for (int i = 0; i &lt; height; i++)
    {
        for (int j = 0; j &lt; width; j++)
        {
            // Troca pixels
        }
    }
}</code></p>
<p>Lembre-se de como implementamos a troca de dois valores com uma vari√°vel tempor√°ria na aula. N√£o h√° necessidade de usar uma fun√ß√£o separada para troca, a menos que voc√™ queira!</p>
<p>E agora √© um bom momento para pensar em seus for aninhados. O <code>for</code> externo itera sobre cada linha, enquanto o <code>for</code> interno itera sobre cada pixel nessa linha. Para refletir uma linha com sucesso, voc√™ precisa iterar sobre cada pixel nela?</p>
<h3>Implementar <code>desfoque</code></h3>
<p>H√° v√°rias formas de criar o efeito de desfocar ou suavizar uma imagem. Para este problema, n√≥s usaremos o "desfoque de caixa", que funciona pegando cada pixel e, para cada valor de cor, dando a ele um novo valor pela m√©dia dos valores das cores dos pixels vizinhos.</p>
<ul>
<li>Considere a seguinte grade de pixels, onde n√≥s numeramos cada pixel.
  <img alt="uma grade de pixels" src="grid.png" /></li>
<li>O novo valor de cada pixel seria a m√©dia dos valores de todos os pixels que est√£o dentro de 1 linha e coluna do pixel original (formando uma caixa 3x3). Por exemplo, cada um dos valores de cor para o pixel 6 seria obtido fazendo a m√©dia dos valores de cor originais dos pixels 1, 2, 3, 5, 6, 7, 9, 10 e 11 (observe que o pr√≥prio pixel 6 est√° incluso na m√©dia). Da mesma forma, os valores de cor para o pixel 11 seriam obtidos fazendo a m√©dia dos valores de cor dos pixels 6, 7, 8, 10, 11, 12, 14, 15 e 16.</li>
<li>Para um pixel ao longo da borda ou canto, como o pixel 15, n√≥s procurar√≠amos por todos os pixels dentro de 1 linha e coluna: nesse caso, os pixels 10, 11, 12, 14, 15 e 16.</li>
</ul>
<p>Ao implementar a fun√ß√£o <code>desfoque</code>, voc√™ pode descobrir que desfocar um pixel acaba afetando o desfoque de outro pixel. Pode ser melhor criar uma c√≥pia de <code>image</code> declarando uma nova matriz bidimensional com um c√≥digo como <code>RGBTRIPLE copy[altura][largura];</code>. Ent√£o, copie <code>image</code> para <code>copy</code>, pixel por pixel, com loops <code>for</code> aninhados, similarmente a isso:</p>
<pre><code>  void blur(int altura, int largura, RGBTRIPLE image[altura][largura])
  {
      // Cria uma c√≥pia de image
      RGBTRIPLE copy[altura][largura];
      for (int i = 0; i &lt; altura; i++)
      {
          for (int j = 0; j &lt; largura; j++)
          {
              copy[i][j] = image[i][j];
          }
      }
  }
</code></pre>
<p>Agora, voc√™ pode ler as cores dos pixels de <code>copy</code> mas escrever (i.e., mudar) as cores dos pixels em <code>image</code>!</p>
<h2>Guia</h2>
<p><strong>Observe que h√° 5 v√≠deos nessa lista de reprodu√ß√£o.</strong></p>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/K0v9byp9jd0?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T3837jmUt0ep7Tpmnxdv9NVut"></iframe></div>

<h2>Como testar</h2>
<p>Tenha certeza de testar seus filtros em todos os arquivos bitmap de exemplo fornecidos!</p>
<h3>Corre√ß√£o</h3>
<pre><code>  check50 cs50/problems/2024/x/filter/less
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 helpers.c
</code></pre>
<h2>Como enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/filter/less
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>