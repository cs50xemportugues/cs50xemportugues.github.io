<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Aula 4</h1>
<ul>
<li><a href="#hexadecimal">Hexadecimal</a></li>
<li><a href="#ponteiros">Ponteiros</a></li>
<li><a href="#string">String</a></li>
<li><a href="#comparar-e-copiar">Comparar e copiar</a></li>
<li><a href="#valgrind">valgrind</a></li>
<li><a href="#troca">Troca</a></li>
<li><a href="#layout-da-mem√≥ria">Layout da mem√≥ria</a></li>
<li><a href="#get_int">get_int</a></li>
<li><a href="#arquivos">Arquivos</a></li>
<li><a href="#jpeg">JPEG</a></li>
</ul>
<h2>Hexadecimal</h2>
<ul>
<li>Na semana 0, aprendemos sobre bin√°rio, um sistema de contagem com 0s e 1s.</li>
<li>Na semana 2, falamos sobre a mem√≥ria e como cada byte tem um endere√ßo ou identificador, ent√£o podemos nos referir a onde nossas vari√°veis s√£o armazenadas.</li>
<li>Acontece que, por conven√ß√£o, os endere√ßos da mem√≥ria usam o sistema de contagem <strong>hexadecimal</strong>, onde existem 16 d√≠gitos, de 0 a 9 e de A a F.</li>
<li>
<p>Lembre-se que, em bin√°rio, cada d√≠gito representava uma pot√™ncia de 2:</p>
<pre><code>  128 64 32 16  8  4  2  1
    1  1  1  1  1  1  1  1
</code></pre>
<ul>
<li>Com 8 bits, podemos contar at√© 255.</li>
</ul>
</li>
<li>
<p>Acontece que, em hexadecimal, podemos contar perfeitamente at√© 8 bits bin√°rios com apenas 2 d√≠gitos:</p>
<pre><code>  16^1 16^0
     F    F
</code></pre>
<ul>
<li>Aqui, <code>F</code> √© um valor de 15 em decimal, e cada lugar √© uma pot√™ncia de 16, ent√£o o primeiro <code>F</code> √© 16^1 * 15 = 240, mais o segundo <code>F</code> com o valor de 16^0 * 15 = 15, para um total de 255.</li>
</ul>
</li>
<li>
<p>E <code>0A</code> √© o mesmo que 10 em decimal, e <code>0F</code> o mesmo que 15. Em hexadecimal, <code>10</code> seria 16, e n√≥s dir√≠amos "um zero em hexadecimal" ao inv√©s de "dez", se quis√©ssemos evitar confus√£o.</p>
</li>
<li>O sistema de cores RGB tamb√©m usa hexadecimal por conven√ß√£o para descrever a quantidade de cada cor. Por exemplo, <code>000000</code> em hexadecimal significa 0 de cada vermelho, verde e azul, para uma cor preta. E <code>FF0000</code> seria 255, ou a quantidade m√°xima poss√≠vel de vermelho. Com diferentes valores para cada cor, podemos representar milh√µes de cores diferentes.</li>
<li>Na escrita, podemos tamb√©m indicar que um valor est√° em hexadecimal ao prefixar com <code>0x</code>, como em <code>0x10</code>, onde o valor √© igual a 16 em decimal, diferentemente de 10.</li>
</ul>
<h2>Ponteiros</h2>
<ul>
<li>Podemos criar um valor <code>n</code> e imprimi-lo:</li>
</ul>
<p>```</p>
<h1>include <stdio.h></h1>
<p>int main(void)
{
    int n = 50;
    printf("%i\n", n);
}
```</p>
<ul>
<li>Na mem√≥ria do nosso computador, existem agora 4 bytes em algum lugar que t√™m o valor bin√°rio de 50, etiquetados <code>n</code>:
  <a href="https://cs50.harvard.edu/x/2020/notes/4/n.png">grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno n embaixo</a></li>
<li>Acontece que, com bilh√µes de bytes na mem√≥ria, esses bytes para a vari√°vel <code>n</code> come√ßam em algum endere√ßo exclusivo que pode parecer como <code>0x12345678</code>.</li>
<li>Em C, podemos realmente ver o endere√ßo com o operador <code>&amp;</code>, que significa "obter o endere√ßo desta vari√°vel":</li>
</ul>
<p>```</p>
<h1>include <stdio.h></h1>
<p>int main(void)
{
    int n = 50;
    printf("%p\n", &amp;n);
}
```</p>
<ul>
<li>
<p>E no CS50 IDE, podemos ver um endere√ßo como <code>0x7ffe00b3adbc</code>, onde este √© um local espec√≠fico na mem√≥ria do servidor.</p>
</li>
<li>
<p>O endere√ßo de uma vari√°vel √© chamado de <strong>ponteiro</strong>, que podemos considerar como um valor que "aponta" para um local na mem√≥ria. O operador <code>*</code> nos permite "ir para" o local para o qual um ponteiro est√° apontando.</p>
</li>
<li>Por exemplo, podemos imprimir <code>*&amp;n</code>, onde "vamos" para o endere√ßo de <code>n</code>, e isso imprimir√° o valor de <code>n</code>, <code>50</code>, j√° que esse √© o valor no endere√ßo de <code>n</code>:</li>
</ul>
<p>```</p>
<h1>include <stdio.h></h1>
<p>int main(void)
{
    int n = 50;
    printf("%i\n", *&amp;n);
}
```</p>
<ul>
<li>Tamb√©m temos que usar o operador <code>*</code> (de uma forma infelizmente confusa) para declarar uma vari√°vel que queremos que seja um ponteiro:</li>
</ul>
<p>```</p>
<h1>include <stdio.h></h1>
<p>int main(void)
{
    int n = 50;
    int *p = &n;
    printf("%p\n", p);
}
```</p>
<ul>
<li>
<p>Aqui, usamos <code>int *p</code> para declarar uma vari√°vel, <code>p</code>, que tem o tipo <code>*</code>, um ponteiro, para um valor do tipo <code>int</code>, um inteiro. Ent√£o, podemos imprimir seu valor (algo como <code>0x12345678</code>), ou imprimir o valor em seu local com <code>printf("%n\n", *p);</code>.</p>
</li>
<li>
<p>Na mem√≥ria do nosso computador, as vari√°veis podem ser semelhantes a isto:
  <a href="https://cs50.harvard.edu/x/2020/notes/4/p.png">grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno 0x12345678 embaixo, e oito caixas juntas contendo 0x12345678 com um pequeno p embaixo</a></p>
</li>
<li>Temos um ponteiro, <code>p</code>, com o endere√ßo de alguma vari√°vel.</li>
<li>Podemos abstrair o valor real dos endere√ßos agora, j√° que eles ser√£o diferentes conforme declaramos vari√°veis em nossos programas, e simplesmente pensar em <code>p</code> como "apontando" para algum valor:
  <a href="https://cs50.harvard.edu/x/2020/notes/4/pointing.png">uma caixa contendo p apontando para uma caixa menor contendo 50</a></li>
<li>Digamos que temos uma caixa de correio rotulada "123", com o n√∫mero "50" dentro dela. A caixa de correio seria <code>int n</code>, pois armazena um inteiro. Podemos ter outra caixa de correio com o endere√ßo "456", dentro da qual est√° o valor "123", que √© o endere√ßo da nossa outra caixa de correio. Isso seria <code>int *p</code>, j√° que √© um ponteiro para um inteiro.</li>
<li>Com a capacidade de usar ponteiros, podemos criar diferentes estruturas de dados, ou diferentes maneiras de organizar dados na mem√≥ria que veremos na pr√≥xima semana.</li>
<li>Muitos sistemas de computador modernos s√£o "64 bits", o que significa que usam 64 bits para endere√ßar a mem√≥ria, portanto um ponteiro ter√° 8 bytes, o dobro do tamanho de um inteiro de 4 bytes.</li>
</ul>
<h2>string</h2>
<ul>
<li>Poder√≠amos ter uma vari√°vel <code>string s</code> para um nome como "EMMA" e poder acessar cada caractere com <code>s[0]</code> e assim por diante:
  <img alt="Caixas lado a lado, contendo: E rotulado s[0], M rotulado s[1], M rotulado s[2], A rotulado s[3], \0 rotulado s[4]" src="https://cs50.harvard.edu/x/2020/notes/4/s_array.png" /></li>
<li>Mas acontece que cada caractere √© armazenado na mem√≥ria em um byte com algum endere√ßo, e <code>s</code> √© na verdade apenas um ponteiro com o endere√ßo do primeiro caractere:
  <img alt="Caixa contendo 0x123 rotulado s, caixas lado a lado contendo E rotulado 0x123, M rotulado 0x124, M rotulado 0x125, A rotulado 0x126, \0 rotulado 0x127" src="https://cs50.harvard.edu/x/2020/notes/4/s_pointer.png" /></li>
<li>E como <code>s</code> √© apenas um ponteiro para o come√ßo, somente o <code>\0</code> indica o fim da string.</li>
<li>De fato, a biblioteca CS50 define uma <code>string</code> com <code>typedef char *string</code>, que simplesmente diz que queremos nomear um novo tipo, <code>string</code>, como <code>char *</code>, ou um ponteiro para um caractere.</li>
<li>
<p>Vamos imprimir uma string:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string s = "EMMA";
      printf("%s\n", s);
  }
</code></pre>
</li>
<li>
<p>Isso √© familiar, mas podemos simplesmente dizer:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char *s = "EMMA";
      printf("%s\n", s);
  }
</code></pre>
<ul>
<li>Isso tamb√©m imprimir√° <code>EMMA</code>.</li>
</ul>
</li>
<li>
<p>Com <code>printf("%p\n", s);</code>, podemos imprimir <code>s</code> como seu valor como um ponteiro, como <code>0x42ab52</code>. (<code>printf</code> sabe ir para o endere√ßo e imprimir a string inteira quando usamos <code>%s</code> e passamos <code>s</code>, mesmo que <code>s</code> aponte apenas para o primeiro caractere.)</p>
</li>
<li>Podemos tamb√©m tentar <code>printf("%p\n", &amp;s[0]);</code>, que √© o endere√ßo do primeiro caractere de <code>s</code>, e √© exatamente o mesmo que imprimir <code>s</code>. E imprimir <code>&amp;s[1]</code>, <code>&amp;s[2]</code>, e <code>&amp;s[3]</code> nos d√° os endere√ßos que s√£o os pr√≥ximos caracteres na mem√≥ria depois de <code>&amp;s[0]</code>, como <code>0x42ab53</code>, <code>0x42ab54</code>, e <code>0x42ab55</code>, exatamente um byte ap√≥s o outro.</li>
<li>E finalmente, se tentarmos <code>printf("%c\n", *s);</code>, obteremos um √∫nico caractere <code>E</code>, j√° que iremos para o endere√ßo contido em <code>s</code>, que tem o primeiro caractere na string.</li>
<li>De fato, <code>s[0]</code>, <code>s[1]</code>, e <code>s[2]</code> na verdade s√£o mapeados diretamente para <code>*s</code>, <code>*(s+1)</code>, e <code>*(s+2)</code>, j√° que cada um dos pr√≥ximos caracteres est√° exatamente no endere√ßo do pr√≥ximo byte.</li>
</ul>
<h2>Comparar e copiar</h2>
<ul>
<li>
<p>Vamos olhar para <code>compare0</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Obter dois inteiros
      int i = get_int("i: ");
      int j = get_int("j: ");

      // Comparar inteiros
      if (i == j)
      {
          printf("Igual\n");
      }
      else
      {
          printf("Diferente\n");
      }
  }
</code></pre>
<ul>
<li>Podemos compilar e executar isso, e nosso programa funciona como esperado, com os mesmos valores dos dois inteiros nos dando "Igual" e valores diferentes "Diferente".</li>
</ul>
</li>
<li>
<p>Em <code>compare1</code>, vemos que os mesmos valores de string est√£o fazendo nosso programa imprimir "Diferente":</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Obter duas strings
      string s = get_string("s: ");
      string t = get_string("t: ");

      // Comparar endere√ßos das strings
      if (s == t)
      {
          printf("Igual\n");
      }
      else
      {
          printf("Diferente\n");
      }
  }
</code></pre>
<ul>
<li>Dado o que sabemos agora sobre strings, isso faz sentido porque cada vari√°vel de "string" est√° apontando para um local diferente na mem√≥ria, onde o primeiro caractere de cada string √© armazenado. Portanto, mesmo que os valores das strings sejam iguais, isso sempre imprimir√° "Diferente".</li>
<li>Por exemplo, nossa primeira string pode estar no endere√ßo 0x123, a segunda pode estar no 0x456, e <code>s</code> ser√° <code>0x123</code> e <code>t</code> ser√° <code>0x456</code>, ent√£o esses valores ser√£o diferentes.</li>
<li>E <code>get_string</code>, o tempo todo, tem retornado apenas um <code>char *</code>, ou um ponteiro para o primeiro caractere de uma string do usu√°rio.</li>
</ul>
</li>
<li>
<p>Agora vamos tentar copiar uma string:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string s = get_string("s: ");

      string t = s;

      t[0] = toupper(t[0]);

      // Imprimir a string duas vezes
      printf("s: %s\n", s);
      printf("t: %s\n", t);
  }
</code></pre>
<ul>
<li>Obtemos uma string <code>s</code> e copiamos o valor de <code>s</code> para <code>t</code>. Em seguida, capitalizamos a primeira letra em <code>t</code>.</li>
<li>Mas quando executamos nosso programa, vemos que tanto <code>s</code> quanto <code>t</code> agora est√£o capitalizados.</li>
<li>Como definimos <code>s</code> e <code>t</code> para os mesmos valores, eles s√£o na verdade ponteiros para o mesmo caractere, e assim capitalizamos o mesmo caractere!</li>
</ul>
</li>
<li>
<p>Para realmente fazer uma c√≥pia de uma string, precisamos fazer um pouco mais de trabalho:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      char *s = get_string("s: ");

      char *t = malloc(strlen(s) + 1);

      for (int i = 0, n = strlen(s); i &lt; n + 1; i++)
      {
          t[i] = s[i];
      }

      t[0] = toupper(t[0]);

      printf("s: %s\n", s);
      printf("t: %s\n", t);
  }
</code></pre>
<ul>
<li>Criamos uma nova vari√°vel, <code>t</code>, do tipo <code>char *</code>, com <code>char *t</code>. Agora, queremos apont√°-la para um novo bloco de mem√≥ria grande o suficiente para armazenar a c√≥pia da string. Com <code>malloc</code>, podemos alocar alguns bytes na mem√≥ria (que n√£o est√£o sendo usados para armazenar outros valores), e passamos o n√∫mero de bytes que desejamos. J√° sabemos o comprimento de <code>s</code>, ent√£o adicionamos 1 para o caractere nulo de termina√ß√£o. Portanto, nossa linha final de c√≥digo √© <code>char *t = malloc(strlen(s) + 1);</code>.</li>
<li>Em seguida, copiamos cada caractere, um de cada vez, e agora podemos capitalizar apenas a primeira letra de <code>t</code>. E usamos <code>i &lt; n + 1</code>, j√° que realmente queremos ir at√© <code>n</code>, para garantir que copiamos o caractere de termina√ß√£o na string.</li>
<li>Na verdade, tamb√©m podemos usar a fun√ß√£o da biblioteca <code>strcpy</code> com <code>strcpy(t, s)</code> em vez do nosso loop, para copiar a string <code>s</code> para <code>t</code>. Para ser claro, o conceito de uma ‚Äústring‚Äù √© da linguagem C e bem suportado; as √∫nicas rodinhas de treinamento do CS50 s√£o o tipo <code>string</code> em vez de <code>char *</code>, e a fun√ß√£o <code>get_string</code>.</li>
</ul>
</li>
<li>
<p>Se n√£o copiarmos o caractere nulo de termina√ß√£o, <code>\0</code>, e tentarmos imprimir nossa string <code>t</code>, <code>printf</code> continuar√° e imprimir√° os valores desconhecidos ou lixo que temos na mem√≥ria, at√© que eventualmente encontre um <code>\0</code>, ou at√© mesmo possa travar completamente, j√° que nosso programa pode acabar tentando ler uma mem√≥ria que n√£o lhe pertence!</p>
</li>
</ul>
<h2>valgrind</h2>
<ul>
<li>Acontece que, ap√≥s concluirmos de usar uma mem√≥ria que alocamos com <code>malloc</code>, devemos chamar <code>free</code> (como em <code>free(t)</code>), que informa ao nosso computador que aqueles bytes n√£o s√£o mais √∫teis ao programa, ent√£o os bytes na mem√≥ria podem ser reutilizados novamente.</li>
<li>Se continu√°ssemos a executar o programa e alocar mem√≥ria com <code>malloc</code>, mas nunca liberar a mem√≥ria ap√≥s o uso, ter√≠amos um <strong>vazamento de mem√≥ria</strong>, o que tornar√° o computador mais lento e usar√° cada vez mais mem√≥ria at√© que o computador fique sem.</li>
<li><code>valgrind</code> √© uma ferramenta de linha de comando que podemos usar para executar o programa e ver se ele tem algum vazamento de mem√≥ria. Podemos executar o valgrind no programa acima com <code>help50 valgrind ./copy</code> e ver, a partir da mensagem de erro, que na linha 10, alocamos mem√≥ria que nunca liberamos (ou ‚Äúperdemos‚Äù).</li>
<li>Portanto, no final, podemos adicionar uma linha <code>free(t)</code>, que n√£o mudar√° a execu√ß√£o do programa, mas sem erros do valgrind.</li>
<li>
<p>Vamos dar uma olhada em <code>memory.c</code>:</p>
<pre><code>  // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare

  #include &lt;stdlib.h&gt;

  void f(void)
  {
      int *x = malloc(10 * sizeof(int));
      x[10] = 0;
  }

  int main(void)
  {
      f();
      return 0;
  }
</code></pre>
<ul>
<li>Este √© um exemplo da documenta√ß√£o do valgrind (valgrind √© uma ferramenta real, enquanto o help50 foi escrito especificamente para nos ajudar neste curso).</li>
<li>A fun√ß√£o <code>f</code> aloca mem√≥ria suficiente para armazenar 10 n√∫meros inteiros e armazena o endere√ßo em um ponteiro chamado <code>x</code>. Ent√£o, tentamos definir o 11¬∫ valor de <code>x</code> com <code>x[10]</code> como <code>0</code>, que vai al√©m do array de mem√≥ria que alocamos para o programa. Isso √© chamado de <strong>estouro de buffer</strong>, em que vamos al√©m dos limites do buffer ou array e para uma mem√≥ria desconhecida.</li>
</ul>
</li>
<li>
<p>O valgrind tamb√©m nos informar√° que h√° uma ‚ÄúGrava√ß√£o inv√°lida de tamanho 4‚Äù para a linha 8, onde estamos realmente tentando alterar o valor de um inteiro (de tamanho 4 bytes).</p>
</li>
<li>E durante todo esse tempo, a Biblioteca CS50 tem liberado mem√≥ria que foi alocada em <code>get_string</code>, quando o programa termina!</li>
</ul>
<h2>Troca</h2>
<ul>
<li>Temos duas bebidas coloridas, roxa e verde, cada uma delas em um copo. Queremos trocar as bebidas entre os dois copos, mas n√£o podemos fazer isso sem um terceiro copo para despejar uma das bebidas primeiro.</li>
<li>
<p>Agora, digamos que queremos trocar os valores de dois n√∫meros inteiros.</p>
<pre><code>  void swap(int a, int b)
  {
      int tmp = a;
      a = b;
      b = tmp;
  }
</code></pre>
<ul>
<li>Com uma terceira vari√°vel para usar como espa√ßo de armazenamento tempor√°rio, podemos fazer isso facilmente, colocando <code>a</code> em <code>tmp</code>, e ent√£o <code>b</code> em <code>a</code>, e finalmente o valor original de <code>a</code>, agora em <code>tmp</code>, em <code>b</code>.</li>
</ul>
</li>
<li>
<p>Mas, se tentarmos usar essa fun√ß√£o em um programa, n√£o vemos nenhuma altera√ß√£o:</p>
<pre><code>  #include &lt;stdio.h&gt;

  void swap(int a, int b);

  int main(void)
  {
      int x = 1;
      int y = 2;

      printf("x √© %i, y √© %i\n", x, y);
      swap(x, y);
      printf("x √© %i, y √© %i\n", x, y);
  }

  void swap(int a, int b)
  {
      int tmp = a;
      a = b;
      b = tmp;
  }
</code></pre>
<ul>
<li>Acontece que a fun√ß√£o <code>swap</code> recebe suas pr√≥prias vari√°veis, <code>a</code> e <code>b</code> quando elas s√£o passadas, que s√£o c√≥pias de <code>x</code> e <code>y</code>, e portanto, alterar esses valores n√£o altera <code>x</code> e <code>y</code> na fun√ß√£o <code>main</code>.</li>
</ul>
</li>
</ul>
<h2><strong>Layout da mem√≥ria</strong></h2>
<ul>
<li>Dentro da mem√≥ria do nosso computador, os diferentes tipos de dados que precisam ser armazenados para o nosso programa s√£o organizados em diferentes se√ß√µes:
  <img alt="Grade com se√ß√µes, de cima para baixo: c√≥digo da m√°quina, globais, heap (com seta apontando para baixo), pilha (com seta apontando para cima)" src="https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png" /><ul>
<li>A se√ß√£o <em>c√≥digo da m√°quina</em> √© o c√≥digo bin√°rio do nosso programa compilado. Quando executamos nosso programa, esse c√≥digo √© carregado na "parte superior" da mem√≥ria.</li>
<li><em>Globais</em> s√£o vari√°veis globais declaramos em nosso programa ou outras vari√°veis compartilhadas que todo o nosso programa pode acessar.</li>
<li>A se√ß√£o <em>heap</em> √© uma √°rea vazia onde o <code>malloc</code> pode obter mem√≥ria livre, para que nosso programa use.</li>
<li>A se√ß√£o <em>pilha</em> √© usada por fun√ß√µes em nosso programa conforme elas s√£o chamadas. Por exemplo, nossa fun√ß√£o <code>main</code> est√° na parte inferior da pilha e tem as vari√°veis locais <code>x</code> e <code>y</code>. A fun√ß√£o <code>swap</code>, quando chamada, tem seu pr√≥prio quadro ou fatia de mem√≥ria que est√° no topo da mem√≥ria de <code>main</code>, com as vari√°veis locais <code>a</code>, <code>b</code> e <code>tmp</code>:
  <img alt="Se√ß√£o da pilha com (a, b, tmp) acima de (x, y)" src="https://cs50.harvard.edu/x/2020/notes/4/stack.png" /><ul>
<li>Depois que a fun√ß√£o <code>swap</code> retorna, a mem√≥ria que ela estava usando √© liberada para a pr√≥xima chamada de fun√ß√£o, e n√≥s perdemos tudo o que fizemos, al√©m dos valores de retorno, e nosso programa volta para a fun√ß√£o que chamou <code>swap</code>.</li>
<li>Portanto, passando os endere√ßos de <code>x</code> e <code>y</code> de <code>main</code> para <code>swap</code>, podemos realmente alterar os valores de <code>x</code> e <code>y</code>: <img alt="Se√ß√£o da pilha com (a, b, tmp) acima de (x, y), e um apontando para x e b apontando para y" src="https://cs50.harvard.edu/x/2020/notes/4/pointers.png" /></li>
</ul>
</li>
</ul>
</li>
<li>Ao passar o endere√ßo de <code>x</code> e <code>y</code>, nossa fun√ß√£o <code>swap</code> pode realmente funcionar:</li>
</ul>
<p>```
  #include <stdio.h></p>
<pre><code>void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&amp;x, &amp;y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
</code></pre>
<p>```</p>
<ul>
<li>
<p>Os endere√ßos de <code>x</code> e <code>y</code> s√£o passados de <code>main</code> para <code>swap</code>, e usamos a sintaxe <code>int *a</code> para declarar que nossa fun√ß√£o <code>swap</code> recebe ponteiros. Salvamos o valor de <code>x</code> para <code>tmp</code> seguindo o ponteiro <code>a</code> e, em seguida, pegamos o valor de <code>y</code> seguindo o ponteiro <code>b</code> e o armazenamos no local para o qual <code>a</code> est√° apontando (<code>x</code>). Finalmente, armazenamos o valor de <code>tmp</code> no local apontado por <code>b</code> (<code>y</code>), e pronto.</p>
</li>
<li>
<p>Se chamarmos <code>malloc</code> muitas vezes, teremos um <strong>overflow de heap</strong>, no qual acabamos passando do nosso heap. Ou, se tivermos muitas fun√ß√µes sendo chamadas, teremos um <strong>overflow de pilha</strong>, no qual nossa pilha tamb√©m tem muitos quadros de mem√≥ria alocados. E esses dois tipos de estouro s√£o geralmente conhecidos como estouros de buffer, ap√≥s os quais nosso programa (ou computador inteiro) pode travar.</p>
</li>
</ul>
<h2>get_int</h2>
<ul>
<li>
<p>Podemos implementar <code>get_int</code> n√≥s mesmos com uma fun√ß√£o de biblioteca em C, <code>scanf</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      int x;
      printf("x: ");
      scanf("%i", &amp;x);
      printf("x: %i\n", x);
  }
</code></pre>
<ul>
<li><code>scanf</code> recebe um formato, <code>%i</code>, portanto, a entrada √© "escaneada" para esse formato e o endere√ßo na mem√≥ria para onde queremos que essa entrada v√°. Mas <code>scanf</code> n√£o tem muita verifica√ß√£o de erros, ent√£o podemos n√£o obter um inteiro.</li>
</ul>
</li>
<li>
<p>Podemos tentar obter uma string da mesma maneira:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char *s = NULL;
      printf("s: ");
      scanf("%s", s);
      printf("s: %s\n", s);
  }
</code></pre>
<ul>
<li>Mas, na verdade, n√£o alocamos nenhuma mem√≥ria para <code>s</code> (<code>s</code> √© <code>NULL</code> ou n√£o aponta para nada), ent√£o, podemos querer chamar <code>char s[5]</code> para alocar uma matriz de 5 caracteres para nossa string. Ent√£o, <code>s</code> ser√° tratado como um ponteiro em <code>scanf</code> e <code>printf</code>.</li>
<li>Agora, se o usu√°rio digitar uma string de comprimento 4 ou menor, nosso programa funcionar√° com seguran√ßa. Mas se o usu√°rio digitar uma string maior, <code>scanf</code> poder√° tentar escrever al√©m do final da nossa matriz na mem√≥ria desconhecida, fazendo com que nosso programa trave.</li>
</ul>
</li>
</ul>
<h2>Arquivos</h2>
<ul>
<li>Com a habilidade de usar ponteiros, tamb√©m podemos abrir arquivos:</li>
</ul>
<p>```c</p>
<h1>include <cs50.h></h1>
<h1>include <stdio.h></h1>
<h1>include <string.h></h1>
<p>int main(void)
{
    // Abre arquivo
    FILE *file = fopen("phonebook.csv", "a");</p>
<pre><code>  // Recebe texto do usu√°rio
  char *name = get_string("Name: ");
  char *number = get_string("Number: ");

  // Imprime (escreve) texto no arquivo
  fprintf(file, "%s,%s\n", name, number);

  // Fecha arquivo
  fclose(file);
</code></pre>
<p>}
```</p>
<ul>
<li><code>fopen</code> √© uma nova fun√ß√£o que podemos usar para abrir um arquivo. Ela retornar√° um ponteiro para um novo tipo, <code>FILE</code>, que podemos ler e escrever. O primeiro argumento √© o nome do arquivo, e o segundo √© o modo que queremos abrir o arquivo (<code>r</code> para leitura, <code>w</code> para escrita, e <code>a</code> para anexar, ou adicionar).</li>
<li>Ap√≥s obter algum texto, podemos usar <code>fprintf</code> para imprimir em um arquivo.</li>
<li>
<p>Finalmente, fechamos o arquivo com <code>fclose</code>.</p>
</li>
<li>
<p>Agora podemos criar nossos pr√≥prios arquivos CSV, arquivos de valores separados por v√≠rgulas (como uma mini-planilha), programaticamente.</p>
</li>
</ul>
<h1>JPEG</h1>
<ul>
<li>
<p>Tamb√©m podemos escrever um programa que abre um arquivo e nos diz se √© um arquivo JPEG (imagem):</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(int argc, char *argv[])
  {
      // Verifica o uso
      if (argc != 2)
      {
          retornar 1;
      }

      // Abrir o arquivo
      FILE *file = fopen(argv[1], "r");
      if (!arquivo)
      {
          retornar 1;
      }

      // Ler os tr√™s primeiros bytes
      unsigned char bytes[3];
      fread(bytes, 3, 1, file);

      // Verificar os tr√™s primeiros bytes
      if (bytes[0] == 0xff &amp;&amp; bytes[1] == 0xd8 &amp;&amp; bytes[2] == 0xff)
      {
          printf("Talvez\n");
      }
      mais
      {
          printf("N√£o\n");
      }

      // Fechar o arquivo
      fclose(file);
  }
</code></pre>
<ul>
<li>Agora, se executarmos este programa com <code>./jpeg brian.jpg</code>, nosso programa tentar√° abrir o arquivo que especificamos (verificando se realmente obtemos um arquivo n√£o nulo) e ler os tr√™s primeiros bytes do arquivo com <code>ler</code>.</li>
<li>Podemos comparar os tr√™s primeiros bytes (em hexadecimal) com os tr√™s bytes necess√°rios para iniciar um arquivo JPEG. Se eles forem iguais, ent√£o nosso arquivo provavelmente ser√° um arquivo JPEG (embora outros tipos de arquivo ainda possam come√ßar com esses bytes). Mas se eles n√£o forem iguais, sabemos que definitivamente n√£o √© um arquivo JPEG.</li>
</ul>
</li>
<li>
<p>Podemos usar essas habilidades para ler e escrever arquivos, em particular imagens, e modific√°-los alterando os bytes neles, no conjunto de problemas desta semana!</p>
</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>