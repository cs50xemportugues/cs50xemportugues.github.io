<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <p><strong>Aula 0</strong></p>
<ul>
<li><a href="#welcome">Bem-vindo</a></li>
<li><a href="#what-is-computer-science">O que √© ci√™ncia da computa√ß√£o?</a></li>
<li><a href="#binary">Bin√°rio</a></li>
<li><a href="#representing-data">Representa√ß√µes de dados</a></li>
<li><a href="#algorithms">Algoritmos</a></li>
<li><a href="#pseudocode">Pseudoc√≥digo</a></li>
<li><a href="#scratch">Scratch</a></li>
</ul>
<h2>Bem-vindo</h2>
<ul>
<li>Quando David estava no primeiro ano, ele ficou muito intimidado para fazer qualquer curso de ci√™ncia da computa√ß√£o. Quando estava no segundo ano, ele encontrou coragem para fazer o equivalente ao CS50, mas apenas para passar/ser reprovado.</li>
<li>Na verdade, dois ter√ßos dos alunos do CS50 nunca fizeram um curso de ci√™ncia da computa√ß√£o antes.</li>
<li>E o mais importante tamb√©m:</li>
</ul>
<blockquote>
<p>O que importa neste curso n√£o √© tanto onde voc√™ estar√° em rela√ß√£o aos seus colegas, mas onde voc√™ estar√° em rela√ß√£o a si mesmo quando come√ßou.</p>
</blockquote>
<h2>O que √© ci√™ncia da computa√ß√£o?</h2>
<ul>
<li>Ci√™ncia da computa√ß√£o √© fundamentalmente resolu√ß√£o de problemas.</li>
<li>O processo de resolu√ß√£o de problemas √© pegar uma entrada (detalhes sobre o problema) e gerar uma sa√≠da (a solu√ß√£o do problema). A "caixa preta" no meio √© a ci√™ncia da computa√ß√£o.
  <img alt="palavra &quot;input&quot;, seta para a caixa, seta para fora da caixa, palavra &quot;output&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/input_output.png" /></li>
<li>Precisamos de uma maneira de representar entradas, de modo que possamos armazenar e trabalhar com informa√ß√µes de uma maneira padr√£o.</li>
</ul>
<h2>Bin√°rio</h2>
<ul>
<li>Um computador, no n√≠vel mais baixo, armazena dados em bin√°rio, um sistema num√©rico em que existem apenas dois d√≠gitos, 0 e 1.</li>
<li>Quando aprendemos a contar, podemos ter usado um dedo para representar uma coisa. Esse sistema √© chamado de un√°rio. Quando aprendemos a escrever n√∫meros com os d√≠gitos de 0 a 9, aprendemos a usar o sistema decimal.</li>
<li>Por exemplo, sabemos que o seguinte representa cento e vinte e tr√™s:</li>
</ul>
<pre>
1 2 3
</pre>

<ul>
<li>O "3" est√° na coluna das unidades, o "2" est√° na coluna das dezenas e o "1" est√° na coluna das centenas.</li>
<li>Portanto, "123" √© 100 √ó 1 + 10 √ó 2 + 1 √ó 3 = 100 + 20 + 3 = 123.</li>
<li>
<p>Cada lugar para um d√≠gito representa uma pot√™ncia de dez, pois h√° dez d√≠gitos poss√≠veis para cada lugar.</p>
</li>
<li>
<p>Em bin√°rio, com apenas dois d√≠gitos, temos pot√™ncias de dois para cada valor de lugar:</p>
</li>
</ul>
<pre>
4 2 1
0 0 0
</pre>

<ul>
<li>
<p>Isso ainda seria igual a 0.</p>
</li>
<li>
<p>Agora, se alterarmos o valor bin√°rio para, digamos, "0 1 1", o valor decimal ser√° 3.</p>
</li>
</ul>
<pre>
4 2 1
0 1 1
</pre>

<ul>
<li>Se quis√©ssemos representar 8, precisar√≠amos de outro d√≠gito:</li>
</ul>
<pre>
8 4 2 1
1 0 0 0
</pre>

<ul>
<li>E o bin√°rio faz sentido para computadores porque n√≥s os alimentamos com eletricidade, que pode estar ligada ou desligada, ent√£o cada bit s√≥ precisa estar ligado ou desligado. Em um computador, h√° milh√µes ou bilh√µes de interruptores chamados transistores que podem armazenar eletricidade e representar um bit como "ligado" ou "desligado".</li>
<li>Com bits ou d√≠gitos bin√°rios suficientes, os computadores podem contar at√© qualquer n√∫mero.</li>
<li>8 bits formam um <strong>byte</strong>.</li>
</ul>
<h2>Representa√ß√µes de dados</h2>
<ul>
<li>Para representar letras, tudo o que precisamos fazer √© decidir como os n√∫meros s√£o mapeados para as letras. Alguns humanos, muitos anos atr√°s, decidiram coletivamente usar um mapeamento padr√£o chamado <a href="https://pt.wikipedia.org/wiki/ASCII">ASCII</a>. A letra "A", por exemplo, √© o n√∫mero 65, e "B" √© 66, e assim por diante. O mapeamento tamb√©m inclui pontua√ß√£o e outros s√≠mbolos. Outros caracteres, como letras com acentos e emojis, fazem parte de um padr√£o chamado <a href="https://pt.wikipedia.org/wiki/Unicode">Unicode</a> que usa mais bits do que ASCII para acomodar todos esses caracteres.<ul>
<li>Quando recebemos um emoji, nosso computador est√° na verdade apenas recebendo um n√∫mero decimal como "128514" ("11111011000000010" em bin√°rio, se voc√™ puder ler isso mais facilmente) que ele ent√£o mapeia para a imagem do emoji.</li>
</ul>
</li>
<li>Uma imagem tamb√©m √© composta de muitos pontos quadrados menores, ou pixels, cada um dos quais pode ser representado em bin√°rio com um sistema chamado RGB, com valores para luz vermelha, verde e azul em cada pixel. Ao misturar diferentes quantidades de cada cor, podemos representar milh√µes de cores:
  <img alt="quadrado vermelho rotulado com 72, quadrado verde rotulado com 73, quadrado azul rotulado com 33" src="https://cs50.harvard.edu/x/2020/notes/0/rgb.png" /><ul>
<li>Os valores vermelho, verde e azul s√£o combinados para obter uma cor amarelo claro:
  <img alt="quadrado amarelo claro" src="https://cs50.harvard.edu/x/2020/notes/0/rgb_combined.png" /></li>
</ul>
</li>
<li>Podemos ver isso em um emoji se aumentarmos o zoom o suficiente: <a href="https://cs50.harvard.edu/x/2020/notes/0/emoji_zoomed.png">emoji ampliado de l√°grimas de alegria com quadrados de pixels distingu√≠veis</a></li>
<li>E os programas de computador sabem, com base no contexto de seu c√≥digo, se os n√∫meros bin√°rios devem ser interpretados como n√∫meros, letras ou pixels.</li>
<li>E os v√≠deos s√£o apenas muitas e muitas imagens exibidas uma ap√≥s a outra, a um determinado n√∫mero de quadros por segundo. A m√∫sica tamb√©m pode ser representada pelas notas que est√£o sendo tocadas, sua dura√ß√£o e seu volume.</li>
</ul>
<h2>Algoritmos</h2>
<ul>
<li>Ent√£o agora podemos representar entradas e sa√≠das. A caixinha preta vista anteriormente conter√° <em>algoritmos</em>, instru√ß√µes passo a passo para solucionar um problema:
  <img alt="caixa com a palavra &quot;algoritmos&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/algorithms.png" /></li>
<li>Digamos que queremos encontrar um amigo, Mike Smith, em uma lista telef√¥nica.<ul>
<li>Podemos come√ßar folheando o livro uma p√°gina de cada vez at√© encontrarmos Mike Smith ou chegarmos ao fim do livro.</li>
<li>Podemos tamb√©m folhear duas p√°ginas por vez, mas se formos longe demais, teremos de saber voltar uma p√°gina.</li>
<li>Mas uma forma ainda mais eficiente seria abrir a lista telef√¥nica ao meio, decidir se Mike estar√° na metade esquerda ou direita do livro (j√° que o livro est√° em ordem alfab√©tica) e descartar imediatamente metade do problema. Podemos repetir isso, dividindo o problema pela metade sempre. Com 1024 p√°ginas para come√ßar, precisar√≠amos de apenas 10 passos dividindo pela metade antes de sobrar apenas uma p√°gina para verificarmos.</li>
</ul>
</li>
<li>Na verdade, podemos representar a efici√™ncia de cada um desses algoritmos com um gr√°fico:
  <img alt="gr√°fico com: &quot;tamanho do problema&quot; como eixo x; &quot;tempo para resolver&quot; como eixo y; linha reta √≠ngreme vermelha da origem at√© o topo do gr√°fico rotulada como &quot;n&quot;; linha reta amarela menos √≠ngreme da origem at√© o topo do gr√°fico rotulada como &quot;n/2&quot;; linha verde curva que se torna cada vez menos √≠ngreme da origem at√© a direita do gr√°fico rotulada como &quot;log n&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/running_time.png" /><ul>
<li>A nossa primeira solu√ß√£o, uma p√°gina por vez, √© como a linha vermelha: nosso tempo para resolver aumenta linearmente conforme o tamanho do problema aumenta.</li>
<li>A segunda solu√ß√£o, duas p√°ginas por vez, √© como a linha amarela: a inclina√ß√£o √© menor, mas ainda linear.</li>
<li>Nossa solu√ß√£o final √© como a linha verde: logar√≠tmica, pois nosso tempo para resolver aumenta cada vez mais devagar conforme o tamanho do problema aumenta. Ou seja, se a lista telef√¥nica passasse de 1000 para 2000 p√°ginas, precisar√≠amos de mais um passo para encontrar Mike. Se o tamanho dobrasse novamente de 2000 para 4000 p√°ginas, ainda precisar√≠amos de apenas mais um passo.</li>
</ul>
</li>
</ul>
<h2>Pseudoc√≥digo</h2>
<ul>
<li>
<p>Podemos escrever <em>pseudoc√≥digo</em>, uma sintaxe informal que √© apenas uma vers√£o mais espec√≠fica de ingl√™s (ou outra l√≠ngua humana) que representa nosso algoritmo:</p>
<pre><code>   1  Pegue a lista telef√¥nica
   2  Abra o meio da lista telef√¥nica
   3  Olhe a p√°gina
   4  Se Smith estiver na p√°gina
   5      Ligue para Mike
   6  Sen√£o se Smith estiver antes no livro
   7      Abra o meio da metade esquerda do livro
   8      Retorne √† linha 3
   9  Sen√£o se Smith estiver depois no livro
   10     Abra o meio da metade direita do livro
   11     Retorne √† linha 3
   12 Sen√£o
   13     Pare
</code></pre>
</li>
<li>
<p>Algumas dessas linhas come√ßam com verbos ou a√ß√µes. Passaremos a cham√°-los de <em>fun√ß√µes</em>:</p>
</li>
</ul>
<pre>
    1  <b>Pegar</b> a lista telef√¥nica
    2  <b>Abrir</b> no meio da lista telef√¥nica
    3  <b>Olhar</b> a p√°gina
    4  Se Smith estiver na p√°gina  
    5      <b>Ligar</b> para Mike
    6  Sen√£o se Smith estiver antes no livro
    7      <b>Abrir</b> no meio da metade esquerda do livro
    8      Retornar √† linha 3
    9  Sen√£o se Smith estiver depois no livro
    10     <b>Abrir</b> no meio da metade direita do livro
    11     Retornar √† linha 3
    12 Sen√£o
    13     <b>Parar</b>
</pre>

<ul>
<li>Tamb√©m temos ramifica√ß√µes que levam a caminhos diferentes, como bifurca√ß√µes na estrada, que chamaremos de <em>condi√ß√µes</em>:</li>
</ul>
<pre>
    1  Pegar a lista telef√¥nica
    2  Abrir no meio da lista telef√¥nica
    3  Olhar a p√°gina
    4  <b>Se</b> Smith estiver na p√°gina
    5      Ligar para Mike
    6  <b>Sen√£o se</b> Smith estiver antes no livro
    7      Abrir no meio da metade esquerda do livro
    8      Retornar √† linha 3
    9  <b>Sen√£o se</b> Smith estiver depois no livro
    10     Abrir no meio da metade direita do livro
    11     Retornar √† linha 3
    12 <b>Sen√£o</b>
    13     Parar
</pre>

<ul>
<li>E as perguntas que decidem para onde vamos s√£o chamadas de <em>express√µes booleanas</em>, que eventualmente resultam em um valor verdadeiro ou falso:</li>
</ul>
<pre>
    1  Pegar a lista telef√¥nica
    2  Abrir no meio da lista telef√¥nica
    3  Olhar a p√°gina
    4  Se <b>Smith estiver na p√°gina</b>
    5      Ligar para Mike
    6  Sen√£o se <b>Smith estiver antes no livro</b>
    7      Abrir no meio da metade esquerda do livro
    8      Retornar √† linha 3
    9  Sen√£o se <b>Smith estiver depois no livro</b>
    10     Abrir no meio da metade direita do livro
    11     Retornar √† linha 3
    12 Sen√£o
    13     Parar
</pre>

<ul>
<li>Finalmente, temos palavras que levam a ciclos, onde podemos repetir partes do nosso programa, chamadas de <em>loops</em>:</li>
</ul>
<pre>
    1  Pegar a lista telef√¥nica
    2  Abrir no meio da lista telef√¥nica
    3  Olhar a p√°gina
    4  Se Smith estiver na p√°gina
    5      Ligar para Mike
    6  Sen√£o se Smith estiver antes no livro
    7      Abrir no meio da metade esquerda do livro
    8      <b>Retornar √† linha 3</b>
    9  Sen√£o se Smith estiver depois no livro
    10     Abrir no meio da metade direita do livro
    11     <b>Retornar √† linha 3</b>
    12 Sen√£o
    13     Parar
</pre>

<h2>Scratch</h2>
<ul>
<li>Podemos escrever programas com os blocos de constru√ß√£o que acabamos de descobrir:<ul>
<li>fun√ß√µes</li>
<li>condi√ß√µes</li>
<li>express√µes booleanas</li>
<li>la√ßos</li>
</ul>
</li>
<li>Usaremos uma linguagem de programa√ß√£o gr√°fica chamada <a href="https://scratch.mit.edu/">Scratch</a>, na qual arrastaremos e soltaremos blocos que cont√™m instru√ß√µes.</li>
<li>Mais tarde em nosso curso, passaremos para linguagens de programa√ß√£o textuais como C, Python e JavaScript. Todas essas linguagens, incluindo o Scratch, t√™m recursos mais poderosos, como:<ul>
<li>vari√°veis<ul>
<li>a capacidade de armazenar valores e alter√°-los</li>
</ul>
</li>
<li>threads<ul>
<li>a capacidade de nosso programa fazer v√°rias coisas ao mesmo tempo</li>
</ul>
</li>
<li>eventos<ul>
<li>a capacidade de responder a mudan√ßas em nosso programa ou entradas</li>
</ul>
</li>
<li>‚Ä¶</li>
</ul>
</li>
<li>O ambiente de programa√ß√£o do Scratch se parece com isto:
  <img alt="captura de tela do Scratch" src="https://cs50.harvard.edu/x/2020/notes/0/scratch.png" /><ul>
<li>√Ä esquerda, temos pe√ßas de quebra-cabe√ßa que representam fun√ß√µes ou vari√°veis, ou outros conceitos, que podemos arrastar e soltar em nossa √°rea de instru√ß√µes no centro.</li>
<li>√Ä direita, temos um palco que ser√° exibido por nosso programa para um humano, onde podemos adicionar ou alterar planos de fundo, personagens (chamados sprites no Scratch) e muito mais.</li>
</ul>
</li>
<li>Podemos arrastar alguns blocos para fazer o Scratch dizer ‚Äúol√°, mundo‚Äù:<br />
<img alt="captura de tela de hello, world" src="https://cs50.harvard.edu/x/2020/notes/0/hello_world.png" /><ul>
<li>O bloco ‚Äúquando a bandeira verde clicada‚Äù √© o in√≠cio do nosso programa, e abaixo dele encaixamos um bloco ‚Äúdizer‚Äù e digitamos ‚Äúol√°, mundo‚Äù.</li>
</ul>
</li>
<li>Tamb√©m podemos arrastar o bloco ‚Äúperguntar e esperar‚Äù, com uma pergunta como ‚ÄúQual √© o seu nome?‚Äù, e combin√°-lo com um bloco ‚Äúdizer‚Äù para a resposta:<br />
<img alt="captura de tela de pergunta e resposta" src="https://cs50.harvard.edu/x/2020/notes/0/answer.png" /></li>
<li>Mas n√£o esperamos depois de dizer ‚ÄúOl√°‚Äù com o primeiro bloco, ent√£o podemos usar o bloco ‚Äúdizer () durante () segundos‚Äù:<br />
<img alt="captura de tela de blocos com dizer por 2 segundos" src="https://cs50.harvard.edu/x/2020/notes/0/wait.png" /></li>
<li>Podemos usar o bloco ‚Äúunir‚Äù para combinar duas frases para que o Scratch possa dizer ‚Äúol√°, David‚Äù:<br />
<img alt="captura de tela de unir" src="https://cs50.harvard.edu/x/2020/notes/0/join.png" /><ul>
<li>Observe que podemos aninhar instru√ß√µes e vari√°veis.</li>
</ul>
</li>
<li>Na verdade, o pr√≥prio bloco ‚Äúdizer‚Äù √© como um algoritmo, onde fornecemos uma entrada de ‚Äúol√°, mundo‚Äù e ele produziu a sa√≠da do Scratch (o gato) ‚Äúdizendo‚Äù essa frase:<br />
<img alt="dizer como algoritmo com &quot;ol√°, mundo&quot; como entrada e gato como sa√≠da" src="https://cs50.harvard.edu/x/2020/notes/0/say_algorithm.png" /></li>
<li>O bloco ‚Äúperguntar‚Äù tamb√©m recebe uma entrada (a pergunta que queremos fazer) e produz a sa√≠da do bloco ‚Äúresposta‚Äù:<br />
<img alt="perguntar como algoritmo com &quot;Qual √© o seu nome?&quot; como entrada e bloco de resposta como sa√≠da" src="https://cs50.harvard.edu/x/2020/notes/0/ask_algorithm.png" /></li>
<li>Podemos ent√£o usar o bloco ‚Äúresposta‚Äù junto com nosso pr√≥prio texto, ‚Äúol√°, ‚Äú, como duas entradas para o algoritmo de jun√ß√£o ‚Ä¶<br />
<img alt="jun√ß√£o como algoritmo com &quot;ol√°, &quot; e &quot;resposta&quot; como entrada e &quot;ol√°, David!&quot; como sa√≠da" src="https://cs50.harvard.edu/x/2020/notes/0/join_algorithm.png" /></li>
<li>‚Ä¶ que passamos como entrada novamente para o bloco ‚Äúdizer‚Äù:<br />
<img alt="dizer como algoritmo com &quot;ol√°, David!&quot; como entrada e gato como sa√≠da" src="https://cs50.harvard.edu/x/2020/notes/0/say_again.png" /></li>
<li>Podemos tentar fazer o Scratch (o nome do gato) dizer miau:<br />
<img alt="blocos rotulados &quot;para sempre&quot; com &quot;reproduzir som Miau at√© fazer&quot; aninhados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/forever_meow.png" /><ul>
<li>Mas quando clicamos na bandeira verde, ouvimos o som do miado repetidamente e imediatamente. Nosso primeiro bug, ou erro! Podemos adicionar um bloco para esperar, para que os miados soem mais normais.<br />
<img alt="blocos rotulados &quot;para sempre&quot; com &quot;reproduzir som Miau at√© fazer&quot; e &quot;esperar 1 segundo&quot; aninhados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/forever_meow_wait.png" /></li>
</ul>
</li>
<li>Podemos fazer o Scratch apontar para o mouse e mover-se em dire√ß√£o a ele:<br />
<img alt="blocos rotulados &quot;para sempre&quot; com &quot;apontar para o ponteiro do mouse&quot; e &quot;mover 10 passos&quot; aninhados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/point_towards.png" /></li>
<li>Veremos uma ovelha que pode contar:<br />
<img alt="blocos rotulados &quot;definir contador como 1&quot; e &quot;para sempre&quot; com &quot;dizer contador durante 1 segundo&quot;, &quot;esperar 1 segundo&quot; e &quot;alterar contador em 1&quot; aninhados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/count.png" /><ul>
<li>Aqui, <code>contador</code> √© uma vari√°vel, cujo valor podemos definir, usar e alterar.</li>
</ul>
</li>
<li>Tamb√©m podemos fazer o Scratch miar se tocarmos nele com o ponteiro do mouse:<br />
<img alt="blocos rotulados &quot;para sempre&quot; com &quot;se tocar no ponteiro do mouse? ent√£o&quot; e &quot;reproduzir som Miau at√© fazer&quot; aninhados" src="https://cs50.harvard.edu/x/2020/notes/0/pet0.png" /></li>
<li>Como alternativa, podemos fazer o Scratch rugir se o fizermos:<br />
<img alt="blocos rotulados &quot;para sempre&quot; com &quot;se tocar no ponteiro do mouse? ent√£o&quot; e &quot;reproduzir som rugido at√© fazer&quot; aninhados, e &quot;sen√£o&quot;, &quot;reproduzir som Miau at√© fazer&quot;, &quot;esperar 1 segundo&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/pet1.png" /><ul>
<li>Aqui, temos dois ramos diferentes, ou condi√ß√µes, que se repetir√£o para sempre. Se o mouse estiver tocando, o Scratch ‚Äúrugir√°‚Äù, caso contr√°rio, ele apenas miar√°.</li>
</ul>
</li>
<li>
<p>Podemos fazer o Scratch se mover para frente e para tr√°s na tela com mais alguns blocos que podemos descobrir olhando ao redor:<br />
<img alt="blocos rotulados &quot;definir estilo de rota√ß√£o esquerda-direita&quot; e &quot;para sempre&quot; com &quot;mover 10 passos&quot;, &quot;se tocar na borda? ent√£o&quot; e &quot;reproduzir som ai at√© fazer&quot;, &quot;virar 180 graus&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/ouch.png" /></p>
<ul>
<li>Podemos at√© mesmo gravar nosso pr√≥prio som para tocar.</li>
</ul>
</li>
<li>
<p>Com duas ‚Äúvestimentas‚Äù ou imagens diferentes do Scratch com as pernas em posi√ß√µes diferentes, podemos at√© mesmo simular um movimento animado ao caminhar:
  <img alt="blocos rotulados como ‚Äúdefinir estilo de rota√ß√£o esquerda-direita‚Äù e ‚Äúpara sempre‚Äù com ‚Äúmover 10 passos‚Äù, ‚Äúse tocou na borda? ent√£o‚Äù com ‚Äútocar som ai at√© fim‚Äù, ‚Äúgirar 180 graus‚Äù aninhado dentro e ‚Äúpr√≥xima vestimenta‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/bounce.png" /></p>
</li>
<li>Analisaremos outro programa, bark, no qual podemos usar a barra de espa√ßo para silenciar um le√£o-marinho:
  <img alt="blocos rotulados como ‚Äúdefinir mudo para falso‚Äù e ‚Äúpara sempre‚Äù com se chave espa√ßo pressionada? ent√£o‚Äù com ‚Äúse mudo = verdadeiro ent√£o‚Äù e ‚Äúdefinir mudo para falso‚Äù e ‚Äúsen√£o‚Äù e ‚Äúdefinir mudo para verdadeiro‚Äù aninhados dentro e ‚Äúaguarde 1 segundo‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/bark.png" /><ul>
<li>Temos uma vari√°vel, <code>muted</code>, que √© <code>false</code> por padr√£o. E o programa verificar√° constantemente se a barra de espa√ßo √© pressionada e definir√° muted para <code>false</code> se for <code>true</code> ou <code>true</code> se n√£o for. Dessa forma, podemos alternar a reprodu√ß√£o do som ou n√£o, j√° que o outro conjunto de blocos do le√£o-marinho verifica a vari√°vel <code>muted</code>:
  <img alt="blocos rotulados como ‚Äúpara sempre‚Äù com se muted = falso ent√£o‚Äù com ‚Äúiniciar som SeaLion‚Äù e ‚Äúpensar oi oi oi por 2 segundos‚Äù aninhados dentro e ‚Äúaguarde 1 segundo‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/bark1.png" /></li>
</ul>
</li>
<li>Com v√°rios sprites, ou personagens, podemos ter diferentes conjuntos de blocos para cada um deles:
  <img alt="blocos rotulados como ‚Äúpara sempre‚Äù com se chave espa√ßo pressionada? ent√£o‚Äù com ‚Äúdizer Marco! por 2 segundos‚Äù e ‚Äútransmiss√£o de evento‚Äù aninhados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/marco.png" /><ul>
<li>Para um fantoche, temos esses blocos que dizem ‚ÄúMarco!‚Äù e, em seguida, um bloco de ‚Äútransmiss√£o de evento‚Äù. Esse ‚Äúevento‚Äù √© usado para que nossos dois sprites se comuniquem entre si, como o envio de uma mensagem secreta. Ent√£o, o outro fantoche pode apenas esperar que esse evento diga ‚ÄúPolo!‚Äù:
  <img alt="blocos rotulados como ‚Äúquando recebo evento‚Äù, ‚Äúdizer Polo! por 2 segundos‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/polo.png" /></li>
</ul>
</li>
<li>Agora que conhecemos alguns conceitos b√°sicos, podemos pensar no design ou na qualidade de nossos programas. Por exemplo, podemos querer que o Scratch tussa tr√™s vezes repetindo alguns blocos:
  <img alt="blocos rotulados como ‚Äúdizer tosse por 1 segundo‚Äù, ‚Äúaguarde 1 segundo‚Äù, ‚Äúdizer tosse por 1 segundo‚Äù, ‚Äúaguarde 1 segundo‚Äù, ‚Äúdizer tosse por 1 segundo‚Äù, ‚Äúaguarde 1 segundo‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/cough0.png" /></li>
<li>Embora esteja correto, podemos evitar a repeti√ß√£o de blocos com um loop:
  <img alt="blocos rotulados como ‚Äúrepetir 3‚Äù com ‚Äúdizer tosse por 1 segundo‚Äù, ‚Äúaguarde 1 segundo‚Äù aninhados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/cough1.png" /></li>
<li>A pr√≥xima etapa √© abstrair parte do nosso c√≥digo em uma fun√ß√£o, ou torn√°-lo reutiliz√°vel de diferentes maneiras. Podemos criar um bloco chamado ‚Äútosse‚Äù e colocar alguns blocos dentro dele:
  <img alt="dois conjuntos de blocos. o primeiro conjunto de blocos √©: ‚Äúdefinir tosse‚Äù, ‚Äúdizer tosse por 1 segundo‚Äù, ‚Äúaguarde 1 segundo‚Äù. o segundo conjunto √©: ‚Äúquando a bandeira verde √© clicada‚Äù, ‚Äúrepetir 3‚Äù, ‚Äútosse‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/cough_function.png" /><ul>
<li>Agora, todos os nossos sprites podem usar o mesmo bloco de ‚Äútosse‚Äù, em quantos lugares desejarmos.</li>
</ul>
</li>
<li>Podemos at√© mesmo colocar um n√∫mero de vezes em nossa fun√ß√£o de tosse, portanto, precisamos apenas de um √∫nico bloco para tossir qualquer n√∫mero de vezes:
  <img alt="dois conjuntos de blocos. o primeiro conjunto de blocos √©: ‚Äúdefinir n vezes de tosse‚Äù, ‚Äúrepetir n‚Äù, dizer tosse por 1 segundo‚Äù, ‚Äúaguarde 1 segundo‚Äù. o segundo conjunto √©: ‚Äúquando a bandeira verde √© clicada‚Äù, ‚Äútosse 3 vezes‚Äù" src="https://cs50.harvard.edu/x/2020/notes/0/cough_function_2.png" /></li>
<li>Analisamos alguns exemplos e discutimos como podemos implementar componentes deles com diferentes sprites que seguem o cursor do mouse ou fazem com que algo mais aconte√ßa no palco.</li>
<li>Bem-vindo a bordo!</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>