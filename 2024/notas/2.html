<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Aula 2</h1>
<ul>
<li><a href="#compila√ß√£o">Compila√ß√£o</a></li>
<li><a href="#depura√ß√£o">Depura√ß√£o</a></li>
<li><a href="#help50-e-printf">help50 e printf</a></li>
<li><a href="#debug50">debug50</a></li>
<li><a href="#check50-e-style50">check50 e style50</a></li>
<li><a href="#tipos-de-dados">Tipos de Dados</a></li>
<li><a href="#mem√≥ria">Mem√≥ria</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#argumentos-da-linha-de-comando">Argumentos da linha de comando</a></li>
<li><a href="#legibilidade">Legibilidade</a></li>
<li><a href="#criptografia">Criptografia</a></li>
</ul>
<h2>Compila√ß√£o</h2>
<ul>
<li>Da √∫ltima vez, aprendemos a escrever nosso primeiro programa em C. Aprendemos a sintaxe para a fun√ß√£o <code>main</code> em nosso programa, a fun√ß√£o <code>printf</code> para imprimir no terminal, como criar strings com aspas duplas e como incluir <code>stdio.h</code> para a fun√ß√£o <code>printf</code>.</li>
<li>Em seguida, compilamos com <code>clang hello.c</code> para poder executar <code>./a.out</code> (o nome padr√£o) e <code>clang -o hello hello.c</code> (passando um argumento da linha de comando para o nome da sa√≠da) para poder executar <code>./hello</code>.</li>
<li>Se quis√©ssemos usar a biblioteca do CS50, via <code>#include &lt;cs50.h&gt;</code>, para strings e a fun√ß√£o <code>get_string</code>, tamb√©m temos que adicionar um sinalizador: <code>clang -o hello hello.c -lcs50</code>. O sinalizador <code>-l</code> vincula o arquivo <code>cs50</code>, que j√° est√° instalado no CS50 Sandbox, e inclui prot√≥tipos, ou defini√ß√µes de strings e <code>get_string</code> (entre mais) que nosso programa pode ent√£o fazer refer√™ncia e usar.</li>
<li>Escrevemos nosso c√≥digo-fonte em C, mas precisamos compil√°-lo em c√≥digo de m√°quina, em bin√°rio, antes que nossos computadores possam execut√°-lo.</li>
<li><code>clang</code> √© o compilador, e <code>make</code> √© um utilit√°rio que nos ajuda a executar o <code>clang</code> sem ter que indicar todas as op√ß√µes manualmente.</li>
<li>"Compilar" o c√≥digo-fonte em c√≥digo de m√°quina √©, na verdade, composto de etapas menores:<ul>
<li>pr√©-processamento</li>
<li>compila√ß√£o</li>
<li>montagem</li>
<li>linkagem</li>
</ul>
</li>
<li><strong>Pr√©-processamento</strong> envolve olhar para as linhas que come√ßam com um <code>#</code>, como <code>#include</code>, antes de tudo. Por exemplo, <code>#include &lt;cs50.h&gt;</code> dir√° ao <code>clang</code> que procure primeiro por esse arquivo de cabe√ßalho, pois ele cont√©m conte√∫do que queremos incluir em nosso programa. Ent√£o, <code>clang</code> essencialmente substituir√° o conte√∫do desses arquivos de cabe√ßalho em nosso programa.</li>
<li>
<p>Por exemplo ‚Ä¶</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>‚Ä¶ ser√° pr√©-processado em:</p>
<pre><code>  string get_string(string prompt);
  int printf(const char *format, ...);

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p><strong>Compila√ß√£o</strong> pega nosso c√≥digo-fonte, em C, e o converte em c√≥digo assembly, que se parece com isto:</p>
<pre><code>  ...
  main:                         # @main
      .cfi_startproc
  # BB#0:
      pushq    %rbp
  .Ltmp0:
      .cfi_def_cfa_offset 16
  .Ltmp1:
      .cfi_offset %rbp, -16
      movq    %rsp, %rbp
  .Ltmp2:
      .cfi_def_cfa_register %rbp
      subq    $16, %rsp
      xorl    %eax, %eax
      movl    %eax, %edi
      movabsq    $.L.str, %rsi
      movb    $0, %al
      callq    get_string
      movabsq    $.L.str.1, %rdi
      movq    %rax, -8(%rbp)
      movq    -8(%rbp), %rsi
      movb    $0, %al
      callq    printf
      ...
</code></pre>
</li>
<li>
<p>Essas instru√ß√µes s√£o de n√≠vel inferior e est√£o mais pr√≥ximas das instru√ß√µes bin√°rias que o CPU de um computador pode entender diretamente. Elas geralmente operam em bytes, ao contr√°rio de abstra√ß√µes como nomes de vari√°veis.</p>
</li>
<li>
<p>O pr√≥ximo passo √© pegar o c√≥digo assembly e traduzi-lo em instru√ß√µes em bin√°rio por <strong>montagem</strong>. As instru√ß√µes em bin√°rio s√£o chamadas de <strong>c√≥digo de m√°quina</strong>, que a CPU de um computador pode executar diretamente.</p>
</li>
<li>A √∫ltima etapa √© <strong>vincula√ß√£o</strong>, onde o conte√∫do de bibliotecas anteriormente compiladas que queremos vincular, como <code>cs50.c</code>, s√£o realmente combinadas com o bin√°rio de nosso programa. Ent√£o, acabamos com um arquivo bin√°rio, <code>a.out</code> ou <code>hello</code>, que √© a vers√£o compilada de <code>hello.c</code>, <code>cs50.c</code> e <code>printf.c</code>.</li>
</ul>
<h2>Depura√ß√£o</h2>
<ul>
<li>Bugs s√£o erros em programas que n√£o pretend√≠amos cometer. E a depura√ß√£o √© o processo de encontrar e corrigir bugs.</li>
</ul>
<h2>help50 e printf</h2>
<ul>
<li>
<p>Digamos que escrevemos este programa, <code>buggy0.c</code>:</p>
<pre><code>  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Vemos um erro (em vermelho), quando tentamos <code>make</code> este programa, que estamos <code>declarando implicitamente a fun√ß√£o de biblioteca 'printf'</code>. N√£o entendemos muito isso, ent√£o podemos executar <code>help50 make buggy0</code>, que nos dir√°, no final, que podemos ter esquecido de escrever <code>#include &lt;stdio.h&gt;</code>, que cont√©m <code>printf</code>.</li>
</ul>
</li>
<li>
<p>Podemos tentar novamente com <code>buggy1.c</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
<ul>
<li>Vemos muitos erros, e mesmo o primeiro n√£o parece fazer muito sentido. Ent√£o, podemos executar novamente <code>help50 make buggy1</code>, que ir√° nos sugerir que precisamos de <code>cs50.h</code> pois <code>string</code> n√£o est√° definido.</li>
</ul>
</li>
<li>
<p>Para limpar a janela do terminal (para que s√≥ possamos ver a sa√≠da do que quisermos executar em seguida), podemos pressionar <code>control + L</code>, ou digitar <code>clear</code> como um comando na janela do terminal.</p>
</li>
<li>
<p>Vamos dar uma olhada em <code>buggy2.c</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("#\n");
      }
  }
</code></pre>
<ul>
<li>
<p>Hmm, pretend√≠amos ver apenas 10 <code>#</code>, mas h√° 11. Se n√£o soub√©ssemos qual √© o problema (pois nosso programa est√° compilando sem nenhum erro, e agora temos um erro l√≥gico), poder√≠amos adicionar outra linha de impress√£o para nos ajudar:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("i agora √© %i: ", i);
          printf("#\n");
      }
  }
</code></pre>
</li>
<li>
<p>Agora, vemos que <code>i</code> come√ßou em 0 e continuou at√© chegar a 10, mas dever√≠amos interromper quando chegasse a 10, com <code>i &lt; 10</code> em vez de <code>i &lt;= 10</code>.</p>
</li>
</ul>
</li>
</ul>
<h2>debug50</h2>
<ul>
<li>Hoje tamb√©m daremos uma olhada no IDE do CS50, que √© como a Sandbox do CS50, mas com mais recursos. √â um ambiente de desenvolvimento online, com um editor de c√≥digo e uma janela de terminal, al√©m de ferramentas para depura√ß√£o e colabora√ß√£o:
  <img alt="Janela do navegador com IDE do CS50, editor de c√≥digo na parte superior com buggy2.c, janela do terminal na parte inferior" src="https://cs50.harvard.edu/x/2020/notes/2/cs50_ide.png" /></li>
<li>No IDE do CS50, teremos outra ferramenta, <code>debug50</code>, para nos ajudar a depurar programas.</li>
<li>Abriremos <code>buggy2.c</code> e tentaremos <code>make buggy2</code>. Mas salvamos <code>buggy2.c</code> em uma pasta chamada <code>src2</code>, ent√£o precisamos executar <code>cd src2</code> para alterar nosso diret√≥rio para o correto. E o terminal do IDE do CS50 ir√° nos lembrar em que diret√≥rio estamos, com um prompt como <code>~/src/ $</code>. (O <code>~</code> indica o padr√£o ou diret√≥rio inicial).</li>
<li>Em vez de usar <code>printf</code>, tamb√©m podemos depurar nosso programa interativamente. Podemos adicionar um <em>ponto de interrup√ß√£o</em>, ou um indicador para uma linha de c√≥digo em que o depurador deve pausar nosso programa. Por exemplo, podemos clicar √† esquerda da linha 5 de nosso c√≥digo, e um c√≠rculo vermelho aparecer√°:
  <img alt="Editor de c√≥digo com √≠cone vermelho ao lado da linha 5 de c√≥digo" src="https://cs50.harvard.edu/x/2020/notes/2/breakpoint.png" /></li>
<li>Agora, se executarmos <code>debug50 ./buggy2</code>, veremos o painel do depurador aberto √† direita:
  <img alt="Painel do depurador com controles, vari√°veis" src="https://cs50.harvard.edu/x/2020/notes/2/debugger_panel.png" /></li>
<li>Vemos que a vari√°vel que criamos, <code>i</code>, est√° na se√ß√£o <code>Vari√°veis Locais</code> e vemos que h√° um valor de <code>0</code>.</li>
<li>Nosso ponto de interrup√ß√£o pausou nosso programa ap√≥s a linha 5, logo antes da linha 7, pois √© a primeira linha de c√≥digo que pode ser executada. Para continuar, temos alguns controles no painel do depurador. O tri√¢ngulo azul continuar√° nosso programa at√© atingirmos outro ponto de interrup√ß√£o ou o final de nosso programa. A seta curva √† sua direita ir√° "passar por cima" da linha, executando-a e pausar nosso programa novamente imediatamente depois.</li>
<li>Ent√£o, usaremos a seta curva para executar a pr√≥xima linha e ver o que muda depois. Estamos na linha <code>printf</code> e pressionando a seta curva novamente, vemos um √∫nico <code>#</code> impresso em nossa janela de terminal. Com outro clique da seta, vemos que o valor da <code>i</code> √† direita muda para <code>1</code>. E podemos continuar clicando na seta para observar a execu√ß√£o do nosso programa, uma linha de cada vez.</li>
<li>Para sair do depurador, podemos pressionar <code>control + C</code> para interromper o programa.</li>
<li>Podemos economizar muito tempo no futuro investindo um pouco agora para aprender a usar o <code>debug50</code>!</li>
</ul>
<h2>check50 e style50</h2>
<ul>
<li>Podemos executar um comando como <code>check50 cs50/problems/hello</code>, onde <code>check50</code> √© um programa que seguir√° as instru√ß√µes identificadas pelo argumento <code>cs50/problems/hello</code> para carregar, executar e testar seu programa em servidores CS50. Isto checar√° a corre√ß√£o de seu programa.<ul>
<li>Ao escrever software no mundo real, os desenvolvedores geralmente escrever√£o seus pr√≥prios testes para garantir que seu c√≥digo funciona como esperado, especialmente quando mais funcionalidades s√£o adicionadas ao mesmo c√≥digo.</li>
</ul>
</li>
<li><code>style50</code> √© outro programa que checar√° nosso c√≥digo em busca de quest√µes est√©ticas, como espa√ßo em branco, de forma que nosso c√≥digo seja mais leg√≠vel e f√°cil de manter. Por exemplo, podemos estar perdendo recuo. E o <a href="https://cs50.readthedocs.io/style/c/">Guia de Estilo</a> incluir√° mais explica√ß√µes sobre o que esperamos.</li>
<li>Podemos at√© usar a depura√ß√£o de borracha de pato, um m√©todo no qual explicamos o que estamos tentando fazer para um pato de borracha, de forma que percebamos o que estamos tentando fazer e o que devemos corrigir.</li>
<li>Tamb√©m queremos escrever nosso c√≥digo com bom design, onde n√£o apenas resolvemos o problema corretamente, mas bem, onde fazemos escolhas razo√°veis de como nosso programa √© executado, e fazemos compensa√ß√µes entre tempo, custo de desenvolvimento e mem√≥ria.</li>
</ul>
<h2>Tipos de Dados</h2>
<ul>
<li>Em C, temos diferentes tipos de vari√°veis que podemos usar para armazenar dados:<ul>
<li>bool 1 byte</li>
<li>char 1 byte</li>
<li>int 4 bytes</li>
<li>float 4 bytes</li>
<li>long 8 bytes</li>
<li>double 8 bytes</li>
<li>string ? bytes</li>
</ul>
</li>
<li>Cada um destes tipos ocupa um determinado n√∫mero de bytes por vari√°vel que criamos, e os tamanhos acima s√£o o que a caixa de areia, IDE, e mais provavelmente seu computador usam para cada tipo em C.</li>
</ul>
<h2>Mem√≥ria</h2>
<ul>
<li>Dentro de nossos computadores, n√≥s temos chips chamados RAM, mem√≥ria de acesso aleat√≥rio, que armazena dados para uso a curto prazo. N√≥s podemos salvar um programa ou arquivo em nosso disco r√≠gido (ou SSD) para armazenamento a longo prazo, mas quando n√≥s o abrimos, ele √© primeiramente copiado para a RAM. Embora a RAM seja muito menor e tempor√°ria (at√© que a energia seja desligada), ela √© muito mais r√°pida.</li>
<li>N√≥s podemos pensar em bytes, armazenados na RAM, como se eles estivessem em uma grade:<br />
<img alt="chip do computador com grade sobreposta" src="https://cs50.harvard.edu/x/2020/notes/2/ram.png" /><ul>
<li>Na realidade, h√° milh√µes ou bilh√µes de bytes por chip.</li>
</ul>
</li>
<li>Em C, quando n√≥s criamos uma vari√°vel do tipo <code>char</code>, que ter√° o tamanho de um byte, ela ser√° fisicamente armazenada em uma daquelas caixinhas na RAM. Um inteiro, com 4 bytes, ocupar√° quatro daquelas caixinhas.</li>
<li>E cada uma dessas caixinhas √© rotulada com algum n√∫mero, ou endere√ßo, de 0 a 1, a 2 e assim por diante.</li>
</ul>
<h2>Arrays</h2>
<ul>
<li>
<p>Vamos dizer que queremos armazenar tr√™s vari√°veis:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char c1 = 'H';
      char c2 = 'I';
      char c3 = '!';
      printf("%c %c %c\n", c1, c2, c3);
  }
</code></pre>
<ul>
<li>Observe que usamos aspas simples para indicar um caractere literal e aspas duplas para v√°rios caracteres juntos em uma string.</li>
<li>Podemos compilar e executar isso para ver <code>H I !</code>.</li>
</ul>
</li>
<li>
<p>E sabemos que os caracteres s√£o apenas n√∫meros, portanto, se alterarmos nossa formata√ß√£o de string para <code>printf("%i %i %i\n", c1, c2, c3);</code>, podemos ver os valores num√©ricos de cada char impresso: <code>72 73 33</code>.</p>
<ul>
<li>Podemos converter ou lan√ßar explicitamente cada caractere em um int antes de us√°-lo com <code>(int) c1</code>, mas nosso compilador pode fazer isso implicitamente para n√≥s.</li>
</ul>
</li>
<li>E na mem√≥ria, podemos ter tr√™s caixas rotuladas como <code>c1</code>, <code>c2</code> e <code>c3</code>, cada uma representando um byte de bin√°rio com os valores de cada vari√°vel.</li>
<li>
<p>Vamos dar uma olhada em <code>scores0.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Pontua√ß√µes
      int score1 = 72;
      int score2 = 73;
      int score3 = 33;

      // Imprimir m√©dia
      printf("M√©dia: %i\n", (score1 + score2 + score3) / 3);
  }
</code></pre>
<ul>
<li>Podemos imprimir a m√©dia de tr√™s n√∫meros, mas agora precisamos criar uma vari√°vel para cada escore que queremos incluir e n√£o podemos us√°-las facilmente mais tarde.</li>
</ul>
</li>
<li>
<p>Acontece que, na mem√≥ria, podemos armazenar vari√°veis umas ap√≥s as outras, consecutivamente. E em C, uma lista de vari√°veis armazenadas uma ap√≥s a outra em um peda√ßo cont√≠guo de mem√≥ria √© chamada de <strong>array</strong>.</p>
</li>
<li>Por exemplo, podemos usar <code>int scores[3];</code> para declarar um array de 3 inteiros.</li>
<li>
<p>E podemos atribuir e usar vari√°veis em um array com:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Pontua√ß√µes
      int scores[3];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Imprimir m√©dia
      printf("M√©dia: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
  }
</code></pre>
<ul>
<li>Observe que os arrays s√£o indexados por zero, o que significa que o primeiro elemento, ou valor, tem √≠ndice 0.</li>
</ul>
</li>
<li>
<p>E repetimos o valor 3, representando o comprimento de nosso array, em dois lugares diferentes. Portanto, podemos usar uma constante ou valor fixo para indicar que ele sempre deve ser o mesmo nos dois lugares:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  const int N = 3;

  int main(void)
  {
      // Pontua√ß√µes
      int scores[N];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Imprimir m√©dia
      printf("M√©dia: %i\n", (scores[0] + scores[1] + scores[2]) / N);
  }
</code></pre>
<ul>
<li>Podemos usar a palavra-chave <code>const</code> para dizer ao compilador que o valor de <code>N</code> nunca deve ser alterado por nosso programa. E por conven√ß√£o, colocaremos nossa declara√ß√£o da vari√°vel fora da fun√ß√£o <code>main</code> e colocaremos seu nome em mai√∫sculas, o que n√£o √© necess√°rio para o compilador, mas mostra a outros humanos que esta vari√°vel √© uma constante e torna f√°cil de ver desde o come√ßo.</li>
</ul>
</li>
<li>
<p>Com um array, podemos coletar nossas pontua√ß√µes em um loop e acess√°-las mais tarde em um loop tamb√©m:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  float average(int length, int array[]);

  int main(void)
  {
      // Obter o n√∫mero de pontua√ß√µes
      int n = get_int("Pontua√ß√µes:  ");

      // Obter pontua√ß√µes
      int scores[n];
      for (int i = 0; i &lt; n; i++)
      {
          scores[i] = get_int("Pontua√ß√£o %i: ", i + 1);
      }

      // Imprimir m√©dia
      printf("M√©dia: %.1f\n", average(n, scores));
  }

  float average(int length, int array[])
  {
      int sum = 0;
      for (int i = 0; i &lt; length; i++)
      {
          sum += array[i];
      }
      return (float) sum / (float) length;
  }
</code></pre>
<ul>
<li>Primeiro, pediremos ao usu√°rio o n√∫mero de pontua√ß√µes que ele possui, criaremos um array com <code>ints</code> suficientes para o n√∫mero de pontua√ß√µes que ele possui e usaremos um loop para coletar todas as pontua√ß√µes.</li>
<li>Em seguida, escreveremos uma fun√ß√£o auxiliar, <code>average</code>, para retornar um <code>float</code> ou um valor decimal. Vamos passar o comprimento e um array de <code>ints</code> (que pode ser de qualquer tamanho) e usar outro loop dentro de nossa fun√ß√£o auxiliar para adicionar os valores em uma soma. Usamos <code>(float)</code> para converter <code>sum</code> e <code>length</code> em floats, portanto, o resultado que obtemos ao dividir os dois tamb√©m √© um float.</li>
<li>Por fim, quando imprimimos o resultado que obtemos, usamos <code>%.1f</code> para mostrar apenas um lugar ap√≥s a v√≠rgula decimal.</li>
</ul>
</li>
<li>
<p>Na mem√≥ria, nosso array √© armazenado assim, onde cada valor ocupa n√£o um, mas quatro bytes:<br />
<img alt="grade com 72 chamado score1, 73 chamado score2, 33 chamado score3, cada um ocupando quatro caixas e muitas caixas vazias a seguir" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_array.png" /></p>
</li>
</ul>
<h2>Strings</h2>
<ul>
<li>Strings s√£o na verdade apenas matrizes de caracteres. Se tivermos uma string <code>s</code>, cada caractere pode ser acessado com <code>s[0]</code>, <code>s[1]</code> e assim por diante.</li>
<li>E acontece que uma string termina com um caractere especial, '\0', ou um byte com todos os bits definidos como 0. Esse caractere √© chamado de caractere nulo ou caractere de termina√ß√£o nulo. Portanto, precisamos de quatro bytes para armazenar nossa string ‚ÄúHI!‚Äù:
  <img alt="grade com H rotulado s[0], I rotulado s[1],! rotulado s[2], \0 rotulado s[3], cada um ocupando uma caixa, e muitas caixas vazias seguindo" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png" /></li>
<li>
<p>Agora vamos ver como quatro strings em um array podem se parecer:</p>
<pre><code>  nomes de string[4];
  names[0] = "EMMA";
  names[1] = "RODRIGO";
  names[2] = "BRIAN";
  names[3] = "DAVID";

  printf("%s\n", nomes[0]);
  printf("%c%c%c%c\n", nomes[0][0], nomes[0][1], nomes[0][2], nomes[0][3]);
</code></pre>
<ul>
<li>Podemos imprimir o primeiro valor em 'nomes' como uma string, ou podemos obter a primeira string e obter cada caractere individual naquela string usando '[]' novamente. (Podemos pensar nisso como '(names[0])[0]', embora n√£o precisemos dos par√™nteses.)</li>
<li>E embora saibamos que o primeiro nome tinha quatro caracteres, <code>printf</code> provavelmente usou um loop para olhar cada caractere na string, imprimindo-os um de cada vez at√© chegar ao caractere nulo que marca o final da string. E, de fato, podemos imprimir<code>names[0][4]</code>como um<code>int</code>com<code>%i</code> e ver um <code>0</code> sendo impresso.</li>
</ul>
</li>
<li>
<p>Podemos visualizar cada caractere com seu pr√≥prio r√≥tulo na mem√≥ria:
  <img alt="grade com E rotulado names[0][0], M rotulado names[0][1] e assim por diante, at√© names[3][5] com um \0, cada um ocupando uma caixa e caixas vazias seguindo" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png" /></p>
</li>
<li>
<p>Podemos tentar fazer experi√™ncias com <code>string0.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Entrada: ");
      printf("Sa√≠da: ");
      para (int i = 0; i &lt; strlen(s); i++)
      {
          printf("%c", s[i]);
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Podemos usar a condi√ß√£o <code>s[i] != '\0'</code>, onde podemos verificar o caractere atual e imprimi-lo apenas se ele n√£o for o caractere nulo.</li>
<li>Tamb√©m podemos usar o comprimento da string, mas primeiro precisamos de uma nova biblioteca, <code>string.h</code>, para <code>strlen</code>, que nos diz o comprimento de uma string.</li>
</ul>
</li>
<li>
<p>Podemos melhorar o design do nosso programa. <code>string0</code> foi um pouco ineficiente, pois verificamos o comprimento da string, ap√≥s cada caractere ser impresso, em nossa condi√ß√£o. Mas como o comprimento da string n√£o muda, podemos verificar o comprimento da string uma vez:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Entrada: ");
      printf("Sa√≠da:\n");
      para (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c\n", s[i]);
      }
  }
</code></pre>
<ul>
<li>Agora, no in√≠cio do nosso loop, inicializamos uma vari√°vel <code>i</code> e <code>n</code> e lembre-se do comprimento de nossa string em <code>n</code>. Ent√£o, podemos verificar os valores a cada vez, sem ter que realmente calcular o comprimento da string.</li>
<li>E precisamos usar um pouco mais de mem√≥ria para <code>n</code>, mas isso economiza algum tempo ao n√£o ter que verificar o comprimento da string a cada vez.</li>
</ul>
</li>
<li>
<p>Agora podemos combinar o que vimos, para escrever um programa que pode colocar letras em mai√∫sculas:</p>
<pre><code>  # include &lt;cs50.h&gt;
  # include &lt;stdio.h&gt;
  # include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Antes: ");
      printf("Depois:  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')
          {
              printf("%c", s[i] - 32);
          }
          else
          {
              printf("%c", s[i]);
          }
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Primeiro, obtemos uma string <code>s</code>. Ent√£o, para cada caractere na string, se for min√∫scula (seu valor est√° entre o de <code>a</code> e <code>z</code>), n√≥s a convertemos para mai√∫scula. De outra forma, n√≥s apenas a imprimimos.</li>
<li>N√≥s podemos converter uma letra min√∫scula em sua equivalente mai√∫scula, subtraindo a diferen√ßa entre seus valores ASCII. (N√≥s sabemos que letras min√∫sculas t√™m um valor ASCII maior do que letras mai√∫sculas, e a diferen√ßa √© convenientemente a mesma entre as mesmas letras, ent√£o podemos subtrair essa diferen√ßa para obter uma letra mai√∫scula de uma letra min√∫scula.)</li>
</ul>
</li>
<li>
<p>N√≥s podemos utilizar as <a href="https://man.cs50.io/"><strong>p√°ginas do manual</strong></a>, ou manual do programador, para encontrar fun√ß√µes de biblioteca que podemos utilizar para realizar a mesma coisa:</p>
<pre><code>  # include &lt;cs50.h&gt;
  # include &lt;ctype.h&gt;
  # include &lt;stdio.h&gt;
  # include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Antes: ");
      printf("Depois:  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c", toupper(s[i]));
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Ao pesquisar as p√°ginas do manual, vemos <code>toupper()</code> √© uma fun√ß√£o, entre outras, de uma biblioteca chamada <code>ctype</code>, que podemos utilizar.</li>
</ul>
</li>
</ul>
<h2>Argumentos de linha de comando</h2>
<ul>
<li>Usamos programas como <code>make</code> e <code>clang</code>, que aceitam palavras extras ap√≥s seu nome na linha de comando. Acontece que programas pr√≥prios tamb√©m podem aceitar <strong>argumentos de linha de comando</strong>.</li>
<li>
<p>Em <code>argv.c</code>, mudamos como nossa fun√ß√£o <code>main</code> se parece:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(int argc, string argv[])
  {
      if (argc == 2)
      {
          printf("hello, %s\n", argv[1]);
      }
      else
      {
          printf("hello, world\n");
      }
  }
</code></pre>
<ul>
<li><code>argc</code> e <code>argv</code> s√£o duas vari√°veis que nossa fun√ß√£o <code>main</code> agora receber√° quando nosso programa for executado a partir da linha de comando. <code>argc</code> √© a contagem de argumentos, ou o n√∫mero de argumentos, e <code>argv</code> √© um array de strings que s√£o os argumentos. E o primeiro argumento, <code>argv[0]</code>, √© o nome do nosso programa (a primeira palavra digitada, como <code>./hello</code>). Neste exemplo, verificamos se temos dois argumentos e imprimimos o segundo se for o caso.</li>
<li>Por exemplo, se executarmos <code>./argv David</code>, veremos <code>hello, David</code> impresso, j√° que digitamos <code>David</code> como a segunda palavra em nosso comando.</li>
</ul>
</li>
<li>
<p>Acontece que podemos indicar erros em nosso programa retornando um valor da nossa fun√ß√£o <code>main</code> (como implicado pelo <code>int</code> antes da nossa fun√ß√£o <code>main</code>). Por padr√£o, nossa fun√ß√£o <code>main</code> retorna <code>0</code> para indicar que nada deu errado, mas podemos escrever um programa para retornar um valor diferente:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(int argc, string argv[])
  {
      if (argc != 2)
      {
          printf("missing command-line argument\n");
          return 1;
      }
      printf("hello, %s\n", argv[1]);
      return 0;
  }
</code></pre>
<ul>
<li>O valor de retorno de <code>main</code> em nosso programa √© chamado de c√≥digo de sa√≠da.</li>
</ul>
</li>
<li>
<p>√Ä medida que escrevemos programas mais complexos, c√≥digos de erro como este podem nos ajudar a determinar o que deu errado, mesmo que n√£o seja vis√≠vel ou significativo para o usu√°rio.</p>
</li>
</ul>
<h2>Legibilidade</h2>
<ul>
<li>Agora que sabemos como trabalhar com strings em nossos programas, podemos analisar par√°grafos de texto quanto ao seu n√≠vel de legibilidade, com base em fatores como qu√£o longas e complicadas as palavras e as frases s√£o.</li>
</ul>
<h2>Criptografia</h2>
<ul>
<li>Se quis√©ssemos enviar uma mensagem a algu√©m, podemos querer <strong>criptografar</strong>, ou seja, embaralhar essa mensagem de alguma forma para que fosse dif√≠cil para outras pessoas lerem. A mensagem original, ou entrada do nosso algoritmo, √© chamada de <strong>texto n√£o criptografado</strong> e a mensagem criptografada, ou sa√≠da, √© chamada de <strong>texto criptografado</strong>.</li>
<li>Uma mensagem como <code>OI!</code> poderia ser convertida em ASCII, <code>72 73 33</code>. Mas qualquer pessoa poderia converter isso de volta em letras.</li>
<li>Um algoritmo de criptografia geralmente requer outra entrada, al√©m do texto n√£o criptografado. √â necess√°rio uma <strong>chave</strong> e, √†s vezes, √© simplesmente um n√∫mero mantido em segredo. Com a chave, o texto n√£o criptografado pode ser convertido, por meio de algum algoritmo, em texto criptografado e vice-versa.</li>
<li>Por exemplo, se quis√©ssemos enviar uma mensagem como <code>EU AMO VOC√ä</code>, poder√≠amos primeiro convert√™-la em ASCII: <code>73 76 79 86 69 89 79 85</code>. Em seguida, podemos criptograf√°-la com uma chave de apenas <code>1</code> e um algoritmo simples, no qual apenas adicionamos a chave a cada valor: <code>74 77 80 87 70 90 80 86</code>. Ent√£o, algu√©m que converta esse ASCII de volta em texto ver√° <code>JM PWF ZPV</code>. Para descriptografar isso, algu√©m precisar√° saber a chave.</li>
<li>Vamos aplicar esses conceitos em nosso conjunto de problemas!</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>