<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em PortuguÃªs</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em PortuguÃªs</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        MemÃ³ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        SeguranÃ§a CibernÃ©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade AcadÃªmica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">PÃ¡ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Aula 3</h1>
<ul>
<li><a href="#busca">Busca</a></li>
<li><a href="#grande-o">Grande O</a></li>
<li><a href="#busca-linear">Busca linear</a></li>
<li><a href="#estruturas">Estruturas</a></li>
<li><a href="#ordenaÃ§Ã£o">OrdenaÃ§Ã£o</a></li>
<li><a href="#ordenaÃ§Ã£o-por-seleÃ§Ã£o">OrdenaÃ§Ã£o por seleÃ§Ã£o</a></li>
<li><a href="#recursÃ£o">RecursÃ£o</a></li>
<li><a href="#ordenaÃ§Ã£o-por-mesclagem">OrdenaÃ§Ã£o por mesclagem</a></li>
</ul>
<h2>Busca</h2>
<ul>
<li>Da Ãºltima vez, falamos sobre a memÃ³ria em um computador ou RAM e sobre como nossos dados podem ser armazenados como variÃ¡veis â€‹â€‹individuais ou como matrizes de muitos itens ou elementos.</li>
<li>Podemos pensar em uma matriz com vÃ¡rios itens como uma fileira de armÃ¡rios, onde um computador sÃ³ pode abrir um armÃ¡rio para olhar um item, um de cada vez.</li>
<li>Por exemplo, se quisermos verificar se um nÃºmero estÃ¡ em uma matriz, com um algoritmo que utiliza uma matriz como entrada e produz um booleano como resultado, podemos:<ul>
<li>examinar cada armÃ¡rio ou cada elemento, um de cada vez, do inÃ­cio ao fim.<ul>
<li>Isso Ã© chamado de <strong>busca linear</strong>, em que nos movemos em uma linha, jÃ¡ que nossa matriz nÃ£o Ã© classificada.</li>
</ul>
</li>
<li>iniciar no meio e mover para a esquerda ou direita dependendo do que estamos procurando, se nossa matriz de itens for classificada.<ul>
<li>Isso Ã© chamado de <strong>busca binÃ¡ria</strong>, jÃ¡ que podemos dividir nosso problema em dois a cada passo, como Davi fez com a lista telefÃ´nica na semana 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Podemos escrever pseudocÃ³digo para a busca linear com:</p>
<pre><code>  Para i de 0 a n â€“ 1
      Se o i-Ã©simo elemento for 50
          Retornar verdadeiro
  Retornar falso
</code></pre>
<ul>
<li>Podemos rotular cada um dos <code>n</code> armÃ¡rios de <code>0</code> a <code>n â€“ 1</code> e verificar cada um deles em ordem.</li>
</ul>
</li>
<li>
<p>Para a busca binÃ¡ria, nosso algoritmo pode ter a seguinte aparÃªncia:</p>
<pre><code>  Se nÃ£o houver itens
      Retornar falso
  Se o item do meio for 50
      Retornar verdadeiro
  Sendo contrÃ¡rio, se 50 &lt; item do meio
      Buscar metade esquerda
  Sendo contrÃ¡rio, se 50 &gt; item do meio
      Buscar metade direita
</code></pre>
<ul>
<li>Eventualmente, nÃ£o teremos mais partes da matriz sobrando (se o item que queremos nÃ£o estiver lÃ¡), para que possamos retornar <code>falso</code>.</li>
<li>Caso contrÃ¡rio, podemos pesquisar cada metade dependendo do valor do item do meio.</li>
</ul>
</li>
</ul>
<h2>Big O</h2>
<ul>
<li>Na semana 0, vimos diferentes tipos de algoritmos e seus tempos de execuÃ§Ã£o: <img alt="grÃ¡fico com: &quot;tamanho do problema&quot; no eixo x; &quot;tempo para resolver&quot; no eixo y; linha reta vermelha e Ã­ngreme da origem ao topo do grÃ¡fico rotulada &quot;n&quot;; linha reta amarela menos Ã­ngreme da origem ao topo do grÃ¡fico rotulada &quot;n/2&quot;; linha curva verde menos Ã­ngreme da origem para a direita do grÃ¡fico rotulada &quot;log_2 n&quot;" src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" /></li>
<li>A maneira mais formal de descrever isso Ã© com a notaÃ§Ã£o big <em>O</em>, que podemos entender como â€œda ordem deâ€. Por exemplo, se nosso algoritmo for a pesquisa linear, ele levarÃ¡ aproximadamente <em>O</em>(<em>n</em>) passos, "da ordem de <em>n</em>". Na verdade, atÃ© mesmo um algoritmo que examina dois itens por vez e leva <em>n</em>/2 passos tem <em>O</em>(<em>n</em>). Isso ocorre porque, Ã  medida que <em>n</em> fica cada vez maior, somente o termo maior, <em>n</em>, importa.</li>
<li>Da mesma forma, um tempo de execuÃ§Ã£o logarÃ­tmico Ã© <em>O</em>(log <em>n</em>), nÃ£o importa qual seja a base, jÃ¡ que Ã© apenas uma aproximaÃ§Ã£o do que acontece quando <em>n</em> Ã© muito grande.</li>
<li>Existem alguns tempos de execuÃ§Ã£o comuns:
    - <em>O</em>(_n_2)
    - <em>O</em>(<em>n</em> log <em>n</em>)
    - <em>O</em>(<em>n</em>)
        - (busca linear)
    - <em>O</em>(log <em>n</em>)
        - (busca binÃ¡ria)
    - <em>O</em>(1)</li>
<li>Os cientistas da computaÃ§Ã£o tambÃ©m podem usar a notaÃ§Ã£o big Î©, big Omega, que Ã© o limite inferior do nÃºmero de etapas para nosso algoritmo. (Big <em>O</em> Ã© o limite superior do nÃºmero de etapas, ou o pior caso, e normalmente Ã© o que mais nos importa.) Com a busca linear, por exemplo, o pior caso Ã© <em>n</em> etapas, mas o melhor caso Ã© 1 etapa, jÃ¡ que nosso item pode ser o primeiro item que verificamos. O melhor caso para a busca binÃ¡ria tambÃ©m Ã© 1, jÃ¡ que nosso item pode estar no meio da matriz.</li>
<li>E temos um conjunto semelhante dos tempos de execuÃ§Ã£o big Î© mais comuns:
    - Î©(_n_2)
    - Î©(<em>n</em> log <em>n</em>)
    - Î©(<em>n</em>)
        - (contar o nÃºmero de itens)
    - Î©(log <em>n</em>)
    - Î©(1)
        - (busca linear, busca binÃ¡ria)</li>
</ul>
<h2>Pesquisa linear</h2>
<ul>
<li>
<p>Vamos dar uma olhada no <code>numbers.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Uma matriz de nÃºmeros
      int numbers[] = {4, 8, 15, 16, 23, 42};

      // Pesquisar por 50
      for (int i = 0; i &lt; 6; i++)
      {
          if (numbers[i] == 50)
          {
              printf("Encontrado\n");
              return 0;
          }
      }
      printf("NÃ£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Aqui inicializamos uma matriz com alguns valores e verificamos os itens na matriz um de cada vez, em ordem.</li>
<li>E em cada caso, dependendo se o valor foi encontrado ou nÃ£o, podemos retornar um cÃ³digo de saÃ­da de 0 (para sucesso) ou 1 (para falha).</li>
</ul>
</li>
<li>
<p>Podemos fazer o mesmo para nomes:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      // Uma matriz de nomes
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};

      // Pesquisar por EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("Encontrado\n");
              return 0;
          }
      }
      printf("NÃ£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>NÃ£o podemos comparar strings diretamente, pois elas nÃ£o sÃ£o um tipo de dados simples, mas sim uma matriz de vÃ¡rios caracteres. Precisamos comparÃ¡-las de forma diferente. Felizmente, a biblioteca <code>string</code> tem uma funÃ§Ã£o <code>strcmp</code> que compara strings para nÃ³s e retorna <code>0</code> se forem iguais, entÃ£o podemos usÃ¡-la.</li>
</ul>
</li>
<li>
<p>Vamos tentar implementar uma agenda telefÃ´nica com as mesmas ideias:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
      string numbers[] = {"617â€“555â€“0100", "617â€“555â€“0101", "617â€“555â€“0102", "617â€“555â€“0103"};

      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("Encontrado %s\n", numbers[i]);
              return 0;
          }
      }
      printf("NÃ£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Usaremos strings para nÃºmeros de telefone, pois elas podem incluir formataÃ§Ã£o ou ser muito longas para um nÃºmero.</li>
<li>Agora, se o nome em um determinado Ã­ndice na matriz <code>names</code> corresponder a quem estamos procurando, retornaremos o nÃºmero de telefone na matriz <code>numbers</code>, no mesmo Ã­ndice. Mas isso significa que precisamos ter muito cuidado para garantir que cada nÃºmero corresponda ao nome em cada Ã­ndice, especialmente se adicionarmos ou removermos nomes e nÃºmeros.</li>
</ul>
</li>
</ul>
<h2>Structs</h2>
<ul>
<li>
<p>Acontece que podemos criar nossos prÃ³prios tipos de dados personalizados chamados <strong>structs</strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  person;

  int main(void)
  {
      person people[4];

      people[0].name = "EMMA";
      people[0].number = "617â€“555â€“0100";

      people[1].name = "RODRIGO";
      people[1].number = "617â€“555â€“0101";

      people[2].name = "BRIAN";
      people[2].number = "617â€“555â€“0102";

      people[3].name = "DAVID";
      people[3].number = "617â€“555â€“0103";

      // Buscar por EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, "EMMA") == 0)
          {
              printf("Encontrado %s\n", people[i].number);
              return 0;
          }
      }
      printf("NÃ£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Podemos pensar em structs como contÃªineres que podem armazenar vÃ¡rios outros tipos de dados.</li>
<li>Aqui, criamos um novo tipo utilizando uma struct chamada <code>person</code>, que terÃ¡ uma <code>string</code> chamada <code>name</code> e uma <code>string</code> chamada <code>number</code>. Em seguida, podemos criar uma array com esses tipos de struct e inicializar os valores presentes em cada uma delas utilizando uma nova sintaxe, <code>.</code>, para acessar as propriedades de cada <code>person</code>.</li>
<li>Em nosso loop, podemos agora ter mais certeza de que o <code>number</code> corresponde ao <code>name</code>, visto que pertencem ao mesmo elemento <code>person</code>.</li>
</ul>
</li>
</ul>
<h2>OrdenaÃ§Ã£o</h2>
<ul>
<li>Se nossa entrada for uma lista nÃ£o ordenada de nÃºmeros, hÃ¡ muitos algoritmos que poderÃ­amos usar para produzir uma saÃ­da de uma lista ordenada.</li>
<li>Com oito voluntÃ¡rios no palco com os seguintes nÃºmeros, poderÃ­amos considerar a troca de pares de nÃºmeros prÃ³ximos como o primeiro passo.</li>
<li>
<p>Nossos voluntÃ¡rios comeÃ§am na seguinte ordem aleatÃ³ria:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Observamos os primeiros dois nÃºmeros e os trocamos para que fiquem em ordem:</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“ â€“
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>O prÃ³ximo par, <code>6</code> e <code>8</code>, estÃ¡ em ordem, por isso, nÃ£o precisamos trocÃ¡-los.</p>
</li>
<li>
<p>O prÃ³ximo par, <code>8</code> e <code>5</code>, precisa ser trocado:</p>
<pre><code>  3 6 8 5 2 7 4 1
      â€“ â€“
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Continuamos atÃ© o final da lista:</p>
<pre><code>  3 6 5 2 8 7 4 1
          â€“ â€“
  3 6 5 2 7 8 4 1
            â€“ â€“
  3 6 5 2 7 4 8 1
              â€“ â€“
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>Nossa lista ainda nÃ£o estÃ¡ ordenada, mas estamos um passo mais perto da soluÃ§Ã£o porque o valor mais alto, <code>8</code>, foi deslocado para a direita.</p>
</li>
<li>
<p>Repetimos com outra passagem pela lista:</p>
<pre><code>  3 6 5 2 7 4 1 8
  â€“ â€“
  3 6 5 2 7 4 1 8
    â€“ â€“
  3 5 6 2 7 4 1 8
      â€“ â€“
  3 5 2 6 7 4 1 8
        â€“ â€“
  3 5 2 6 7 4 1 8
          â€“ â€“
  3 5 2 6 4 7 1 8
              â€“ â€“
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Note que nÃ£o precisamos trocar 3 e 6, ou 6 e 7.</li>
</ul>
</li>
<li>
<p>Agora, o prÃ³ximo maior valor, <code>7</code>, foi movido para a direita. Se repetirmos isso, cada vez mais da lista fica ordenada e, rapidamente, teremos uma lista totalmente ordenada.</p>
</li>
<li>
<p>Esse algoritmo Ã© chamado de <strong>bubble sort</strong>, em que os valores altos "borbulham" para a direita. O pseudocÃ³digo para ele pode ser:</p>
<pre><code>  Repetir nÂ -Â 1 vezes
      Para i de 0 a nÂ -Â 2
          Se os Ã©simos e Ã©simo + 1 elementos estiverem fora de ordem
              TrocÃ¡-los
</code></pre>
<ul>
<li>Como estamos comparando os elementos Ã©simo e Ã©simo + 1, precisamos subir apenas atÃ© nÂ -Â 2 para i. Em seguida, trocamos os dois elementos se estiverem fora de ordem.</li>
<li>E podemos parar depois que tivermos feito nÂ -Â 1 passagens, jÃ¡ que sabemos que os maiores nÂ -Â 1 elementos terÃ£o borbulhado para a direita.</li>
</ul>
</li>
<li>
<p>Temos nÂ -Â 2 etapas para o laÃ§o interno e nÂ -Â 1 laÃ§os, entÃ£o temos um total de n2Â -Â 3nÂ +Â 2 etapas. Mas o maior fator, ou termo dominante, Ã© n2, Ã  medida que n fica cada vez maior, entÃ£o, podemos dizer que o bubble sort Ã© _O_(_n_2).</p>
</li>
<li>Vimos tempos de execuÃ§Ã£o como o seguinte, portanto, embora a pesquisa binÃ¡ria seja muito mais rÃ¡pida que a pesquisa linear, pode nÃ£o valer o custo Ãºnico de ordenar a lista primeiro, a menos que faÃ§amos muitas pesquisas ao longo do tempo:<ul>
<li><em>O</em>(_n_2)<ul>
<li>bubble sort</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>pesquisa linear</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>pesquisa binÃ¡ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>E o Î© para bubble sort ainda Ã© n2, jÃ¡ que ainda verificamos cada par de elementos por nÂ -Â 1 passagens.</li>
</ul>
<h2>ClassificaÃ§Ã£o por seleÃ§Ã£o</h2>
<ul>
<li>
<p>Podemos adotar outra abordagem com o mesmo conjunto de nÃºmeros:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Primeiro, vamos analisar cada nÃºmero e lembrar do menor nÃºmero que vimos. Em seguida, podemos trocÃ¡-lo pelo primeiro nÃºmero em nossa lista, jÃ¡ que sabemos que ele Ã© o menor:</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“             â€“
  1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Agora sabemos que pelo menos o primeiro elemento de nossa lista estÃ¡ no lugar certo, entÃ£o podemos procurar o menor elemento entre os demais e trocÃ¡-lo pelo prÃ³ximo elemento nÃ£o classificado (agora o segundo elemento):</p>
<pre><code>  1 3 8 5 2 7 4 6
    â€“     â€“
  1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Podemos repetir isso vÃ¡rias vezes atÃ© termos uma lista classificada.</p>
</li>
<li>
<p>Esse algoritmo Ã© chamado de <strong>classificaÃ§Ã£o por seleÃ§Ã£o</strong>, e podemos escrever o pseudocÃ³digo da seguinte forma:</p>
<pre><code>  Para i de 0 atÃ© nâ€“1
      Encontre o menor item entre o item i e o Ãºltimo item
      Troque o menor item pelo item i
</code></pre>
</li>
<li>
<p>Com a grande notaÃ§Ã£o <em>O</em>, ainda temos tempo de execuÃ§Ã£o de <em>O</em>(<em>n_2), jÃ¡ que estÃ¡vamos olhando para aproximadamente todos os elementos _n</em> para encontrar o menor e fazendo <em>n</em> passagens para classificar todos os elementos.</p>
</li>
<li>
<p>Mais formalmente, podemos usar algumas fÃ³rmulas para mostrar que o maior fator Ã© realmente _n_2:</p>
<pre><code>  n + (n â€“ 1) + (n â€“ 2) + ... + 1
  n(n + 1)/2
  (n^2 + n)/2
  n^2/2 + n/2
  O(n^2)
</code></pre>
</li>
<li>
<p>Portanto, descobrimos que a classificaÃ§Ã£o por seleÃ§Ã£o Ã© fundamentalmente igual Ã  classificaÃ§Ã£o por bolhas no tempo de execuÃ§Ã£o:</p>
<ul>
<li><em>O</em>(_n_2)<ul>
<li>ClassificaÃ§Ã£o por bolhas, classificaÃ§Ã£o por seleÃ§Ã£o</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>Pesquisa linear</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>Pesquisa binÃ¡ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>O melhor caso, Î©, tambÃ©m Ã© _n_2.</li>
<li>
<p>Podemos voltar Ã  classificaÃ§Ã£o por bolhas e mudar seu algoritmo para algo assim, o que nos permitirÃ¡ parar mais cedo se todos os elementos forem classificados:</p>
<pre><code>  Repetir atÃ© que nÃ£o haja trocas
      Para i de 0 a nâ€“2
          Se os elementos i e i+1 estiverem fora de ordem
              Troque-os
</code></pre>
</li>
<li>
<p>Agora, sÃ³ precisamos analisar cada elemento uma vez, entÃ£o o melhor caso agora Ã© Î©(<em>n</em>):
    - Î©(_n_2)
      - ClassificaÃ§Ã£o por seleÃ§Ã£o
    - Î©(<em>n</em> log <em>n</em>)
    - Î©(<em>n</em>)
      - ClassificaÃ§Ã£o por bolhas
    - Î©(log <em>n</em>)
    - Î©(1)
      - Pesquisa linear, pesquisa binÃ¡ria</p>
</li>
<li>
<p>Analisamos uma visualizaÃ§Ã£o on-line <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparando algoritmos de classificaÃ§Ã£o</a> com animaÃ§Ãµes de como os elementos se movem dentro dos arrays para a classificaÃ§Ã£o por bolhas e a classificaÃ§Ã£o por seleÃ§Ã£o.</p>
</li>
</ul>
<h2><strong>RecursÃ£o</strong></h2>
<ul>
<li>
<p>Lembre-se que na semana 0, tÃ­nhamos um pseudocÃ³digo para encontrar um nome em uma lista telefÃ´nica, onde tÃ­nhamos linhas nos dizendo para "voltar" e repetir alguns passos:</p>
<pre><code>  1  Pegue a lista telefÃ´nica
  2  Abra a lista telefÃ´nica no meio
  3  Veja a pÃ¡gina
  4  Se Smith estiver na pÃ¡gina
  5      Ligue para Mike
  6  SenÃ£o se Smith estiver antes no livro
  7      Abra no meio da metade esquerda do livro
  8      **Volte para a linha 3**
  9  SenÃ£o se Smith estiver depois no livro
  10     Abra no meio da metade direita do livro
  11     **Volte para a linha 3**
  12 SenÃ£o
  13     Sair
</code></pre>
</li>
<li>
<p>Em vez disso, poderÃ­amos repetir todo o nosso algoritmo na metade do livro que nos restou:</p>
<pre><code>  1  Pegue a lista telefÃ´nica
  2  Abra a lista telefÃ´nica no meio
  3  Veja a pÃ¡gina
  4  Se Smith estiver na pÃ¡gina
  5      Ligue para Mike
  6  SenÃ£o se Smith estiver antes no livro
  7      **Procure na metade esquerda do livro**
  8
  9  SenÃ£o se Smith estiver depois no livro
  10     **Procure na metade direita do livro**
  11
  12 SenÃ£o
  13     Sair
</code></pre>
<ul>
<li>Isso parece um processo cÃ­clico que nunca terminarÃ¡, mas, na verdade, estamos dividindo o problema pela metade a cada vez e parando quando nÃ£o houver mais livro.</li>
</ul>
</li>
<li>
<p><strong>RecursÃ£o</strong> ocorre quando uma funÃ§Ã£o ou algoritmo se refere a si mesmo, como no novo pseudocÃ³digo acima.</p>
</li>
<li>
<p>TambÃ©m na semana 1, implementamos uma "pirÃ¢mide" de blocos na seguinte forma:</p>
<pre><code>  #
  ##
  ###
  ####
</code></pre>
<ul>
<li>
<p>E poderÃ­amos ter um cÃ³digo iterativo como este:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenha a altura da pirÃ¢mide
      int height = get_int("Altura: ");

      // Desenhe a pirÃ¢mide
      draw(height);
  }

  void draw(int h)
  {
      // Desenhar pirÃ¢mide de altura h
      for (int i = 1; i &lt;= h; i++)
      {
          for (int j = 1; j &lt;= i; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
<ul>
<li>Aqui, usamos loops <code>for</code> para imprimir cada bloco em cada linha.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mas observe que uma pirÃ¢mide de altura 4 Ã© na verdade uma pirÃ¢mide de altura 3, com uma linha extra de 4 blocos adicionados. E uma pirÃ¢mide de altura 3 Ã© uma pirÃ¢mide de altura 2, com uma linha extra de 3 blocos. Uma pirÃ¢mide de altura 2 Ã© uma pirÃ¢mide de altura 1, com uma linha extra de 2 blocos. E, finalmente, uma pirÃ¢mide de altura 1 Ã© apenas uma pirÃ¢mide de altura 0, ou nada, com outra linha de um Ãºnico bloco adicionado.</p>
</li>
<li>
<p>Com essa ideia em mente, podemos escrever:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenha a altura da pirÃ¢mide
      int height = get_int("Altura: ");

      // Desenhe a pirÃ¢mide
      draw(height);
  }

  void draw(int h)
  {
      // Se nÃ£o hÃ¡ nada para desenhar
      if (h == 0)
      {
          return;
      }

      // Desenhe uma pirÃ¢mide de altura h - 1
      draw(h - 1);

      // Desenhe mais uma linha de largura h
      for (int i = 0; i &lt; h; i++)
      {
          printf("#");
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Agora, nossa funÃ§Ã£o <code>draw</code> primeiro se chama <strong>recursivamente</strong>, desenhando uma pirÃ¢mide de altura <code>h - 1</code>. Mas, antes disso, precisamos parar se <code>h</code> for 0, pois nÃ£o haverÃ¡ mais nada para ser desenhado.</li>
<li>Depois, desenhamos a prÃ³xima linha, ou uma linha de largura <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>OrdenaÃ§Ã£o por mesclagem</h2>
<ul>
<li>
<p>Podemos aplicar a ideia de recursÃ£o para ordenaÃ§Ã£o, com outro algoritmo chamado ordenaÃ§Ã£o por mesclagem. O pseudocÃ³digo pode se parecer com:</p>
<pre><code>  Se apenas um item
    Retornar
  Caso contrÃ¡rio
      Ordenar a metade esquerda dos itens
      Ordenar a metade direita dos itens
      Mesclar as metades ordenadas
</code></pre>
</li>
<li>
<p>Veremos melhor isso na prÃ¡tica com uma lista nÃ£o ordenada:</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Primeiro, ordenaremos a metade esquerda (os primeiros quatro elementos):</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  â€“ â€“ â€“ â€“
</code></pre>
</li>
<li>
<p>Bem, para ordenar, precisamos ordenar primeiro a metade dos elementos da metade esquerda:</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  â€“ â€“
</code></pre>
</li>
<li>
<p>Agora, temos apenas um item, <code>7</code>, na metade esquerda, e um item, <code>4</code>, na metade direita. Portanto, vamos mesclar isso, pegando primeiro o menor item de cada lista:</p>
<pre><code>  â€“ â€“ | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>E agora voltamos para a metade direita da metade esquerda, e a ordenamos:</p>
<pre><code>  â€“ â€“ | â€“ â€“ | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Agora, ambas as metades da metade esquerda estÃ£o ordenadas, entÃ£o podemos mesclÃ¡-las. Observamos o inÃ­cio de cada lista e pegamos <code>2</code>, pois Ã© menor que <code>4</code>. EntÃ£o, pegamos <code>4</code>, jÃ¡ que agora Ã© o menor item na frente de ambas as listas. Em seguida, pegamos <code>5</code> e, finalmente, <code>7</code>, para obter:</p>
<pre><code>  â€“ â€“ â€“ â€“ | 6 3 8 1
  â€“ â€“ â€“ â€“
  2 4 5 7
</code></pre>
</li>
<li>
<p>Agora ordenamos a metade direita da mesma forma. Primeiro, a metade esquerda da metade direita:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | 8 1
  â€“ â€“ â€“ â€“ | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>EntÃ£o, a metade direita da metade direita:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | â€“ â€“
  â€“ â€“ â€“ â€“ | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>Podemos mesclar a metade direita agora:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
</ul>
<p>E finalmente, podemos unir as duas metades da lista inteira, seguindo as mesmas etapas de antes. Note que nÃ£o precisamos verificar todos os elementos de cada metade para encontrar o menor, pois sabemos que cada metade jÃ¡ estÃ¡ classificada. Em vez disso, pegamos apenas o menor elemento dos dois no inÃ­cio de cada metade:</p>
<pre><code>    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    2 4 5 7 | â€“ 3 6 8
    1


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ 4 5 7 | â€“ 3 6 8
    1 2


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ 4 5 7 | â€“ â€“ 6 8
    1 2 3


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ 5 7 | â€“ â€“ 6 8
    1 2 3 4


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ 7 | â€“ â€“ 6 8
    1 2 3 4   5


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ 7 | â€“ â€“ â€“ 8
    1 2 3 4   5 6


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ 8
    1 2 3 4   5 6 7


    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    1 2 3 4   5 6 7 8
</code></pre>
<p>Demorou muitas etapas, mas na verdade demorou menos etapas do que os outros algoritmos que vimos atÃ© agora. Dividimos nossa lista pela metade a cada vez, atÃ© que estÃ¡vamos "classificando" oito listas com um elemento cada:</p>
<pre><code>    7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
    4   7 | 2   5 | 3   6 | 1   8
    2   4   5   7 | 1   3   6   8
    1   2   3   4   5   6   7   8
</code></pre>
<p>Como nosso algoritmo dividiu o problema pela metade a cada vez, seu tempo de execuÃ§Ã£o Ã© logarÃ­tmico com <em>O</em>(log <em>n</em>). E depois que classificamos cada metade (ou metade de uma metade), precisÃ¡vamos mesclar todos os elementos, com <em>n</em> etapas, pois tÃ­nhamos que olhar para cada elemento uma vez.
Portanto, nosso tempo total de execuÃ§Ã£o Ã© <em>O</em>(<em>n</em> log <em>n</em>):
  - <em>O</em>(_n_2)
    - classificaÃ§Ã£o por bolha, classificaÃ§Ã£o por seleÃ§Ã£o
  - <em>O</em>(<em>n</em> log <em>n</em>)
    - classificaÃ§Ã£o por mesclagem
  - <em>O</em>(<em>n</em>)
    - busca linear
  - <em>O</em>(log <em>n</em>)
    - busca binÃ¡ria
  - <em>O</em>(1)
Como log <em>n</em> Ã© maior que 1, mas menor que <em>n</em>, <em>n</em> log <em>n</em> estÃ¡ entre <em>n</em> (vezes 1) e _n_2.
O melhor caso, Î©, ainda Ã© <em>n</em> log <em>n</em>, pois ainda classificamos cada metade primeiro e depois as mesclamos:
  - Î©(_n_2)
    - classificaÃ§Ã£o por seleÃ§Ã£o
  - Î©(<em>n</em> log <em>n</em>)
    - classificaÃ§Ã£o por mesclagem
  - Î©(<em>n</em>)
    - classificaÃ§Ã£o por bolha
  - Î©(log <em>n</em>)
  - Î©(1)
    - busca linear, busca binÃ¡ria
Finalmente, hÃ¡ outra notaÃ§Ã£o, Î˜, Theta, que usamos para descrever os tempos de execuÃ§Ã£o dos algoritmos se o limite superior e o limite inferior forem os mesmos. Por exemplo, a classificaÃ§Ã£o por mesclagem tem Î˜(<em>n</em> log <em>n</em>) jÃ¡ que o melhor e o pior caso requerem o mesmo nÃºmero de etapas. E a classificaÃ§Ã£o por seleÃ§Ã£o tem Î˜(_n_2).
Analisamos uma <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualizaÃ§Ã£o final</a> de algoritmos de classificaÃ§Ã£o com um nÃºmero maior de entradas, rodando ao mesmo tempo.</p>


        </main>
      </div>
    </div>
  </body>

</html>