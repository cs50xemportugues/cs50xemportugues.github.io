<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Aula 3</h1>
<ul>
<li><a href="#busca">Busca</a></li>
<li><a href="#grande-o">Grande O</a></li>
<li><a href="#busca-linear">Busca linear</a></li>
<li><a href="#estruturas">Estruturas</a></li>
<li><a href="#ordena√ß√£o">Ordena√ß√£o</a></li>
<li><a href="#ordena√ß√£o-por-sele√ß√£o">Ordena√ß√£o por sele√ß√£o</a></li>
<li><a href="#recurs√£o">Recurs√£o</a></li>
<li><a href="#ordena√ß√£o-por-mesclagem">Ordena√ß√£o por mesclagem</a></li>
</ul>
<h2>Busca</h2>
<ul>
<li>Da √∫ltima vez, falamos sobre a mem√≥ria em um computador ou RAM e sobre como nossos dados podem ser armazenados como vari√°veis ‚Äã‚Äãindividuais ou como matrizes de muitos itens ou elementos.</li>
<li>Podemos pensar em uma matriz com v√°rios itens como uma fileira de arm√°rios, onde um computador s√≥ pode abrir um arm√°rio para olhar um item, um de cada vez.</li>
<li>Por exemplo, se quisermos verificar se um n√∫mero est√° em uma matriz, com um algoritmo que utiliza uma matriz como entrada e produz um booleano como resultado, podemos:<ul>
<li>examinar cada arm√°rio ou cada elemento, um de cada vez, do in√≠cio ao fim.<ul>
<li>Isso √© chamado de <strong>busca linear</strong>, em que nos movemos em uma linha, j√° que nossa matriz n√£o √© classificada.</li>
</ul>
</li>
<li>iniciar no meio e mover para a esquerda ou direita dependendo do que estamos procurando, se nossa matriz de itens for classificada.<ul>
<li>Isso √© chamado de <strong>busca bin√°ria</strong>, j√° que podemos dividir nosso problema em dois a cada passo, como Davi fez com a lista telef√¥nica na semana 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Podemos escrever pseudoc√≥digo para a busca linear com:</p>
<pre><code>  Para i de 0 a n ‚Äì 1
      Se o i-√©simo elemento for 50
          Retornar verdadeiro
  Retornar falso
</code></pre>
<ul>
<li>Podemos rotular cada um dos <code>n</code> arm√°rios de <code>0</code> a <code>n ‚Äì 1</code> e verificar cada um deles em ordem.</li>
</ul>
</li>
<li>
<p>Para a busca bin√°ria, nosso algoritmo pode ter a seguinte apar√™ncia:</p>
<pre><code>  Se n√£o houver itens
      Retornar falso
  Se o item do meio for 50
      Retornar verdadeiro
  Sendo contr√°rio, se 50 &lt; item do meio
      Buscar metade esquerda
  Sendo contr√°rio, se 50 &gt; item do meio
      Buscar metade direita
</code></pre>
<ul>
<li>Eventualmente, n√£o teremos mais partes da matriz sobrando (se o item que queremos n√£o estiver l√°), para que possamos retornar <code>falso</code>.</li>
<li>Caso contr√°rio, podemos pesquisar cada metade dependendo do valor do item do meio.</li>
</ul>
</li>
</ul>
<h2>Big O</h2>
<ul>
<li>Na semana 0, vimos diferentes tipos de algoritmos e seus tempos de execu√ß√£o: <img alt="gr√°fico com: &quot;tamanho do problema&quot; no eixo x; &quot;tempo para resolver&quot; no eixo y; linha reta vermelha e √≠ngreme da origem ao topo do gr√°fico rotulada &quot;n&quot;; linha reta amarela menos √≠ngreme da origem ao topo do gr√°fico rotulada &quot;n/2&quot;; linha curva verde menos √≠ngreme da origem para a direita do gr√°fico rotulada &quot;log_2 n&quot;" src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" /></li>
<li>A maneira mais formal de descrever isso √© com a nota√ß√£o big <em>O</em>, que podemos entender como ‚Äúda ordem de‚Äù. Por exemplo, se nosso algoritmo for a pesquisa linear, ele levar√° aproximadamente <em>O</em>(<em>n</em>) passos, "da ordem de <em>n</em>". Na verdade, at√© mesmo um algoritmo que examina dois itens por vez e leva <em>n</em>/2 passos tem <em>O</em>(<em>n</em>). Isso ocorre porque, √† medida que <em>n</em> fica cada vez maior, somente o termo maior, <em>n</em>, importa.</li>
<li>Da mesma forma, um tempo de execu√ß√£o logar√≠tmico √© <em>O</em>(log <em>n</em>), n√£o importa qual seja a base, j√° que √© apenas uma aproxima√ß√£o do que acontece quando <em>n</em> √© muito grande.</li>
<li>Existem alguns tempos de execu√ß√£o comuns:
    - <em>O</em>(_n_2)
    - <em>O</em>(<em>n</em> log <em>n</em>)
    - <em>O</em>(<em>n</em>)
        - (busca linear)
    - <em>O</em>(log <em>n</em>)
        - (busca bin√°ria)
    - <em>O</em>(1)</li>
<li>Os cientistas da computa√ß√£o tamb√©m podem usar a nota√ß√£o big Œ©, big Omega, que √© o limite inferior do n√∫mero de etapas para nosso algoritmo. (Big <em>O</em> √© o limite superior do n√∫mero de etapas, ou o pior caso, e normalmente √© o que mais nos importa.) Com a busca linear, por exemplo, o pior caso √© <em>n</em> etapas, mas o melhor caso √© 1 etapa, j√° que nosso item pode ser o primeiro item que verificamos. O melhor caso para a busca bin√°ria tamb√©m √© 1, j√° que nosso item pode estar no meio da matriz.</li>
<li>E temos um conjunto semelhante dos tempos de execu√ß√£o big Œ© mais comuns:
    - Œ©(_n_2)
    - Œ©(<em>n</em> log <em>n</em>)
    - Œ©(<em>n</em>)
        - (contar o n√∫mero de itens)
    - Œ©(log <em>n</em>)
    - Œ©(1)
        - (busca linear, busca bin√°ria)</li>
</ul>
<h2>Pesquisa linear</h2>
<ul>
<li>
<p>Vamos dar uma olhada no <code>numbers.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Uma matriz de n√∫meros
      int numbers[] = {4, 8, 15, 16, 23, 42};

      // Pesquisar por 50
      for (int i = 0; i &lt; 6; i++)
      {
          if (numbers[i] == 50)
          {
              printf("Encontrado\n");
              return 0;
          }
      }
      printf("N√£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Aqui inicializamos uma matriz com alguns valores e verificamos os itens na matriz um de cada vez, em ordem.</li>
<li>E em cada caso, dependendo se o valor foi encontrado ou n√£o, podemos retornar um c√≥digo de sa√≠da de 0 (para sucesso) ou 1 (para falha).</li>
</ul>
</li>
<li>
<p>Podemos fazer o mesmo para nomes:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      // Uma matriz de nomes
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};

      // Pesquisar por EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("Encontrado\n");
              return 0;
          }
      }
      printf("N√£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>N√£o podemos comparar strings diretamente, pois elas n√£o s√£o um tipo de dados simples, mas sim uma matriz de v√°rios caracteres. Precisamos compar√°-las de forma diferente. Felizmente, a biblioteca <code>string</code> tem uma fun√ß√£o <code>strcmp</code> que compara strings para n√≥s e retorna <code>0</code> se forem iguais, ent√£o podemos us√°-la.</li>
</ul>
</li>
<li>
<p>Vamos tentar implementar uma agenda telef√¥nica com as mesmas ideias:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
      string numbers[] = {"617‚Äì555‚Äì0100", "617‚Äì555‚Äì0101", "617‚Äì555‚Äì0102", "617‚Äì555‚Äì0103"};

      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("Encontrado %s\n", numbers[i]);
              return 0;
          }
      }
      printf("N√£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Usaremos strings para n√∫meros de telefone, pois elas podem incluir formata√ß√£o ou ser muito longas para um n√∫mero.</li>
<li>Agora, se o nome em um determinado √≠ndice na matriz <code>names</code> corresponder a quem estamos procurando, retornaremos o n√∫mero de telefone na matriz <code>numbers</code>, no mesmo √≠ndice. Mas isso significa que precisamos ter muito cuidado para garantir que cada n√∫mero corresponda ao nome em cada √≠ndice, especialmente se adicionarmos ou removermos nomes e n√∫meros.</li>
</ul>
</li>
</ul>
<h2>Structs</h2>
<ul>
<li>
<p>Acontece que podemos criar nossos pr√≥prios tipos de dados personalizados chamados <strong>structs</strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  person;

  int main(void)
  {
      person people[4];

      people[0].name = "EMMA";
      people[0].number = "617‚Äì555‚Äì0100";

      people[1].name = "RODRIGO";
      people[1].number = "617‚Äì555‚Äì0101";

      people[2].name = "BRIAN";
      people[2].number = "617‚Äì555‚Äì0102";

      people[3].name = "DAVID";
      people[3].number = "617‚Äì555‚Äì0103";

      // Buscar por EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, "EMMA") == 0)
          {
              printf("Encontrado %s\n", people[i].number);
              return 0;
          }
      }
      printf("N√£o encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Podemos pensar em structs como cont√™ineres que podem armazenar v√°rios outros tipos de dados.</li>
<li>Aqui, criamos um novo tipo utilizando uma struct chamada <code>person</code>, que ter√° uma <code>string</code> chamada <code>name</code> e uma <code>string</code> chamada <code>number</code>. Em seguida, podemos criar uma array com esses tipos de struct e inicializar os valores presentes em cada uma delas utilizando uma nova sintaxe, <code>.</code>, para acessar as propriedades de cada <code>person</code>.</li>
<li>Em nosso loop, podemos agora ter mais certeza de que o <code>number</code> corresponde ao <code>name</code>, visto que pertencem ao mesmo elemento <code>person</code>.</li>
</ul>
</li>
</ul>
<h2>Ordena√ß√£o</h2>
<ul>
<li>Se nossa entrada for uma lista n√£o ordenada de n√∫meros, h√° muitos algoritmos que poder√≠amos usar para produzir uma sa√≠da de uma lista ordenada.</li>
<li>Com oito volunt√°rios no palco com os seguintes n√∫meros, poder√≠amos considerar a troca de pares de n√∫meros pr√≥ximos como o primeiro passo.</li>
<li>
<p>Nossos volunt√°rios come√ßam na seguinte ordem aleat√≥ria:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Observamos os primeiros dois n√∫meros e os trocamos para que fiquem em ordem:</p>
<pre><code>  6 3 8 5 2 7 4 1
  ‚Äì ‚Äì
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>O pr√≥ximo par, <code>6</code> e <code>8</code>, est√° em ordem, por isso, n√£o precisamos troc√°-los.</p>
</li>
<li>
<p>O pr√≥ximo par, <code>8</code> e <code>5</code>, precisa ser trocado:</p>
<pre><code>  3 6 8 5 2 7 4 1
      ‚Äì ‚Äì
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Continuamos at√© o final da lista:</p>
<pre><code>  3 6 5 2 8 7 4 1
          ‚Äì ‚Äì
  3 6 5 2 7 8 4 1
            ‚Äì ‚Äì
  3 6 5 2 7 4 8 1
              ‚Äì ‚Äì
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>Nossa lista ainda n√£o est√° ordenada, mas estamos um passo mais perto da solu√ß√£o porque o valor mais alto, <code>8</code>, foi deslocado para a direita.</p>
</li>
<li>
<p>Repetimos com outra passagem pela lista:</p>
<pre><code>  3 6 5 2 7 4 1 8
  ‚Äì ‚Äì
  3 6 5 2 7 4 1 8
    ‚Äì ‚Äì
  3 5 6 2 7 4 1 8
      ‚Äì ‚Äì
  3 5 2 6 7 4 1 8
        ‚Äì ‚Äì
  3 5 2 6 7 4 1 8
          ‚Äì ‚Äì
  3 5 2 6 4 7 1 8
              ‚Äì ‚Äì
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Note que n√£o precisamos trocar 3 e 6, ou 6 e 7.</li>
</ul>
</li>
<li>
<p>Agora, o pr√≥ximo maior valor, <code>7</code>, foi movido para a direita. Se repetirmos isso, cada vez mais da lista fica ordenada e, rapidamente, teremos uma lista totalmente ordenada.</p>
</li>
<li>
<p>Esse algoritmo √© chamado de <strong>bubble sort</strong>, em que os valores altos "borbulham" para a direita. O pseudoc√≥digo para ele pode ser:</p>
<pre><code>  Repetir n¬†-¬†1 vezes
      Para i de 0 a n¬†-¬†2
          Se os √©simos e √©simo + 1 elementos estiverem fora de ordem
              Troc√°-los
</code></pre>
<ul>
<li>Como estamos comparando os elementos √©simo e √©simo + 1, precisamos subir apenas at√© n¬†-¬†2 para i. Em seguida, trocamos os dois elementos se estiverem fora de ordem.</li>
<li>E podemos parar depois que tivermos feito n¬†-¬†1 passagens, j√° que sabemos que os maiores n¬†-¬†1 elementos ter√£o borbulhado para a direita.</li>
</ul>
</li>
<li>
<p>Temos n¬†-¬†2 etapas para o la√ßo interno e n¬†-¬†1 la√ßos, ent√£o temos um total de n2¬†-¬†3n¬†+¬†2 etapas. Mas o maior fator, ou termo dominante, √© n2, √† medida que n fica cada vez maior, ent√£o, podemos dizer que o bubble sort √© _O_(_n_2).</p>
</li>
<li>Vimos tempos de execu√ß√£o como o seguinte, portanto, embora a pesquisa bin√°ria seja muito mais r√°pida que a pesquisa linear, pode n√£o valer o custo √∫nico de ordenar a lista primeiro, a menos que fa√ßamos muitas pesquisas ao longo do tempo:<ul>
<li><em>O</em>(_n_2)<ul>
<li>bubble sort</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>pesquisa linear</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>pesquisa bin√°ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>E o Œ© para bubble sort ainda √© n2, j√° que ainda verificamos cada par de elementos por n¬†-¬†1 passagens.</li>
</ul>
<h2>Classifica√ß√£o por sele√ß√£o</h2>
<ul>
<li>
<p>Podemos adotar outra abordagem com o mesmo conjunto de n√∫meros:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Primeiro, vamos analisar cada n√∫mero e lembrar do menor n√∫mero que vimos. Em seguida, podemos troc√°-lo pelo primeiro n√∫mero em nossa lista, j√° que sabemos que ele √© o menor:</p>
<pre><code>  6 3 8 5 2 7 4 1
  ‚Äì             ‚Äì
  1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Agora sabemos que pelo menos o primeiro elemento de nossa lista est√° no lugar certo, ent√£o podemos procurar o menor elemento entre os demais e troc√°-lo pelo pr√≥ximo elemento n√£o classificado (agora o segundo elemento):</p>
<pre><code>  1 3 8 5 2 7 4 6
    ‚Äì     ‚Äì
  1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Podemos repetir isso v√°rias vezes at√© termos uma lista classificada.</p>
</li>
<li>
<p>Esse algoritmo √© chamado de <strong>classifica√ß√£o por sele√ß√£o</strong>, e podemos escrever o pseudoc√≥digo da seguinte forma:</p>
<pre><code>  Para i de 0 at√© n‚Äì1
      Encontre o menor item entre o item i e o √∫ltimo item
      Troque o menor item pelo item i
</code></pre>
</li>
<li>
<p>Com a grande nota√ß√£o <em>O</em>, ainda temos tempo de execu√ß√£o de <em>O</em>(<em>n_2), j√° que est√°vamos olhando para aproximadamente todos os elementos _n</em> para encontrar o menor e fazendo <em>n</em> passagens para classificar todos os elementos.</p>
</li>
<li>
<p>Mais formalmente, podemos usar algumas f√≥rmulas para mostrar que o maior fator √© realmente _n_2:</p>
<pre><code>  n + (n ‚Äì 1) + (n ‚Äì 2) + ... + 1
  n(n + 1)/2
  (n^2 + n)/2
  n^2/2 + n/2
  O(n^2)
</code></pre>
</li>
<li>
<p>Portanto, descobrimos que a classifica√ß√£o por sele√ß√£o √© fundamentalmente igual √† classifica√ß√£o por bolhas no tempo de execu√ß√£o:</p>
<ul>
<li><em>O</em>(_n_2)<ul>
<li>Classifica√ß√£o por bolhas, classifica√ß√£o por sele√ß√£o</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>Pesquisa linear</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>Pesquisa bin√°ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>O melhor caso, Œ©, tamb√©m √© _n_2.</li>
<li>
<p>Podemos voltar √† classifica√ß√£o por bolhas e mudar seu algoritmo para algo assim, o que nos permitir√° parar mais cedo se todos os elementos forem classificados:</p>
<pre><code>  Repetir at√© que n√£o haja trocas
      Para i de 0 a n‚Äì2
          Se os elementos i e i+1 estiverem fora de ordem
              Troque-os
</code></pre>
</li>
<li>
<p>Agora, s√≥ precisamos analisar cada elemento uma vez, ent√£o o melhor caso agora √© Œ©(<em>n</em>):
    - Œ©(_n_2)
      - Classifica√ß√£o por sele√ß√£o
    - Œ©(<em>n</em> log <em>n</em>)
    - Œ©(<em>n</em>)
      - Classifica√ß√£o por bolhas
    - Œ©(log <em>n</em>)
    - Œ©(1)
      - Pesquisa linear, pesquisa bin√°ria</p>
</li>
<li>
<p>Analisamos uma visualiza√ß√£o on-line <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparando algoritmos de classifica√ß√£o</a> com anima√ß√µes de como os elementos se movem dentro dos arrays para a classifica√ß√£o por bolhas e a classifica√ß√£o por sele√ß√£o.</p>
</li>
</ul>
<h2><strong>Recurs√£o</strong></h2>
<ul>
<li>
<p>Lembre-se que na semana 0, t√≠nhamos um pseudoc√≥digo para encontrar um nome em uma lista telef√¥nica, onde t√≠nhamos linhas nos dizendo para "voltar" e repetir alguns passos:</p>
<pre><code>  1  Pegue a lista telef√¥nica
  2  Abra a lista telef√¥nica no meio
  3  Veja a p√°gina
  4  Se Smith estiver na p√°gina
  5      Ligue para Mike
  6  Sen√£o se Smith estiver antes no livro
  7      Abra no meio da metade esquerda do livro
  8      **Volte para a linha 3**
  9  Sen√£o se Smith estiver depois no livro
  10     Abra no meio da metade direita do livro
  11     **Volte para a linha 3**
  12 Sen√£o
  13     Sair
</code></pre>
</li>
<li>
<p>Em vez disso, poder√≠amos repetir todo o nosso algoritmo na metade do livro que nos restou:</p>
<pre><code>  1  Pegue a lista telef√¥nica
  2  Abra a lista telef√¥nica no meio
  3  Veja a p√°gina
  4  Se Smith estiver na p√°gina
  5      Ligue para Mike
  6  Sen√£o se Smith estiver antes no livro
  7      **Procure na metade esquerda do livro**
  8
  9  Sen√£o se Smith estiver depois no livro
  10     **Procure na metade direita do livro**
  11
  12 Sen√£o
  13     Sair
</code></pre>
<ul>
<li>Isso parece um processo c√≠clico que nunca terminar√°, mas, na verdade, estamos dividindo o problema pela metade a cada vez e parando quando n√£o houver mais livro.</li>
</ul>
</li>
<li>
<p><strong>Recurs√£o</strong> ocorre quando uma fun√ß√£o ou algoritmo se refere a si mesmo, como no novo pseudoc√≥digo acima.</p>
</li>
<li>
<p>Tamb√©m na semana 1, implementamos uma "pir√¢mide" de blocos na seguinte forma:</p>
<pre><code>  #
  ##
  ###
  ####
</code></pre>
<ul>
<li>
<p>E poder√≠amos ter um c√≥digo iterativo como este:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenha a altura da pir√¢mide
      int height = get_int("Altura: ");

      // Desenhe a pir√¢mide
      draw(height);
  }

  void draw(int h)
  {
      // Desenhar pir√¢mide de altura h
      for (int i = 1; i &lt;= h; i++)
      {
          for (int j = 1; j &lt;= i; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
<ul>
<li>Aqui, usamos loops <code>for</code> para imprimir cada bloco em cada linha.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mas observe que uma pir√¢mide de altura 4 √© na verdade uma pir√¢mide de altura 3, com uma linha extra de 4 blocos adicionados. E uma pir√¢mide de altura 3 √© uma pir√¢mide de altura 2, com uma linha extra de 3 blocos. Uma pir√¢mide de altura 2 √© uma pir√¢mide de altura 1, com uma linha extra de 2 blocos. E, finalmente, uma pir√¢mide de altura 1 √© apenas uma pir√¢mide de altura 0, ou nada, com outra linha de um √∫nico bloco adicionado.</p>
</li>
<li>
<p>Com essa ideia em mente, podemos escrever:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenha a altura da pir√¢mide
      int height = get_int("Altura: ");

      // Desenhe a pir√¢mide
      draw(height);
  }

  void draw(int h)
  {
      // Se n√£o h√° nada para desenhar
      if (h == 0)
      {
          return;
      }

      // Desenhe uma pir√¢mide de altura h - 1
      draw(h - 1);

      // Desenhe mais uma linha de largura h
      for (int i = 0; i &lt; h; i++)
      {
          printf("#");
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Agora, nossa fun√ß√£o <code>draw</code> primeiro se chama <strong>recursivamente</strong>, desenhando uma pir√¢mide de altura <code>h - 1</code>. Mas, antes disso, precisamos parar se <code>h</code> for 0, pois n√£o haver√° mais nada para ser desenhado.</li>
<li>Depois, desenhamos a pr√≥xima linha, ou uma linha de largura <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>Ordena√ß√£o por mesclagem</h2>
<ul>
<li>
<p>Podemos aplicar a ideia de recurs√£o para ordena√ß√£o, com outro algoritmo chamado ordena√ß√£o por mesclagem. O pseudoc√≥digo pode se parecer com:</p>
<pre><code>  Se apenas um item
    Retornar
  Caso contr√°rio
      Ordenar a metade esquerda dos itens
      Ordenar a metade direita dos itens
      Mesclar as metades ordenadas
</code></pre>
</li>
<li>
<p>Veremos melhor isso na pr√°tica com uma lista n√£o ordenada:</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Primeiro, ordenaremos a metade esquerda (os primeiros quatro elementos):</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì
</code></pre>
</li>
<li>
<p>Bem, para ordenar, precisamos ordenar primeiro a metade dos elementos da metade esquerda:</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  ‚Äì ‚Äì
</code></pre>
</li>
<li>
<p>Agora, temos apenas um item, <code>7</code>, na metade esquerda, e um item, <code>4</code>, na metade direita. Portanto, vamos mesclar isso, pegando primeiro o menor item de cada lista:</p>
<pre><code>  ‚Äì ‚Äì | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>E agora voltamos para a metade direita da metade esquerda, e a ordenamos:</p>
<pre><code>  ‚Äì ‚Äì | ‚Äì ‚Äì | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Agora, ambas as metades da metade esquerda est√£o ordenadas, ent√£o podemos mescl√°-las. Observamos o in√≠cio de cada lista e pegamos <code>2</code>, pois √© menor que <code>4</code>. Ent√£o, pegamos <code>4</code>, j√° que agora √© o menor item na frente de ambas as listas. Em seguida, pegamos <code>5</code> e, finalmente, <code>7</code>, para obter:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | 6 3 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7
</code></pre>
</li>
<li>
<p>Agora ordenamos a metade direita da mesma forma. Primeiro, a metade esquerda da metade direita:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>Ent√£o, a metade direita da metade direita:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>Podemos mesclar a metade direita agora:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
</ul>
<p>E finalmente, podemos unir as duas metades da lista inteira, seguindo as mesmas etapas de antes. Note que n√£o precisamos verificar todos os elementos de cada metade para encontrar o menor, pois sabemos que cada metade j√° est√° classificada. Em vez disso, pegamos apenas o menor elemento dos dois no in√≠cio de cada metade:</p>
<pre><code>    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    2 4 5 7 | ‚Äì 3 6 8
    1


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì 4 5 7 | ‚Äì 3 6 8
    1 2


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì 4 5 7 | ‚Äì ‚Äì 6 8
    1 2 3


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì 5 7 | ‚Äì ‚Äì 6 8
    1 2 3 4


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì 6 8
    1 2 3 4   5


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì ‚Äì 8
    1 2 3 4   5 6


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì 8
    1 2 3 4   5 6 7


    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
    1 2 3 4   5 6 7 8
</code></pre>
<p>Demorou muitas etapas, mas na verdade demorou menos etapas do que os outros algoritmos que vimos at√© agora. Dividimos nossa lista pela metade a cada vez, at√© que est√°vamos "classificando" oito listas com um elemento cada:</p>
<pre><code>    7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
    4   7 | 2   5 | 3   6 | 1   8
    2   4   5   7 | 1   3   6   8
    1   2   3   4   5   6   7   8
</code></pre>
<p>Como nosso algoritmo dividiu o problema pela metade a cada vez, seu tempo de execu√ß√£o √© logar√≠tmico com <em>O</em>(log <em>n</em>). E depois que classificamos cada metade (ou metade de uma metade), precis√°vamos mesclar todos os elementos, com <em>n</em> etapas, pois t√≠nhamos que olhar para cada elemento uma vez.
Portanto, nosso tempo total de execu√ß√£o √© <em>O</em>(<em>n</em> log <em>n</em>):
  - <em>O</em>(_n_2)
    - classifica√ß√£o por bolha, classifica√ß√£o por sele√ß√£o
  - <em>O</em>(<em>n</em> log <em>n</em>)
    - classifica√ß√£o por mesclagem
  - <em>O</em>(<em>n</em>)
    - busca linear
  - <em>O</em>(log <em>n</em>)
    - busca bin√°ria
  - <em>O</em>(1)
Como log <em>n</em> √© maior que 1, mas menor que <em>n</em>, <em>n</em> log <em>n</em> est√° entre <em>n</em> (vezes 1) e _n_2.
O melhor caso, Œ©, ainda √© <em>n</em> log <em>n</em>, pois ainda classificamos cada metade primeiro e depois as mesclamos:
  - Œ©(_n_2)
    - classifica√ß√£o por sele√ß√£o
  - Œ©(<em>n</em> log <em>n</em>)
    - classifica√ß√£o por mesclagem
  - Œ©(<em>n</em>)
    - classifica√ß√£o por bolha
  - Œ©(log <em>n</em>)
  - Œ©(1)
    - busca linear, busca bin√°ria
Finalmente, h√° outra nota√ß√£o, Œò, Theta, que usamos para descrever os tempos de execu√ß√£o dos algoritmos se o limite superior e o limite inferior forem os mesmos. Por exemplo, a classifica√ß√£o por mesclagem tem Œò(<em>n</em> log <em>n</em>) j√° que o melhor e o pior caso requerem o mesmo n√∫mero de etapas. E a classifica√ß√£o por sele√ß√£o tem Œò(_n_2).
Analisamos uma <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualiza√ß√£o final</a> de algoritmos de classifica√ß√£o com um n√∫mero maior de entradas, rodando ao mesmo tempo.</p>


        </main>
      </div>
    </div>
  </body>

</html>