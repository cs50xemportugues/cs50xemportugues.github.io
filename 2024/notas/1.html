<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Aula 1</h2>
<ul>
<li><a href="#c">C</a></li>
<li><a href="#hello-world">hello, world</a></li>
<li><a href="#compiladores">Compiladores</a></li>
<li><a href="#string">String</a></li>
<li><a href="#blocos-do-scratch-em-c">Blocos do Scratch em C</a></li>
<li><a href="#tipos-formatos-e-operadores">Tipos, formatos e operadores</a></li>
<li><a href="#mais-exemplos">Mais exemplos</a><ul>
<li><a href="#telas">Telas</a></li>
</ul>
</li>
<li><a href="#mem√≥ria-imprecis√£o-e-estouro">Mem√≥ria, imprecis√£o e estouro</a></li>
</ul>
<h2>C</h2>
<ul>
<li>
<p>Hoje vamos aprender uma nova linguagem, <strong>C</strong>: uma linguagem de programa√ß√£o que tem todos os recursos do Scratch e muito mais, mas talvez um pouco menos amig√°vel pois √© totalmente em texto:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Apesar de as palavras serem novas, as ideias s√£o as mesmas dos blocos "Quando a bandeira verde √© clicada" e "diga (hello, world)" do Scratch:<br />
<img alt="bloco com r√≥tulo 'Quando a bandeira verde √© clicada', bloco com r√≥tulo 'diga (hello, world)'" src="https://cs50.harvard.edu/x/2020/notes/1/when_green_flag.png" /></li>
</ul>
</li>
<li>
<p>Apesar de parecer complicado, n√£o se esque√ßa que 2/3 dos alunos do CS50 nunca fizeram ci√™ncia da computa√ß√£o antes, ent√£o n√£o se assuste! E embora no in√≠cio, para pegar emprestada uma frase do MIT, tentar absorver todos esses novos conceitos possa parecer como beber de uma mangueira de inc√™ndio, tenha certeza de que at√© o final do semestre estaremos capacitados e experientes na aprendizagem e aplica√ß√£o desses conceitos.</p>
</li>
<li>Podemos comparar v√°rios dos construtos em C com blocos que j√° vimos e usamos no Scratch. A sintaxe √© muito menos importante que os princ√≠pios, que j√° nos foram apresentados.</li>
</ul>
<h2>ol√°, mundo</h2>
<ul>
<li>
<p>O bloco ‚Äúquando a bandeira verde for clicada‚Äù no Scratch inicia o programa principal; clicar na bandeira verde faz com que o conjunto direito de blocos abaixo comece. Em C, a primeira linha para o mesmo √© <code>int main(void)</code>, sobre a qual aprenderemos mais nas pr√≥ximas semanas, seguida por uma chave aberta <code>{</code>, e uma chave fechada <code>}</code>, envolvendo tudo o que deve estar em nosso programa.</p>
<pre><code>  int main(void)
  {

  }
</code></pre>
</li>
<li>
<p>O bloco ‚Äúdizer (ol√°, mundo)‚Äù √© uma fun√ß√£o e mapeia para <code>printf("ol√°, mundo");</code>. Em C, a fun√ß√£o para imprimir algo na tela √© <code>printf</code>, onde <code>f</code> significa "format", o que significa que podemos formatar a string impressa de diferentes maneiras. Ent√£o, usamos par√™nteses para passar o que queremos imprimir. Temos que usar aspas duplas para circundar nosso texto para que seja entendido como texto, e finalmente, adicionamos um ponto-e-v√≠rgula <code>;</code> para finalizar essa linha de c√≥digo.</p>
</li>
<li>Para que nosso programa funcione, tamb√©m precisamos de outra linha no topo, uma linha de cabe√ßalho <code>#include &lt;stdio.h&gt;</code> que define a fun√ß√£o <code>printf</code> que queremos usar. Em algum lugar h√° um arquivo em nosso computador, <code>stdio.h</code>, que inclui o c√≥digo que nos permite acessar a fun√ß√£o <code>printf</code>, e a linha <code>#include</code> diz ao computador para incluir esse arquivo com nosso programa.</li>
<li>Para escrever nosso primeiro programa em Scratch, abrimos o site do Scratch. Da mesma forma, usaremos o <a href="https://sandbox.cs50.io/">CS50 Sandbox</a> para come√ßar a escrever e executar o c√≥digo da mesma maneira. O CS50 Sandbox √© um ambiente virtual baseado em nuvem com as bibliotecas e ferramentas j√° instaladas para escrever programas em v√°rias linguagens. No topo, h√° um editor de c√≥digo simples, onde podemos digitar texto. Abaixo, temos uma janela de terminal, na qual podemos digitar comandos:<br />
<img alt="dois pain√©is, superior rotulado hello.c, inferior rotulado Terminal" src="https://cs50.harvard.edu/x/2020/notes/1/cs50_sandbox.png" /></li>
<li>Digitaremos nosso c√≥digo do in√≠cio na parte superior, depois de usar o sinal <code>+</code> para criar um novo arquivo chamado <code>hello.c</code>:<br />
<img alt="ol√°, mundo no editor" src="https://cs50.harvard.edu/x/2020/notes/1/editor.png" /></li>
<li>Finalizamos o arquivo do nosso programa com <code>.c</code> por conven√ß√£o, para indicar que ele foi concebido como um programa C. Observe que nosso c√≥digo √© colorido, para que certas coisas fiquem mais vis√≠veis.</li>
</ul>
<h2>Compiladores</h2>
<ul>
<li>Uma vez que salvamos o c√≥digo que escrevemos, que √© chamado de <strong>c√≥digo-fonte</strong>, precisamos convert√™-lo em <strong>c√≥digo de m√°quina</strong>, instru√ß√µes bin√°rias que o computador entende diretamente.</li>
<li>Usamos um programa chamado <strong>compilador</strong> para compilar nosso c√≥digo-fonte em c√≥digo de m√°quina.</li>
<li>Para fazer isso, usamos o painel <strong>Terminal</strong>, que tem um <strong>prompt de comando</strong>. O <code>$</code> √† esquerda √© um prompt, ap√≥s o qual podemos digitar comandos.</li>
<li>Digitamos <code>clang hello.c</code> (onde <code>clang</code> significa "linguagens C", um compilador escrito por um grupo de pessoas). Mas antes de pressionarmos Enter, clicamos no √≠cone da pasta no canto superior esquerdo do CS50 Sandbox. Vemos nosso arquivo, <code>hello.c</code>. Ent√£o, pressionamos Enter na janela do terminal e vemos que agora temos outro arquivo chamado <code>a.out</code> (abrevia√ß√£o de "sa√≠da de montagem"). Dentro desse arquivo est√° o c√≥digo do nosso programa, em bin√°rio. Agora, podemos digitar <code>./a.out</code> no prompt do terminal para executar o programa <code>a.out</code> em nossa pasta atual. Acabamos de escrever, compilar e executar nosso primeiro programa!</li>
</ul>
<h2>String</h2>
<ul>
<li>
<p>Mas depois de executar nosso programa, vemos <code>hello, world$</code>, com o novo prompt na mesma linha que nossa sa√≠da. Acontece que precisamos especificar precisamente que precisamos de uma nova linha ap√≥s o nosso programa, por isso podemos atualizar nosso c√≥digo para incluir um caractere de nova linha especial, <code>\n</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Agora precisamos nos lembrar de recompilar nosso programa com <code>clang hello.c</code> antes de executar esta nova vers√£o.</li>
</ul>
</li>
<li>
<p>A linha 2 de nosso programa est√° intencionalmente em branco, pois queremos iniciar uma nova se√ß√£o de c√≥digo, assim como iniciar novos par√°grafos em ensaios. N√£o √© estritamente necess√°rio para que nosso programa execute corretamente, mas ajuda os humanos a ler programas mais longos com mais facilidade.</p>
</li>
<li>Podemos alterar o nome de nosso programa de <code>a.out</code> para outra coisa tamb√©m. Podemos passar <strong>argumentos de linha de comando</strong> ou op√ß√µes adicionais para programas no terminal, dependendo do que o programa foi escrito para entender. Por exemplo, podemos digitar <code>clang -o hello hello.c</code>, e <code>-o hello</code> est√° dizendo ao programa <code>clang</code> para salvar a sa√≠da compilada como apenas <code>hello</code>. Ent√£o, possiamo executar apenas <code>./hello</code>.</li>
<li>
<p>Em nosso prompt de comando, podemos executar outros comandos, como <code>ls</code> (lista), que mostra os arquivos em nossa pasta atual:</p>
<pre><code>  $ ls
  a.out* hello* hello.c
</code></pre>
<ul>
<li>O asterisco, <code>*</code>, indica que esses arquivos s√£o execut√°veis ou que podem ser executados por nosso computador.</li>
</ul>
</li>
<li>
<p>Podemos usar o comando <code>rm</code> (remover) para excluir um arquivo:</p>
<pre><code>  $ rm a.out
  rm: remove regular file 'a.out'?
</code></pre>
<ul>
<li>Podemos digitar <code>y</code> ou <code>yes</code> para confirmar e usar <code>ls</code> novamente para ver que ele realmente se foi para sempre.</li>
</ul>
</li>
<li>
<p>Agora, vamos tentar obter a entrada do usu√°rio, como fizemos no Scratch quando quer√≠amos dizer "ola, David":<br />
<img alt="screenshot dos blocos &quot;ask what's your name? and wait&quot;, &quot;say join hello, answer&quot;" src="https://cs50.harvard.edu/x/2020/notes/1/ask_say_join.png" /></p>
<pre><code>  string answer = get_string("What's your name?\n");
  printf("hello, %s\n", answer);
</code></pre>
<ul>
<li>Primeiro, precisamos de uma <strong>string</strong>, ou parte do texto (especificamente, zero ou mais caracteres em uma sequ√™ncia entre aspas duplas, como <code>""</code>, <code>"ba"</code>, ou ‚Äúbananas‚Äù), que podemos pedir ao usu√°rio, com a fun√ß√£o <code>get_string</code>. Passamos o prompt, ou o que queremos perguntar ao usu√°rio, para a fun√ß√£o com <code>"What is your name?\n"</code> entre par√™nteses. √Ä esquerda, queremos criar uma vari√°vel, <code>answer</code>, cujo valor ser√° o que o usu√°rio insere. (O sinal de igual <code>=</code> est√° definindo o valor da direita para a esquerda.) Finalmente, o tipo de vari√°vel que queremos √© <code>string</code>, ent√£o especificamos isso √† esquerda de <code>answer</code>.</li>
<li>Em seguida, dentro da fun√ß√£o <code>printf</code>, queremos o valor de <code>answer</code> no que imprimimos de volta. Usamos um espa√ßo reservado para nossa vari√°vel de string, <code>%s</code>, dentro da frase que queremos imprimir, como <code>"hello, %s\n"</code>, e ent√£o damos <code>printf</code> outro argumento, ou op√ß√£o, para dizer que queremos que a vari√°vel <code>answer</code> seja substitu√≠da.</li>
</ul>
</li>
<li>
<p>Se cometermos um erro, como escrever <code>printf("hello, world"\n);</code> com o <code>\n</code> fora das aspas duplas de nossa string, veremos erros de nosso compilador:</p>
<pre><code>  $ clang -o hello hello.c
  hello.c:5:26: error: expected ')'
      printf("hello, world"\n);
                           ^
  hello.c:5:11: note: to match this '('
      printf("hello, world"\n);
            ^
  1 error generated.
</code></pre>
<ul>
<li>A primeira linha do erro nos diz para olhar para <code>hello.c</code>, linha 5, coluna 26, onde o compilador esperava um par√™ntese de fechamento, em vez de uma barra invertida.</li>
</ul>
</li>
<li>
<p>Para simplificar as coisas (pelo menos no come√ßo), incluiremos uma biblioteca, ou conjunto de c√≥digos, do CS50. A biblioteca nos fornece o tipo de vari√°vel <code>string</code>, a fun√ß√£o <code>get_string</code> e muito mais. S√≥ temos que escrever uma linha no topo para <code>incluir</code> o arquivo <code>cs50.h</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, name\n");
  }
</code></pre>
</li>
<li>
<p>Ent√£o vamos criar um novo arquivo, <code>string.c</code>, com este c√≥digo:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>Agora, se tentarmos compilar esse c√≥digo, obteremos muitas linhas de erro. √Äs vezes, um erro significa que o compilador come√ßa a interpretar o c√≥digo correto incorretamente, gerando mais erros do que realmente existem. Ent√£o, come√ßamos com nosso primeiro erro:</p>
<pre><code>  $ clang -o string string.c
  string.c:5:5: error: use of undeclared identifier 'string'; did you mean 'stdin'?
    string name = get_string("What's your name?\n");
    ^~~~~~
    stdin
  /usr/include/stdio.h:135:25: note: 'stdin' declared here
  extern struct _IO_FILE *stdin;          /* Standard input stream.  */
</code></pre>
<ul>
<li>N√£o quer√≠amos dizer <code>stdin</code> (‚Äúentrada padr√£o‚Äù) em vez de <code>string</code>, ent√£o essa mensagem de erro n√£o foi √∫til. Na verdade, precisamos importar outro arquivo que define o tipo <code>string</code> (na verdade, uma roda de treinamento do CS50, como descobriremos nas pr√≥ximas semanas).</li>
</ul>
</li>
<li>
<p>Ent√£o podemos incluir outro arquivo, <code>cs50.h</code>, que tamb√©m inclui a fun√ß√£o <code>get_string</code>, entre outras.</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>Agora, quando tentarmos compilar nosso programa, teremos apenas um erro:</p>
<pre><code>  $ clang -o string string.c
  /tmp/string-aca94d.o: In function `main':
  string.c:(.text+0x19): undefined reference to `get_string'
  clang-7: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<ul>
<li>Acontece que tamb√©m temos que dizer ao nosso compilador para adicionar nosso arquivo de biblioteca CS50 especial, com <code>clang -o string string.c -lcs50</code>, com <code>-l</code> para ‚Äúlink‚Äù.</li>
</ul>
</li>
<li>
<p>Podemos at√© mesmo abstrair isso e digitar <code>make string</code>. Vemos que, por padr√£o no CS50 Sandbox, <code>make</code> usa <code>clang</code> para compilar nosso c√≥digo de <code>string.c</code> para <code>string</code>, com todos os argumentos necess√°rios ou sinalizadores passados.</p>
</li>
</ul>
<p><strong>Blocos do Scratch em C</strong></p>
<ul>
<li>
<p>O bloco ‚Äúdefinir [contador] para (0)‚Äù est√° criando uma vari√°vel e, em C, escrever√≠amos <code>int contador = 0;</code>, onde <code>int</code> especifica que o tipo da nossa vari√°vel √© um n√∫mero inteiro.
<img alt="bloco com a etiqueta 'definir contador para (0)' - block labeled 'set counter to (0)'" src="https://cs50.harvard.edu/x/2020/notes/1/set_counter_to_0.png" /></p>
</li>
<li>
<p>‚Äúalterar [contador] por (1)‚Äù √© <code>contador = contador + 1;</code> em C. (Em C, <code>=</code> n√£o √© como um sinal de igual em uma equa√ß√£o, onde estamos dizendo que <code>contador</code> √© igual a <code>contador + 1</code>. Em vez disso, <code>=</code> √© um operador de atribui√ß√£o que significa ‚Äúcopiar o valor √† direita no valor √† esquerda‚Äù.) E observe que n√£o precisamos mais dizer <code>int</code>, pois presume-se que j√° especificamos anteriormente que <code>contador</code> √© um <code>int</code>, com algum valor existente. Tamb√©m podemos dizer <code>contador += 1;</code> ou <code>contador++;</code>, ambos os quais s√£o ‚Äúsintaxe simplificada‚Äù ou atalhos que t√™m o mesmo efeito com menos caracteres para digitar.
<img alt="bloco com a etiqueta 'alterar contador por (1)' - block labeled 'change counter by (1)'" src="https://cs50.harvard.edu/x/2020/notes/1/change_counter_by_1.png" /></p>
</li>
<li>
<p>Uma condi√ß√£o seria mapeada para:
<img alt="bloco com a etiqueta 'se &lt; (x) &lt; (y) &gt; ent√£o', dentro do qual h√° um bloco com a etiqueta 'dizer (x √© menor que y)' - block labeled 'if &lt; (x) &lt; (y)&gt; then', inside which there is a block labeled 'say (x is less than y)'" src="https://cs50.harvard.edu/x/2020/notes/1/if_x_y.png" /></p>
</li>
</ul>
<p><code>c
      if (x &lt; y)
      {
          printf("x √© menor que y\n");
      }</code></p>
<ul>
<li>
<p>Observe que, em C, usamos <code>{</code> e <code>}</code> (bem como indenta√ß√£o) para indicar como as linhas de c√≥digo devem ser aninhadas.</p>
</li>
<li>
<p>Tamb√©m podemos ter condi√ß√µes se-sen√£o:
<img alt="bloco com a etiqueta 'se &lt; (x) &lt; (y) &gt; ent√£o', dentro do qual h√° um bloco com a etiqueta 'dizer (x √© menor que y)', o bloco pai tamb√©m tem um 'sen√£o', dentro do qual h√° um bloco com a etiqueta 'dizer (x n√£o √© menor que y)' - block labeled 'if &lt; (x) &lt; (y)&gt; then', inside which there is a block labeled 'say (x is less than y)', parent block also has an 'else', inside which there is a block labeled 'say (x is not less than y)'" src="https://cs50.harvard.edu/x/2020/notes/1/if_else.png" /></p>
</li>
</ul>
<p><code>c
      if (x &lt; y)
      {
          printf("x √© menor que y\n");
      }
      else
      {
          printf("x n√£o √© menor que y\n");
      }</code></p>
<ul>
<li>
<p>Observe que as linhas de c√≥digo que n√£o s√£o, elas mesmas, uma a√ß√£o (<code>if...</code> e as chaves) n√£o terminam em ponto e v√≠rgula.</p>
</li>
<li>
<p>E at√© mesmo <code>sen√£o se</code>:
<img alt="bloco com a etiqueta 'se &lt; (x) &lt; (y) &gt; ent√£o', dentro do qual h√° um bloco com a etiqueta 'dizer (x √© menor que y)', o bloco pai tamb√©m tem um 'sen√£o', dentro do qual h√° um bloco aninhado com a etiqueta 'se &lt; (x) &gt; (y) &gt; ent√£o', dentro do qual h√° um bloco com a etiqueta 'dizer (x √© maior que y)', o bloco pai tamb√©m tem um 'sen√£o', dentro do qual h√° um bloco com a etiqueta 'se &lt; (x) = (y) &gt; ent√£o', dentro do qual h√° um bloco com a etiqueta 'dizer (x √© igual a y)' - block labeled 'if &lt; (x) &lt; (y)&gt; then', inside which there is a block labeled 'say (x is less than y)', parent block also has an 'else', inside which is a nesting of a block labeled 'if &lt; (x) &gt; (y) &gt; then', inside which there is a block labeled 'say (x is greater than y)', parent block also has an 'else', inside which there is a block labeled 'if &lt; (x) = (y) &gt; then', inside which there is a block labeled 'say (x is equal to y)'" src="https://cs50.harvard.edu/x/2020/notes/1/if_else_if.png" /></p>
</li>
</ul>
<p><code>c
      if (x &lt; y)
      {
          printf("x √© menor que y\n");
      }
      else if (x &gt; y)
      {
          printf("x √© maior que y\n");
      }
      else if (x == y)
      {
          printf("x √© igual a y\n");
      }</code></p>
<ul>
<li>Observe que, para comparar dois valores em C, usamos <code>==</code>, dois sinais de igual.</li>
<li>
<p>E, logicamente, n√£o precisamos de <code>if (x == y)</code> na condi√ß√£o final, pois esse √© o √∫nico caso restante, e podemos simplesmente dizer <code>else</code>.</p>
</li>
<li>
<p>Os loops podem ser escritos como o seguinte:
<img alt="bloco com a etiqueta 'para sempre', dentro do qual h√° um bloco com a etiqueta 'dizer (ol√°, mundo)' - block labeled 'forever', inside which there is a block labeled 'say (hello, world)'" src="https://cs50.harvard.edu/x/2020/notes/1/forever.png" /></p>
</li>
</ul>
<p><code>c
      while (true)
      {
          printf("ol√°, mundo\n");
      }</code></p>
<ul>
<li>
<p>A palavra-chave <code>while</code> tamb√©m requer uma condi√ß√£o, ent√£o usamos <code>true</code> como a express√£o booleana para garantir que nosso loop seja executado para sempre. Nosso programa verificar√° se a express√£o √© avaliada como <code>true</code> (o que sempre ser√° o caso) e, em seguida, executar√° as linhas dentro das chaves. Em seguida, repetir√° isso at√© que a express√£o n√£o seja mais verdadeira (o que n√£o mudar√° neste caso).</p>
</li>
<li>
<p>Poder√≠amos fazer algo um certo n√∫mero de vezes com <code>while</code>:
<img alt="bloco com a etiqueta 'repetir (50)', dentro do qual h√° um bloco com a etiqueta 'dizer (ol√°, mundo)' - block labeled 'repeat (50)', inside which there is a block labeled 'say (hello, world)'" src="https://cs50.harvard.edu/x/2020/notes/1/repeat.png" /></p>
</li>
</ul>
<p><code>c
      int i = 0;
      while (i &lt; 50)
      {
          printf("ol√°, mundo\n");
          i++;
      }</code></p>
<ul>
<li>Criamos uma vari√°vel, <code>i</code>, e a definimos como 0. Ent√£o, enquanto <code>i &lt; 50</code>, executamos algumas linhas de c√≥digo e adicionamos 1 a <code>i</code> ap√≥s cada execu√ß√£o.</li>
<li>
<p>As chaves em torno das duas linhas dentro do loop <code>while</code> indicam que essas linhas ser√£o repetidas e podemos adicionar linhas adicionais ao nosso programa depois, se quisermos.</p>
</li>
<li>
<p>Para fazer a mesma repeti√ß√£o, mais comumente podemos usar a palavra-chave <code>for</code>:</p>
</li>
</ul>
<p><code>c
      for (int i = 0; i &lt; 50; i++)
      {
          printf("ol√°, mundo\n");
      }</code></p>
<ul>
<li>Novamente, primeiro criamos uma vari√°vel chamada <code>i</code> e a definimos como 0. Ent√£o, verificamos se <code>i &lt; 50</code> toda vez que alcan√ßamos o in√≠cio do loop, antes de executar qualquer parte do c√≥digo dentro dele. Se essa express√£o for verdadeira, ent√£o executamos o c√≥digo interno. Finalmente, depois de executar o c√≥digo interno, usamos <code>i++</code> para adicionar um a <code>i</code> e o loop se repete.</li>
</ul>
<h2>Tipos, formatos, operadores</h2>
<ul>
<li>H√° outros tipos que podemos usar para as nossas vari√°veis<ul>
<li><code>bool</code>, uma express√£o booleana de <code>true</code> ou <code>false</code></li>
<li><code>char</code>, um √∫nico caractere como <code>a</code> ou <code>2</code></li>
<li><code>double</code>, um valor de ponto flutuante com ainda mais d√≠gitos</li>
<li><code>float</code>, um valor de ponto flutuante, ou n√∫mero real com um valor decimal</li>
<li><code>int</code>, inteiros at√© um determinado tamanho, ou n√∫mero de bits</li>
<li><code>long</code>, inteiros com mais bits, para que possam contar mais alto</li>
<li><code>string</code>, uma cadeia de caracteres</li>
</ul>
</li>
<li>E a biblioteca CS50 tem fun√ß√µes correspondentes para obter entrada de v√°rios tipos:<ul>
<li><code>get_char</code></li>
<li><code>get_double</code></li>
<li><code>get_float</code></li>
<li><code>get_int</code></li>
<li><code>get_long</code></li>
<li><code>get_string</code></li>
</ul>
</li>
<li>Para <code>printf</code>, tamb√©m, h√° diferentes espa√ßos reservados para cada tipo:<ul>
<li><code>%c</code> para caracteres</li>
<li><code>%f</code> para flutuantes, duplos</li>
<li><code>%i</code> para ints</li>
<li><code>%li</code> para longos</li>
<li><code>%s</code> para strings</li>
</ul>
</li>
<li>E existem alguns operadores matem√°ticos que podemos usar:<ul>
<li><code>+</code> para adi√ß√£o</li>
<li><code>-</code> para subtra√ß√£o</li>
<li><code>*</code> para multiplica√ß√£o</li>
<li><code>/</code> para divis√£o</li>
<li><code>%</code> para resto</li>
</ul>
</li>
</ul>
<h1>Mais exemplos</h1>
<ul>
<li>Para cada um desses exemplos, voc√™ pode clicar nos <a href="../../weeks/1/">links do sandbox</a> para executar e editar suas pr√≥prias c√≥pias deles.</li>
<li>
<p>Em <code>int.c</code>, obtemos e imprimimos um inteiro:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int idade = get_int("Qual √© a sua idade?\n");
      int dias = idade * 365;
      printf("Voc√™ tem pelo menos %i dias de idade.\n", dias);
  }
</code></pre>
<ul>
<li>Observe que usamos <code>%i</code> para imprimir um inteiro.</li>
<li>Agora podemos executar <code>make int</code> e executar nosso programa com <code>./int</code>.</li>
<li>
<p>Podemos combinar linhas e remover a vari√°vel <code>dias</code> com:</p>
<pre><code>  int idade = get_int("Qual √© a sua idade?\n");
  printf("Voc√™ tem pelo menos %i dias de idade.\n", idade * 365);
</code></pre>
</li>
<li>
<p>Ou mesmo combinar tudo em uma linha:</p>
<pre><code>  printf("Voc√™ tem pelo menos %i dias de idade.\n", get_int("Qual √© a sua idade?\n") * 365);
</code></pre>
</li>
<li>
<p>No entanto, quando uma linha fica muito longa ou complicada, pode ser melhor manter duas ou at√© tr√™s linhas para facilitar a leitura.</p>
</li>
</ul>
</li>
<li>
<p>Em <code>float.c</code>, podemos obter n√∫meros decimais (chamados de valores de ponto flutuante em computadores, porque o ponto decimal pode "flutuar" entre os d√≠gitos, dependendo do n√∫mero):</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      float pre√ßo = get_float("Qual √© o pre√ßo?\n");
      printf("Seu total √© %f.\n", pre√ßo * 1.0625);
  }
</code></pre>
<ul>
<li>Agora, se compilarmos e executarmos nosso programa, veremos um pre√ßo impresso com impostos.</li>
<li>Podemos especificar o n√∫mero de d√≠gitos impressos ap√≥s a v√≠rgula decimal com um espa√ßo reservado como <code>%.2f</code> para dois d√≠gitos ap√≥s a v√≠rgula decimal.</li>
</ul>
</li>
<li>
<p>Com <code>parity.c</code>, podemos verificar se um n√∫mero √© par ou √≠mpar:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n = get_int("n: ");

      if (n % 2 == 0)
      {
          printf("par\n");
      }
      else
      {
          printf("√≠mpar\n");
      }
  }
</code></pre>
<ul>
<li>Com o operador <code>%</code> (m√≥dulo), podemos obter o restante de <code>n</code> ap√≥s sua divis√£o por 2. Se o restante for 0, sabemos que <code>n</code> √© par. Caso contr√°rio, sabemos que <code>n</code> √© √≠mpar.</li>
<li>Fun√ß√µes como <code>get_int</code> da biblioteca CS50 fazem a verifica√ß√£o de erros, onde apenas as entradas do usu√°rio que correspondem ao tipo desejado s√£o aceitas.</li>
</ul>
</li>
<li>
<p>Em <code>conditions.c</code>, transformamos os trechos de condi√ß√£o anteriores em um programa:</p>
<pre><code>  // Condi√ß√µes e operadores relacionais

  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Solicita ao usu√°rio x
      int x = get_int("x: ");

      // Solicita ao usu√°rio y
      int y = get_int("y: ");

      // Compara x e y
      if (x &lt; y)
      {
          printf("x √© menor que y\n");
      }
      else if (x &gt; y)
      {
          printf("x √© maior que y\n");
      }
      else
      {
          printf("x √© igual a y\n");
      }
  }
</code></pre>
<ul>
<li>As linhas que come√ßam com <code>//</code> s√£o coment√°rios, ou nota para humanos que o compilador ir√° ignorar.</li>
<li>Para David compilar e executar este programa em seu sandbox, ele primeiro precisava executar <code>cd src1</code> no terminal. Isso altera o diret√≥rio ou pasta para aquele no qual ele salvou todos os arquivos de origem da aula. Ent√£o, ele poderia executar <code>make conditions</code> e <code>./conditions</code>. Com <code>pwd</code>, ele pode ver que est√° em uma pasta <code>src1</code> (dentro de outras pastas). E <code>cd</code> por si s√≥, sem argumentos, nos levar√° de volta para nossa pasta padr√£o no sandbox.</li>
</ul>
</li>
<li>
<p>Em <code>agree.c</code>, podemos pedir ao usu√°rio para confirmar ou negar algo:</p>
<pre><code>  // Operadores l√≥gicos

  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Solicita ao usu√°rio que concorde
      char c = get_char("Voc√™ concorda?\n");

      // Verifica se concordou
      if (c == 'S' || c == 's')
      {
          printf("Concordo.\n");
      }
      else if (c == 'N' || c == 'n')
      {
          printf("N√£o concordo.\n");
      }
  }
</code></pre>
<ul>
<li>Usamos duas barras verticais, <code>||</code>, para indicar um "ou" l√≥gico, seja qual for a express√£o que pode ser verdadeira para que a condi√ß√£o seja seguida.</li>
<li>E se nenhuma das express√µes for verdadeira, nada acontecer√°, pois nosso programa n√£o tem um loop.</li>
</ul>
</li>
<li>
<p>Vamos implementar o programa de tosse da semana 0:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("tosse\n");
      printf("tosse\n");
      printf("tosse\n");
  }
</code></pre>
</li>
<li>
<p>Podemos usar um loop <code>for</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt; 3; i++)
      {
          printf("tosse\n");
      }
  }
</code></pre>
<ul>
<li>Por conven√ß√£o, os programadores tendem a come√ßar a contar em 0 e, portanto, <code>i</code> ter√° os valores de <code>0</code>, <code>1</code> e <code>2</code> antes de parar, para um total de tr√™s itera√ß√µes. Tamb√©m poder√≠amos escrever <code>for (int i = 1; i &lt;= 3; i++)</code> para o mesmo efeito final.</li>
</ul>
</li>
<li>
<p>Podemos mover a linha <code>printf</code> para sua pr√≥pria fun√ß√£o:</p>
<pre><code>  #include &lt;stdio.h&gt;

  void tosse(void);

  int main(void)
  {
      for (int i = 0; i &lt; 3; i++)
      {
          tosse();
      }
  }

  void tosse(void)
  {
      printf("tosse\n");
  }
</code></pre>
<ul>
<li>Declaramos uma nova fun√ß√£o com <code>void tosse(void);</code> antes que nossa fun√ß√£o <code>main</code> a chame. O compilador C l√™ nosso c√≥digo de cima para baixo, ent√£o precisamos dizer a ele que a fun√ß√£o <code>tosse</code> existe, antes de us√°-la. Ent√£o, ap√≥s nossa fun√ß√£o <code>main</code>, podemos implementar a fun√ß√£o <code>tosse</code>. Dessa forma, o compilador sabe que a fun√ß√£o existe e podemos manter nossa fun√ß√£o <code>main</code> perto do topo.</li>
<li>E nossa fun√ß√£o <code>tosse</code> n√£o recebe nenhuma entrada, ent√£o temos <code>tosse(void)</code>.</li>
</ul>
</li>
<li>
<p>Podemos abstrair a <code>tosse</code> ainda mais:</p>
<pre><code>  #include &lt;stdio.h&gt;

  void tosse(int n);

  int main(void)
  {
      tosse(3);
  }

  void tosse(int n)
  {
      for (int i = 0; i &lt; n; i++)
      {
          printf("tosse\n");
      }
  }
</code></pre>
<ul>
<li>Agora, quando queremos imprimir "tosse" qualquer n√∫mero de vezes, podemos simplesmente chamar a mesma fun√ß√£o. Observe que, com <code>void tosse(int n)</code>, indicamos que a fun√ß√£o <code>tosse</code> recebe como entrada um <code>int</code>, que chamamos de <code>n</code>. E dentro de <code>tosse</code>, usamos <code>n</code> em nosso loop <code>for</code> para imprimir "tosse" o n√∫mero correto de vezes.</li>
</ul>
</li>
<li>
<p>Vamos dar uma olhada em <code>positivo.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int obter_ inteiro_positivo(void);

  int main(void)
  {
      int i = obter_inteiro_positivo();
      printf("%i\n", i);
  }

  // Solicita ao usu√°rio um inteiro positivo
  int obter_ inteiro_positivo(void)
  {
      int n;
      fa√ßa
      {
          n = get_int("%s", "Inteiro positivo: ");
      }
      Enquanto (n &lt; 1);
      Retorno n;
  }
</code></pre>
<ul>
<li>A biblioteca CS50 n√£o tem uma fun√ß√£o <code>obter_inteiro_positivo</code>, mas podemos escrever uma n√≥s mesmos. Nossa fun√ß√£o <code>int obter_inteiro_positivo(void)</code> solicitar√° ao usu√°rio um <code>int</code> e retornar√° esse <code>int</code>, que nossa fun√ß√£o <code>main</code> armazena como <code>i</code>. Em <code>obter_inteiro_positivo</code>, inicializamos uma vari√°vel, <code>int n</code>, sem atribuir um valor a ela ainda. Ent√£o, temos uma nova constru√ß√£o, <code>fa√ßa ... enquanto</code>, que faz algo <em>primeiro</em>, ent√£o verifica uma condi√ß√£o e repete at√© que a condi√ß√£o deixe de ser verdadeira.</li>
<li>Assim que o loop terminar porque temos um <code>n</code> que n√£o √© "&lt; 1", podemos retorn√°-lo com a palavra-chave <code>return</code>. E de volta √† nossa fun√ß√£o <code>main</code>, podemos definir <code>int i</code> para esse valor.</li>
</ul>
</li>
</ul>
<h2>Telas</h2>
<ul>
<li>
<p>Podemos desejar um programa que imprima parte de uma tela de um videogame, como Super Mario Bros. Em <code>mario0.c</code>, temos:</p>
<pre><code>  // Imprime uma linha de 4 pontos de interroga√ß√£o

  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("????\n");
  }
</code></pre>
</li>
<li>
<p>Podemos pedir para o usu√°rio um n√∫mero de pontos de interroga√ß√£o e, em seguida, imprimi-los, com <code>mario2.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n;
      do
      {
          n = get_int("Largura: ");
      }
      while (n &lt; 1);
      for (int i = 0; i &lt; n; i++)
      {
          printf("?");
      }
      printf("\n");
  }
</code></pre>
</li>
<li>
<p>E podemos imprimir um conjunto bidimensional de blocos com <code>mario8.c</code>:</p>
<pre><code>  // Imprime uma grade nxn de tijolos com um loop

  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n;
      do
      {
          n = get_int("Tamanho: ");
      }
      while (n &lt; 1);
      for (int i = 0; i &lt; n; i++)
      {
          for (int j = 0; j &lt; n; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
<ul>
<li>Observe que temos dois loops aninhados, onde o loop externo usa <code>i</code> para fazer tudo dentro das vezes <code>n</code> e o loop interno usa <code>j</code>, uma vari√°vel diferente, para fazer algo <code>n</code> vezes para cada uma daquelas vezes. Em outras palavras, o loop externo imprime <code>n</code> ‚Äúlinhas‚Äù ou linhas, e o loop interno imprime <code>n</code> ‚Äúcolunas‚Äù ou caracteres ‚Äú#‚Äù, em cada linha.</li>
</ul>
</li>
<li>
<p>Outros exemplos n√£o abordados em aula est√£o dispon√≠veis em ‚ÄúC√≥digo-fonte‚Äù para a <a href="../../weeks/1/">Semana 1</a>.</p>
</li>
</ul>
<p><strong># Mem√≥ria imprecis√£o e overflow</strong></p>
<ul>
<li>Nosso computador possui mem√≥ria em chips de hardware chamados RAM, mem√≥ria de acesso aleat√≥rio. Nossos programas utilizam essa RAM para armazenar dados enquanto s√£o executados, por√©m essa mem√≥ria √© finita. Portanto, com um n√∫mero finito de bits n√£o podemos representar todos os n√∫meros possiveis (dos quais existe um n√∫mero infinito). Ent√£o nosso computador tem um determinado n√∫mero de bits para cada <code>float</code> e <code>int</code> e tem de arredondar para o valor decimal mais pr√≥ximo em determinado ponto.</li>
<li>
<p>Com <code>floats.c</code> podemos ver o que acontece quando usamos floats:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Solicita o x ao usu√°rio
      float x = get_float("x: ");

      // Solicita o y ao usu√°rio
      float y = get_float("y: ");

      // Executa a divis√£o
      printf("x / y = %.50f\n", x / y);
  }
</code></pre>
<ul>
<li>Com <code>%50f</code>, podemos especificar o n√∫mero de casas decimais exibidos.</li>
<li>
<p>Hmm, agora obtemos...</p>
<pre><code>  x: 1
  y: 10
  x / y = 0.10000000149011611938476562500000000000000000000000
</code></pre>
</li>
<li>
<p>Acontece que isso se chama <strong>imprecis√£o de ponto flutuante</strong>, onde n√£o temos bits suficientes para armazenar todos os valores poss√≠veis ent√£o o computador tem de armazenar o valor mais pr√≥ximo poss√≠vel de 1 dividido por 10.</p>
</li>
</ul>
</li>
<li>
<p>Podemos ver um problema similar em <code>overflow.c</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;unistd.h&gt;

  int main(void)
  {
      for (int i = 1; ; i *= 2)
      {
          printf("%i\n", i);
          sleep(1);
      }
  }
</code></pre>
<ul>
<li>No nosso la√ßo <code>for</code>, definimos <code>i</code> como <code>1</code> e o dobramos com <code>*= 2</code>. (E continuaremos fazendo isso para sempre, ent√£o n√£o h√° condi√ß√£o para verifica√ß√£o.)</li>
<li>Tamb√©m usamos a fun√ß√£o <code>sleep</code> do <code>unistd.h</code> para permitir que nosso programa pause sempre.</li>
<li>
<p>Agora, quando executamos esse programa veremos o n√∫mero crescer cada vez mais at√© que:</p>
<pre><code>  1073741824
  overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
  -2147483648
  0
  0
  ...
</code></pre>
</li>
<li>
<p>Acontece que nosso programa reconheceu que um inteiro assinado (um inteiro com um sinal positivo ou negativo) n√£o poderia armazenar esse pr√≥ximo valor e exibiu um erro. Ent√£o, uma vez que ele tentou dobr√°-lo de qualquer forma, <code>i</code> se tornou um n√∫mero negativo e ent√£o 0.</p>
</li>
<li>Esse problema √© chamado de <strong>overflow de inteiro</strong>, onde um inteiro pode ser somente t√£o grande antes que acabem os bits e ele "reinicie". Podemos imaginar adicionar um ao n√∫mero 999 decimal. O √∫ltimo digito se torna 0, pegamos o 1 emprestado para que o pr√≥ximo digito se torne 0 e obtemos 1000. Mas se tiv√©ssemos apenas tr√™s digitos, acabar√≠amos com 000 pois n√£o h√° lugar para o 1 final!</li>
</ul>
</li>
<li>
<p>O problema da virada do mil√™nio surgiu porque muitos programas armazenavam o ano-calend√°rio com apenas dois digitos, como 98 para 1998 e 99 para 1999. Por√©m quando o ano 2000 se aproximou, os programas teriam armazenado 00, levando a confus√£o entre os anos 1900 e 2000.</p>
</li>
<li>Um avi√£o Boeing 787 tamb√©m teve um bug onde um contador no gerador tinha overflow ap√≥s um certo n√∫mero de dias de opera√ß√£o cont√≠nua, visto que o n√∫mero de segundos que havia rodado j√° n√£o cabia mais naquele contador.</li>
<li>Portanto, vimos alguns problemas que podem acontecer, mas agora entendemos por que e como preven√≠-los.</li>
<li>Com o problema definido nesta semana, usaremos o CS50 Lab, constru√≠do no CS50 Sandbox, para escrever alguns programas com orienta√ß√µes para nos guiar.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>