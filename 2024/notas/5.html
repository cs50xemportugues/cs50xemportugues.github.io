<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x em Portugu√™s</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkgreen">
  <header>
    <h1>
      <a href="">CS50x em Portugu√™s</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arrays
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Mem√≥ria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estruturas de Dados
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Seguran√ßa Cibern√©tica
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projeto.html">Projeto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidade.html">Honestidade Acad√™mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/perguntas-frequentes.html">Perguntas Frequentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Livro de Notas</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Equipe</a>
      </li>
      <li>
        <a href="/2024/plano-de-curso.html">Plano de Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">P√°ginas do Manual</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Guia de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Aula 5</h2>
<ul>
<li><a href="#pointers">Ponteiros</a></li>
<li><a href="#resizing-arrays">Redimensionar matrizes</a></li>
<li><a href="#data-structures">Estruturas de dados</a></li>
<li><a href="#linked-lists">Listas vinculadas</a></li>
<li><a href="#more-data-structures">Mais estruturas de dados</a></li>
</ul>
<h2>Ponteiros</h2>
<ul>
<li>Da √∫ltima vez, aprendemos sobre ponteiros, <code>malloc</code> e outras ferramentas √∫teis para trabalhar com mem√≥ria.</li>
<li>
<p>Vamos rever este trecho de c√≥digo:</p>
<pre><code>  int main(void)
  {
      int *x;
      int *y;

      x = malloc(sizeof(int));

      *x = 42;
      *y = 13;
  }
</code></pre>
<ul>
<li>Aqui, as primeiras duas linhas de c√≥digo em nossa fun√ß√£o <code>main</code> est√£o declarando dois ponteiros, <code>x</code> e <code>y</code>. Ent√£o, alocamos mem√≥ria suficiente para um <code>int</code> com <code>malloc</code> e armazenamos o endere√ßo retornado por <code>malloc</code> em <code>x</code>.</li>
<li>Com <code>*x = 42;</code>, vamos ao endere√ßo apontado por <code>x</code> e armazenamos o valor <code>42</code> nesse local.</li>
<li>
<p>A linha final, por√©m, √© bugada, pois n√£o sabemos qual √© o valor de <code>y</code>, j√° que nunca definimos um valor para ele. Em vez disso, podemos escrever:</p>
<pre><code>  y = x;
  *y = 13;
</code></pre>
<ul>
<li>E isso ir√° definir <code>y</code> para apontar para o mesmo local que <code>x</code> faz, e ent√£o definir esse valor como <code>13</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Damos uma olhada em um clipe curto, <a href="https://www.youtube.com/watch?v=3uLKjb973HU">Divers√£o com Ponteiros com Binky</a>, que tamb√©m explica este trecho de uma forma animada!</p>
</li>
</ul>
<h2>Redimensionando arrays</h2>
<ul>
<li>Na semana 2, aprendemos sobre arrays, onde poder√≠amos armazenar o mesmo tipo de valor em uma lista lado a lado. Mas precisamos declarar o tamanho dos arrays quando os criamos e, quando quisermos aumentar o tamanho do array, a mem√≥ria ao redor dele poder√° ser ocupada por outros dados.</li>
<li>Uma solu√ß√£o pode ser alocar mais mem√≥ria em uma √°rea maior que esteja livre e mover nosso array para l√°, onde h√° mais espa√ßo. Mas precisamos copiar nosso array, o que se torna uma opera√ß√£o com tempo de execu√ß√£o <em>O</em>(<em>n</em>), uma vez que precisamos copiar cada um dos <em>n</em> elementos em um array.</li>
<li>
<p>Podemos escrever um programa como o seguinte para fazer isso em c√≥digo:</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(void)
  {
      // Aqui, alocamos mem√≥ria suficiente para tr√™s inteiros, e nossa vari√°vel
      // list apontar√° para o primeiro inteiro.
      int *list = malloc(3 * sizeof(int));
      // Devemos verificar se alocamos a mem√≥ria corretamente, pois o malloc pode
      // falhar ao obter mem√≥ria livre suficiente.
      if (list == NULL)
      {
          return 1;
      }

      // Com esta sintaxe, o compilador far√° aritm√©tica de ponteiro para n√≥s e
      // calcular√° o byte na mem√≥ria que list[0], list[1] e list[2] mapeia,
      // j√° que os inteiros t√™m 4 bytes de tamanho.
      list[0] = 1;
      list[1] = 2;
      list[2] = 3;

      // Agora, se quisermos redimensionar nosso array para 4 inteiros, tentaremos alocar
      // mem√≥ria suficiente para eles e usar temporariamente tmp para apontar para o primeiro:
      int *tmp = malloc(4 * sizeof(int));
      if (tmp == NULL)
      {
          return 1;
      }

      // Agora, copiamos inteiros do array antigo para o novo array ...
      for (int i = 0; i &lt; 3; i++)
      {
          tmp[i] = list[i];
      }

      // ... e adicionamos o quarto inteiro:
      tmp[3] = 4;

      // Devemos liberar a mem√≥ria original para list, por isso precisamos de
      // uma vari√°vel tempor√°ria para apontar para o novo array ...
      free(list);

      // ... e agora podemos definir nossa vari√°vel list para apontar para o novo array que
      // tmp aponta:
      list = tmp;

      // Agora, podemos imprimir o novo array:
      for (int i = 0; i &lt; 4; i++)
      {
          printf("%i\n", list[i]);
      }

      // E finalmente, liberar a mem√≥ria para o novo array.
      free(list);
  }
</code></pre>
</li>
<li>
<p>Acontece que na verdade h√° uma fun√ß√£o √∫til, <code>realloc</code>, que realocar√° alguma mem√≥ria:</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(void)
  {
      int *list = malloc(3 * sizeof(int));
      if (list == NULL)
      {
          return 1;
      }

      list[0] = 1;
      list[1] = 2;
      list[2] = 3;

      // Aqui, fornecemos ao realloc nosso array original que list aponta, e ele
      // retornar√° um novo endere√ßo para um novo array, com os dados antigos copiados:
      int *tmp = realloc(list, 4 * sizeof(int));
      if (tmp == NULL)
      {
          return 1;
      }
      // Agora, tudo o que precisamos fazer √© lembrar o local do novo array:
      list = tmp;

      list[3] = 4;

      for (int i = 0; i &lt; 4; i++)
      {
          printf("%i\n", list[i]);
      }

      free(list);
  }
</code></pre>
</li>
</ul>
<h2>Estruturas de dados</h2>
<ul>
<li><strong>Estruturas de dados</strong> s√£o constru√ß√µes de programa√ß√£o que nos permitem armazenar informa√ß√µes em diferentes layouts na mem√≥ria do nosso computador.</li>
<li>Para construir uma estrutura de dados, precisaremos de algumas ferramentas que j√° vimos:<ul>
<li><code>struct</code> para criar tipos de dados personalizados</li>
<li><code>.</code> para acessar propriedades em uma estrutura</li>
<li><code>*</code> para ir para um endere√ßo na mem√≥ria apontado por um ponteiro</li>
</ul>
</li>
</ul>
<h2>Listas Vinculadas</h2>
<ul>
<li>Com uma <strong>lista vinculada</strong>, podemos armazenar uma lista de valores que pode ser facilmente aumentada armazenando valores em partes diferentes da mem√≥ria:<br />
<img alt="Grade representando mem√≥ria, com tr√™s das caixas rotuladas com caixas vazias entre elas, cada uma rotulada como 1 0x123, 2 0x456 e 3 0x789" src="https://cs50.harvard.edu/x/2020/notes/5/linked_list.png" /><ul>
<li>Isso √© diferente de uma matriz, pois nossos valores n√£o est√£o mais pr√≥ximos uns dos outros na mem√≥ria.</li>
</ul>
</li>
<li>Podemos vincular nossa lista alocando, para cada elemento, mem√≥ria suficiente para o valor que desejamos armazenar e o endere√ßo do pr√≥ximo elemento:<br />
<img alt="Tr√™s caixas, cada uma dividida em duas e rotulada como (1 0x123 e 0x456), (2 0x456 e 0x789) e (3 0x789 e NULL)" src="https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png" /><ul>
<li>A prop√≥sito, <code>NUL</code> se refere a <code>\0</code>, um caractere que encerra uma string, e <code>NULL</code> se refere a um endere√ßo todo zero ou um ponteiro nulo que podemos considerar como n√£o apontando para lugar nenhum.</li>
</ul>
</li>
<li>Ao contr√°rio dos arrays, n√£o acessamos mais elementos aleatoriamente em uma lista vinculada. Por exemplo, n√£o podemos mais acessar o quinto elemento da lista calculando onde ele est√°, em tempo constante. (Como sabemos que os arrays armazenam elementos consecutivos, podemos adicionar 1 ou 4 ou o tamanho do nosso elemento para calcular endere√ßos.) Em vez disso, temos que seguir o ponteiro de cada elemento, um de cada vez. E precisamos alocar o dobro de mem√≥ria do que precis√°vamos antes para cada elemento.</li>
<li>
<p>No c√≥digo, podemos criar nossa pr√≥pria struct chamada <code>node</code> (como um n√≥ de um gr√°fico em matem√°tica) e precisamos armazenar um <code>int</code> e um ponteiro para o pr√≥ximo <code>node</code> chamado <code>next</code>:</p>
<pre><code>  typedef struct node
  {
      int number;
      struct node *next;
  }
  node;
</code></pre>
<ul>
<li>Iniciamos esta struct com <code>typedef struct node</code> para que possamos nos referir a um <code>node</code> dentro de nossa struct.</li>
</ul>
</li>
<li>
<p>Podemos construir uma lista vinculada no c√≥digo come√ßando com nossa struct. Primeiro, queremos lembrar uma lista vazia para que possamos usar o ponteiro nulo: <code>node *list = NULL;</code>.</p>
</li>
<li>
<p>Para adicionar um elemento, primeiro precisamos alocar um pouco de mem√≥ria para um n√≥ e definir seus valores:</p>
<pre><code>  node *n = malloc(sizeof(node));
  // Queremos ter certeza de que o malloc conseguiu obter mem√≥ria para n√≥s:
  if (n != NULL)
  {
      // Isso √© equivalente a (*n).number, onde primeiro vamos ao n√≥ apontado
      // por n e ent√£o definimos a propriedade number. Em C, tamb√©m podemos usar essa
      // nota√ß√£o de seta:
      n-&gt;number = 2;
      // Ent√£o precisamos armazenar um ponteiro para o pr√≥ximo n√≥ em nossa lista, mas o
      // novo n√≥ n√£o apontar√° para nada (por enquanto):
      n-&gt;next = NULL;
  }
</code></pre>
</li>
<li>
<p>Agora nossa lista pode apontar para este n√≥: <code>list = n;</code>:<br />
<img alt="Uma caixa rotulada como lista com uma seta para fora apontando para duas caixas conectadas, uma com 2 e uma vazia)" src="https://cs50.harvard.edu/x/2020/notes/5/list_with_one_node.png" /></p>
</li>
<li>Para adicionar √† lista, criaremos um novo n√≥ da mesma forma, talvez com o valor 4. Mas agora precisamos atualizar o ponteiro em nosso primeiro n√≥ para apontar para ele.</li>
<li>
<p>Como nosso ponteiro <code>list</code> aponta apenas para o primeiro n√≥ (e n√£o podemos ter certeza de que a lista tem apenas um n√≥), precisamos "seguir as migalhas de p√£o" e seguir o ponteiro next de cada n√≥:</p>
<pre><code>  // Cria um ponteiro tempor√°rio para onde list est√° apontando
  node *tmp = list;
  // Enquanto o n√≥ tiver um ponteiro next ...
  while (tmp-&gt;next != NULL)
  {
      // ... defina o tempor√°rio para o pr√≥ximo n√≥
      tmp = tmp-&gt;next;
  }
  // Agora, tmp aponta para o √∫ltimo n√≥ em nossa lista, e podemos atualizar seu pr√≥ximo
  // ponteiro para apontar para nosso novo n√≥.
</code></pre>
</li>
<li>
<p>Se quisermos inserir um n√≥ na frente de nossa lista vinculada, precisaremos atualizar cuidadosamente nosso n√≥ para apontar para aquele que o segue, antes de atualizar a lista. Caso contr√°rio, perderemos o resto da nossa lista:</p>
<pre><code>  // Aqui, estamos inserindo um n√≥ na frente da lista, ent√£o queremos seu
  // pr√≥ximo ponteiro para apontar para a lista original, antes de apontar a lista para
  // n:
  n-&gt;next = list;
  list = n;
</code></pre>
</li>
<li>
<p>E para inserir um n√≥ no meio de nossa lista, podemos percorrer a lista, seguindo cada elemento um de cada vez, comparando seus valores e alterando os ponteiros <code>next</code> cuidadosamente tamb√©m.</p>
</li>
<li>
<p>Com alguns volunt√°rios no palco, simulamos uma lista, com cada volunt√°rio atuando como a vari√°vel <code>list</code> ou um n√≥. √Ä medida que inserimos n√≥s na lista, precisamos de um ponteiro tempor√°rio para seguir a lista e garantir que n√£o perdamos nenhuma parte dela. Nossa lista vinculada aponta apenas para o primeiro n√≥ em nossa lista, ent√£o s√≥ podemos olhar para um n√≥ por vez, mas podemos alocar dinamicamente mais mem√≥ria conforme precisamos para aumentar nossa lista.</p>
</li>
<li>
<p>Agora, mesmo que nossa lista ligada seja ordenada, o tempo de execu√ß√£o de sua pesquisa ser√° <em>O</em>(<em>n</em>), pois temos que seguir cada n√≥ para verificar seus valores e n√£o sabemos onde ser√° o meio da nossa lista.</p>
</li>
<li>Podemos combinar todos os nossos trechos de c√≥digo em um programa completo:<pre><code>  #include&lt;stdio.h&gt;
  #include&lt;stdlib.h&gt;

  // Representa um n√≥
  typedef struct node
  {
      int number;
      struct node *next;
  }
  node;

  int main(void)
  {
      // Lista de tamanho 0, inicialmente n√£o aponta para nada
      node *list = NULL;

      // Adicionar n√∫mero √† lista
      node *n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 1;
      n-&gt;next = NULL;
      // Criamos nosso primeiro n√≥, armazenamos o valor 1 nele e deixamos o pr√≥ximo
      // ponteiro para apontar para nada. Ent√£o, nossa vari√°vel de lista pode apontar para ele.
      list = n;

      // Adicionar n√∫mero √† lista
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 2;
      n-&gt;next = NULL;
      // Agora, vamos ao nosso primeiro n√≥ para o qual list aponta e definimos o pr√≥ximo ponteiro
      // nele para apontar para nosso novo n√≥, adicionando-o ao final da lista:
      list-&gt;next = n;

      // Adicionar n√∫mero √† lista
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 3;
      n-&gt;next = NULL;
      // Podemos seguir v√°rios n√≥s com esta sintaxe, usando o next ponteiro
      // repetidamente, para adicionar nosso terceiro novo n√≥ ao final da lista:
      list-&gt;next-&gt;next = n;
      // Normalmente, por√©m, queremos um loop e uma vari√°vel tempor√°ria para adicionar
      // um novo n√≥ √† nossa lista.

      // Imprimir lista
      // Aqui podemos iterar sobre todos os n√≥s em nossa lista com um tempor√°rio
      // vari√°vel. Primeiro, temos um ponteiro tempor√°rio, tmp, que aponta para o
      // lista. Ent√£o, nossa condi√ß√£o para continuar √© que tmp n√£o seja NULL, e
      // finalmente, atualizamos tmp para o pr√≥ximo ponteiro dele mesmo.
      for (node *tmp = list; tmp != NULL; tmp = tmp-&gt;next)
      {
          // Dentro do n√≥, vamos apenas imprimir o n√∫mero armazenado:
          printf("%i\n", tmp-&gt;number);
      }

      // Lista livre
      // Como estamos liberando cada n√≥ √† medida que avan√ßamos, usaremos um loop while
      // e siga o pr√≥ximo ponteiro de cada n√≥ antes de liber√°-lo, mas veremos
      // isso com mais detalhes no Problema definido 5.
      while (list != NULL)
      {
          node *tmp = list-&gt;next;
          free(list);
          list = tmp;
      }
  }
</code></pre>
</li>
</ul>
<h2>Mais estruturas de dados</h2>
<ul>
<li>Uma <strong>√°rvore</strong> √© outra estrutura de dados em que cada n√≥ aponta para dois outros n√≥s, um √† esquerda (com um valor menor) e outro √† direita (com um valor maior):
  <img alt="√°rvore com o n√≥ 4 no centro superior, seta para a esquerda para 3 abaixo, seta para a direita para 6 abaixo; 2 tem seta para a esquerda para 1 abaixo, seta para a direita para 3 abaixo; 6 tem seta para a esquerda para 5 abaixo, seta para a direita para 7 abaixo" src="https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png" /><ul>
<li>Observe que agora h√° duas dimens√µes nesta estrutura de dados, em que alguns n√≥s est√£o em "n√≠veis" diferentes de outros. E podemos imaginar a implementa√ß√£o disso com uma vers√£o mais complexa de um n√≥ em uma lista vinculada, em que cada n√≥ n√£o tem um, mas dois ponteiros, um para o valor no "meio da metade esquerda" e outro para o valor no "meio da metade direita". E todos os elementos √† esquerda de um n√≥ s√£o menores, e todos os elementos √† direita s√£o maiores.</li>
<li>Isso √© chamado de √°rvore de pesquisa bin√°ria porque cada n√≥ tem no m√°ximo dois filhos, ou n√≥s para os quais est√° apontando, e uma √°rvore de pesquisa porque √© classificada de uma forma que nos permite pesquisar corretamente.</li>
<li>E como uma lista vinculada, queremos manter um ponteiro apenas para o in√≠cio da lista, mas neste caso queremos apontar para a raiz, ou n√≥ do topo central da √°rvore (o 4).</li>
</ul>
</li>
<li>
<p>Agora, podemos facilmente fazer uma pesquisa bin√°ria e, como cada n√≥ est√° apontando para outro, tamb√©m podemos inserir n√≥s na √°rvore sem precisar mover todos eles, como ter√≠amos que fazer em um array. Pesquisar recursivamente nesta √°rvore se parece com algo como:</p>
<pre><code>  typedef struct node
  {
      int number;
      struct node *left;
      struct node *right;
  } node;

  // Aqui, *tree √© um ponteiro para a raiz da nossa √°rvore.
  bool search(node *tree)
  {
      // Precisamos de um caso base, se a √°rvore atual (ou parte da √°rvore) for NULL,
      // para retornar falso:
      if (tree == NULL)
      {
          return false;
      }
      // Agora, dependendo se o n√∫mero no n√≥ atual √© maior ou menor,
      // podemos apenas olhar para o lado esquerdo ou direito da √°rvore:
      else if (50 &lt; tree-&gt;number)
      {
          return search(tree-&gt;left);
      }
      else if (50 &gt; tree-&gt;number)
      {
          return search(tree-&gt;right);
      }
      // Caso contr√°rio, o n√∫mero deve ser igual ao que estamos procurando:
      else {
          return true;
      }
  }
</code></pre>
</li>
<li>
<p>O tempo de execu√ß√£o de busca em √°rvore √© <em>O</em>(log <em>n</em>), e inserir n√≥s e manter a √°rvore balanceada tamb√©m √© <em>O</em>(log <em>n</em>). Gastando um pouco mais de mem√≥ria e tempo para manter a √°rvore, n√≥s obtemos agora uma busca mais r√°pida do que em uma lista ligada simples.</p>
</li>
<li>Uma estrutura de dados com tempo de execu√ß√£o de busca quase constante √© uma <strong>tabela de hash</strong>, que √© uma combina√ß√£o de uma matriz e uma lista ligada. N√≥s temos uma matriz de listas ligadas, e cada lista ligada na matriz possui elementos de uma certa categoria. Por exemplo, no mundo real, n√≥s podemos ter muitas etiquetas de nomes e podemos classific√°-las em 26 blocos, cada um rotulado com uma letra do alfabeto, ent√£o podemos encontrar etiquetas de nomes verificando apenas um bloco.</li>
<li>N√≥s podemos implementar isto em uma tabela de hash com uma matriz de 26 ponteiros, cada um dos quais aponta para uma lista ligada para uma letra do alfabeto:<br />
<img alt="matriz vertical com 26 caixas, a primeira com uma seta apontando para um bloco rotulado Albus, a segunda vazia, a terceira com uma seta apontando para um bloco rotulado Cedric ... a s√©tima com uma seta apontando para um bloco rotulado Ginny com uma seta desse bloco apontando para um bloco rotulado George..." src="https://cs50.harvard.edu/x/2020/notes/5/hash_table.png" /></li>
<li>Como n√≥s temos acesso aleat√≥rio com matrizes, podemos adicionar elementos rapidamente, e tamb√©m indexar rapidamente em um bloco.</li>
<li>Um bloco pode ter m√∫ltiplos valores correspondentes, ent√£o n√≥s vamos usar uma lista ligada para armazenar todos eles horizontalmente. (N√≥s chamamos isso de colis√£o, quando dois valores correspondem de alguma forma.)</li>
<li>Isto √© chamado de tabela de hash porque n√≥s usamos uma fun√ß√£o de hash, que pega uma entrada e a mapeia para um bloco em que ela deve ir. No nosso exemplo, a fun√ß√£o de hash est√° apenas verificando a primeira letra do nome, ent√£o ela pode retornar <code>0</code> para ‚ÄúAlbus‚Äù e <code>25</code> para ‚ÄúZacharias‚Äù.</li>
<li>Mas no pior caso, todos os nomes podem come√ßar com a mesma letra, ent√£o n√≥s podemos acabar com o equivalente de uma √∫nica lista ligada novamente. N√≥s podemos verificar as primeiras duas letras, e alocar blocos suficientes para 26*26 poss√≠veis valores de hash, ou at√© mesmo as primeiras tr√™s letras, e agora vamos precisar de 26*26*26 blocos. Mas n√≥s ainda podemos ter um pior caso onde todos os nossos valores come√ßam com os mesmos tr√™s caracteres, ent√£o o tempo de execu√ß√£o para busca √© <em>O</em>(<em>n</em>). Na pr√°tica, entretanto, n√≥s podemos chegar mais perto de <em>O</em>(1) se n√≥s tivermos tantos blocos quanto valores poss√≠veis, especialmente se n√≥s tivermos uma fun√ß√£o de hash ideal, onde n√≥s podemos classificar nossas entradas em blocos √∫nicos.</li>
<li>N√≥s podemos usar outra estrutura de dados chamada de <strong>trie</strong> (pronunciada como ‚Äútry‚Äù, abrevia√ß√£o de ‚Äúrecupera√ß√£o‚Äù):<br />
<img alt="matriz com letras de A-Z em 26 elementos, com H apontando para outra matriz com todas as 26 letras. A matriz A e E de cada um apontam para mais duas matrizes de todas as 26 letras, e isso continua em uma √°rvore at√© que as matrizes mais baixas tenham apenas uma letra marcada como v√°lida" src="https://cs50.harvard.edu/x/2020/notes/5/trie.png" /><ul>
<li>Imagine que n√≥s queremos armazenar um dicion√°rio de palavras eficientemente, e ser capaz de acessar cada uma em tempo constante. Uma trie √© como uma √°rvore, mas cada n√≥ √© uma matriz. Cada matriz ter√° cada letra, A-Z, armazenada. Para cada palavra, a primeira letra apontar√° para uma matriz, onde a pr√≥xima letra v√°lida apontar√° para outra matriz, e assim por diante, at√© que cheguemos a algo indicando o final de uma palavra v√°lida. Se a nossa palavra n√£o estiver na trie, ent√£o uma das matrizes n√£o ter√° um ponteiro ou um caractere de t√©rmino para a nossa palavra. Agora, mesmo que nossa estrutura de dados tenha muitas palavras, o tempo de busca ser√° apenas o comprimento da palavra que estamos procurando, e este pode ser um m√°ximo fixo, ent√£o n√≥s temos <em>O</em>(1) para busca e inser√ß√£o. O custo para isso, no entanto, √© 26 vezes mais mem√≥ria do que precisamos para cada caractere.</li>
</ul>
</li>
<li>H√° constru√ß√µes de n√≠vel ainda mais alto, <strong>estruturas de dados abstratas</strong>, onde n√≥s usamos nossos blocos de constru√ß√£o de matrizes, listas ligadas, tabelas de hash e tries para implementar uma solu√ß√£o para algum problema.</li>
<li>Por exemplo, uma estrutura de dados abstrata √© uma <strong>fila</strong>, onde n√≥s queremos adicionar e remover valores de forma ‚Äúprimeiro a entrar, primeiro a sair‚Äù (FIFO). Para adicionar um valor, n√≥s podemos enfileir√°-lo, e para remover um valor, n√≥s vamos desenfileir√°-lo. E n√≥s podemos implementar isso com uma matriz que redimensionamos conforme adicionamos itens, ou uma lista ligada onde n√≥s acrescentamos valores ao final.</li>
<li>Uma estrutura de dados ‚Äúoposta‚Äù seria uma <strong>pilha</strong>, onde itens adicionados mais recentemente (empurrados) s√£o removidos (retirados) primeiro, de forma ‚Äú√∫ltimo a entrar, primeiro a sair‚Äù (LIFO). Nossa caixa de entrada de e-mail √© uma pilha, onde nossos e-mails mais recentes est√£o no topo.</li>
<li>Outro exemplo √© um <strong>dicion√°rio</strong>, onde n√≥s podemos mapear chaves a valores, ou strings a valores, e podemos implementar um com uma tabela de hash onde uma palavra vem com algumas outras informa√ß√µes (como sua defini√ß√£o ou significado).</li>
<li>N√≥s vamos assistir a <a href="https://www.youtube.com/watch?v=2wM6_PuBIxY">‚ÄúJack aprende os fatos sobre filas e pilhas‚Äù</a>, uma anima√ß√£o sobre essas estruturas de dados.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>