{% extends 'layout.html' %}


{% block conteudo %}

<h1 class="no_toc" id="lecture-7">Lecture 7</h1>

<ul id="markdown-toc">
  <li><a href="#spreadsheets" id="markdown-toc-spreadsheets">Spreadsheets</a></li>
  <li><a href="#sql" id="markdown-toc-sql">SQL</a></li>
  <li><a href="#imdb" id="markdown-toc-imdb">IMDb</a></li>
  <li><a href="#multiple-tables" id="markdown-toc-multiple-tables">Multiple tables</a></li>
  <li><a href="#problems" id="markdown-toc-problems">Problems</a></li>
</ul>

<h2 id="spreadsheets">Spreadsheets</h2>

<ul>
  <li data-marker="*">Most of us are familiar with spreadsheets, rows of data, with each column in a row having a different piece of data that relate to each other somehow.</li>
  <li data-marker="*">A database is an application that can store data, and we can think of Google Sheets as one such application.</li>
  <li data-marker="*">For example, we created a Google Form to ask students their favorite TV show and genre of it. We look thorugh the responses, and see that the spreadsheet has three columns: “Timestamp”, “title”, and “genres”:<br>
<img src="spreadsheet.png" alt="image of Google Sheets spreadsheet with row 1 having cells &quot;Timestamp&quot;, &quot;title&quot;, and &quot;genres&quot;, with row 2 having cells &quot;10/28/2019 15:03:45&quot;, &quot;Dynasty&quot;, &quot;Drama, Family&quot;, and so on"></li>
  <li data-marker="*">We can download a CSV file from the spreadsheet with “File &gt; Download”, upload it to our IDE, and see that it’s a text file with comma-separated values matching the spreadsheet’s data.</li>
  <li data-marker="*">We’ll write <code class="language-plaintext highlighter-rouge">favorites.py</code>:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">csv</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">DictReader</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">"title"</span><span class="p">])</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We’re just going to open the file and make sure we can get the title of each row.</li>
    </ul>
  </li>
  <li data-marker="*">Now we can use a dictionary to count the number of times we’ve seen each title, with the keys being the titles and the values for each key an integer, tracking how many times we’ve seen that title:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">csv</span>

<span class="n">counts</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">DictReader</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s">"title"</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">title</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">title</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">" | "</span><span class="p">)</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">In each row, we can get the <code class="language-plaintext highlighter-rouge">title</code> with <code class="language-plaintext highlighter-rouge">row["title"]</code>.</li>
      <li data-marker="*">Here, if we’ve seen the title before (it’s in <code class="language-plaintext highlighter-rouge">counts</code>), we can just add 1 to the value. Otherwise, we need to set the initial value to 1.</li>
      <li data-marker="*">Finally, we can print out our dictionary’s keys and values with a separator so it’s a bit easier to read.</li>
    </ul>
  </li>
  <li data-marker="*">We can change the way we iterate to <code class="language-plaintext highlighter-rouge">for title, count in sorted(counts.items()):</code>, and we’ll see our dictionary sorted by the keys, alphabetically.</li>
  <li data-marker="*">But we can sort by the key-value pairs in the dictionary with:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counts</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We define a function, <code class="language-plaintext highlighter-rouge">f</code>, which just returns the value from the <code class="language-plaintext highlighter-rouge">item</code> in the dictionary with <code class="language-plaintext highlighter-rouge">item[1]</code>. The <code class="language-plaintext highlighter-rouge">sorted</code> function, in turn, can use that as the key to sort the dictionary’s items. And we’ll also pass in <code class="language-plaintext highlighter-rouge">reverse=True</code> to sort from largest to smallest, instead of smallest to largest.</li>
    </ul>
  </li>
  <li data-marker="*">We can actually define our function in the same line, with this syntax:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counts</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We pass in a lambda, or anonymous function, as the key, which takes in the <code class="language-plaintext highlighter-rouge">item</code> and returns <code class="language-plaintext highlighter-rouge">item[1]</code>.</li>
    </ul>
  </li>
  <li data-marker="*">Finally, we can make all the titles lowercase with <code class="language-plaintext highlighter-rouge">title = row["title"].lower()</code>, so our counts can be a little more accurate even if the names weren’t typed in the exact same way.</li>
</ul>

<h2 id="sql">SQL</h2>

<ul>
  <li data-marker="*">We’ll look at a new program in our terminal window, <code class="language-plaintext highlighter-rouge">sqlite3</code>, a command-line program that lets us use another language, SQL (pronounced like “sequel”).</li>
  <li data-marker="*">We’ll run some commands to create a new database called <code class="language-plaintext highlighter-rouge">favorites.db</code> and import our CSV file into a table called “favorites”:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/ $ sqlite3 favorites.db
SQLite version 3.22.0 2018-01-22 18:45:57
Enter ".help" for usage hints.
sqlite&gt; .mode csv
sqlite&gt; .import "CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv" favorites
</code></pre></div>    </div>
  </li>
  <li data-marker="*">We see a <code class="language-plaintext highlighter-rouge">favorites.db</code> in our IDE after we run this, and now we can use SQL to interact with our data:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlite&gt; SELECT title FROM favorites;
title
Dynasty
The Office
Blindspot
24
Friends
psych
Veep
Survivor
...
</code></pre></div>    </div>
  </li>
  <li data-marker="*">We can even sort our results:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlite&gt; SELECT title FROM favorites ORDER BY title;
title
/
24
9009
Adventure Time
Airplane Repo
Always Sunny
Ancient Aliens
...
</code></pre></div>    </div>
  </li>
  <li data-marker="*">And get a count of the number of times each title appears:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlite&gt; SELECT title, COUNT(title) FROM favorites GROUP BY title;
title | COUNT(title)
/ | 1
24 | 1
9009 | 1
Adventure Time | 1
Airplane Repo | 1
Always Sunny | 1
Ancient Aliens | 1
...
</code></pre></div>    </div>
  </li>
  <li data-marker="*">We can even set the count of each title to a new variable, <code class="language-plaintext highlighter-rouge">n</code>, and order our results by that, in descending order. Then we can see the top 10 results with <code class="language-plaintext highlighter-rouge">LIMIT 10</code>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlite&gt; SELECT title, COUNT(title) AS n FROM favorites GROUP BY title ORDER BY n DESC LIMIT 10;
title | n
The Office | 30
Friends | 20
Game of Thrones | 20
Breaking Bad | 14
Black Mirror | 9
Rick and Morty | 9
Brooklyn Nine-Nine | 5
Game of thrones | 5
No | 5
Prison Break | 5
</code></pre></div>    </div>
  </li>
  <li data-marker="*">SQL is a language that lets us work with a relational database, an application lets us store data and work with them more quickly than with a CSV.</li>
  <li data-marker="*">With <code class="language-plaintext highlighter-rouge">.schema</code>, we can see how the format for the table for our data is created:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlite&gt; .schema
CREATE TABLE favorites(
  "Timestamp" TEXT,
  "title" TEXT,
  "genres" TEXT
);
</code></pre></div>    </div>
  </li>
  <li data-marker="*">It turns out that, when working with data, we only need four operations:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">CREATE</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">READ</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">UPDATE</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">DELETE</code></li>
    </ul>
  </li>
  <li data-marker="*">In SQL, the commands to perform each of these operations are:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">INSERT</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">SELECT</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">UPDATE</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">DELETE</code></li>
    </ul>
  </li>
  <li data-marker="*">First, we’ll need to insert a table with the <code class="language-plaintext highlighter-rouge">CREATE TABLE table (column type, ...);</code> command.</li>
  <li data-marker="*">SQL, too, has its own data types to optimize the amount of space used for storing data:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">BLOB</code>, for “binary large object”, raw binary data that might represent files</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">INTEGER</code>
        <ul>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">smallint</code></li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">integer</code></li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">bigint</code></li>
        </ul>
      </li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">NUMERIC</code>
        <ul>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">boolean</code></li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">date</code></li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">datetime</code></li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">numeric(scale,precision)</code>, which solves floating-point imprecision by using as many bits as needed, for each digit before and after the decimal point</li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">time</code></li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">timestamp</code></li>
        </ul>
      </li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">REAL</code>
        <ul>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">real</code>, for floating-point values</li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">double precision</code>, with more bits</li>
        </ul>
      </li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">TEXT</code>
        <ul>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">char(n)</code>, for an exact number of characters</li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">varchar(n)</code>, for a variable number of characters, up to a certain limit</li>
          <li data-marker="*"><code class="language-plaintext highlighter-rouge">text</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*">SQLite is one database application that supports SQL, and there are many companies with server applications that support SQL, includes Oracle Database, MySQL, PostgreSQL, MariaDB, and Microsoft Access.</li>
  <li data-marker="*">After inserting values, we can use functions to perform calculations, too:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">AVG</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">COUNT</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">DISTINCT</code>, for getting distinct values without duplicates</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">MAX</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">MIN</code></li>
      <li data-marker="*">…</li>
    </ul>
  </li>
  <li data-marker="*">There are also other operations we can combine as needed:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">WHERE</code>, matching on some strict condition</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">LIKE</code>, matching on substrings for text</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">LIMIT</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">GROUP BY</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">ORDER BY</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">JOIN</code>, combining data from multiple tables</li>
    </ul>
  </li>
  <li data-marker="*">We can update data with <code class="language-plaintext highlighter-rouge">UPDATE table SET column=value WHERE condition;</code>, which could include 0, 1, or more rows depending on our condition. For example, we might say <code class="language-plaintext highlighter-rouge">UPDATE favorites SET title = "The Office" WHERE title LIKE "%office"</code>, and that will set all the rows with the title containing “office” to be “The Office” so we can make them consistent.</li>
  <li data-marker="*">And we can remove matching rows with <code class="language-plaintext highlighter-rouge">DELETE FROM table WHERE condition;</code>, as in <code class="language-plaintext highlighter-rouge">DELETE FROM favorites WHERE title = "Friends";</code>.</li>
  <li data-marker="*">We can even delete an entire table altogether with another command, <code class="language-plaintext highlighter-rouge">DROP</code>.</li>
</ul>

<h2 id="imdb">IMDb</h2>

<ul>
  <li data-marker="*">IMDb, or “Internet Movie Database”, has datasets <a href="https://www.imdb.com/interfaces/">available to download</a> as TSV, or tab-separate values, files.</li>
  <li data-marker="*">For example, we can download <code class="language-plaintext highlighter-rouge">title.basics.tsv.gz</code>, which will contain basic data about titles:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">tconst</code>, a unique identifier for each title, like <code class="language-plaintext highlighter-rouge">tt4786824</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">titleType</code>, the type of the title, like <code class="language-plaintext highlighter-rouge">tvSeries</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">primaryTitle</code>, the main title used, like <code class="language-plaintext highlighter-rouge">The Crown</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">startYear</code>, the year a title was released, like <code class="language-plaintext highlighter-rouge">2016</code></li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">genres</code>, a comma-separated list of genres, like <code class="language-plaintext highlighter-rouge">Drama,History</code></li>
    </ul>
  </li>
  <li data-marker="*">We take a look at <code class="language-plaintext highlighter-rouge">title.basics.tsv</code> after we’ve unzipped it, and we see that the first rows are indeed the headers we expected and each row has values separated by tabs. But the file has more than 6 million rows, so even searching for one value takes a moment.</li>
  <li data-marker="*">We’ll download the file into our IDE with <code class="language-plaintext highlighter-rouge">wget</code>, and then <code class="language-plaintext highlighter-rouge">gunzip</code> to unzip it. But our IDE doesn’t have enough space, so we’ll use our Mac’s terminal instead.</li>
  <li data-marker="*">We’ll write <code class="language-plaintext highlighter-rouge">import.py</code> to read the file in:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">csv</span>

<span class="c1"># Open TSV file for reading
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"title.basics.tsv"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">titles</span><span class="p">:</span>

    <span class="c1"># Since the file is a TSV file, we can use the CSV reader and change
</span>    <span class="c1"># the separator to a tab.
</span>    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">titles</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Open new CSV file for writing
</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"shows0.csv"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">shows</span><span class="p">:</span>

        <span class="c1"># Create writer
</span>        <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">writer</span><span class="p">(</span><span class="n">shows</span><span class="p">)</span>

        <span class="c1"># Write header of the columns we want
</span>        <span class="n">writer</span><span class="p">.</span><span class="n">writerow</span><span class="p">([</span><span class="s">"tconst"</span><span class="p">,</span> <span class="s">"primaryTitle"</span><span class="p">,</span> <span class="s">"startYear"</span><span class="p">,</span> <span class="s">"genres"</span><span class="p">])</span>

        <span class="c1"># Iterate over TSV file
</span>        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>

            <span class="c1"># If non-adult TV show
</span>            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"titleType"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"tvSeries"</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s">"isAdult"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">:</span>

                <span class="c1"># Write row
</span>                <span class="n">writer</span><span class="p">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s">"tconst"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"primaryTitle"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"genres"</span><span class="p">]])</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">Now, we can open <code class="language-plaintext highlighter-rouge">shows0.csv</code> and see a smaller set of data. But it turns out, for some of the rows, <code class="language-plaintext highlighter-rouge">startYear</code> has a value of <code class="language-plaintext highlighter-rouge">\N</code>, and that’s a special value from IMDb when they want to represent values that are missing. So we can filter out those values and convert the <code class="language-plaintext highlighter-rouge">startYear</code> to an integer to filter for shows after 1970:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="c1"># If year not missing (We need to escape the backslash too)
</span><span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\\</span><span class="s">N"</span><span class="p">:</span>

    <span class="c1"># If since 1970
</span>    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">1970</span><span class="p">:</span>

        <span class="c1"># Write row
</span>        <span class="n">writer</span><span class="p">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s">"tconst"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"primaryTitle"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"genres"</span><span class="p">]])</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">We can write a program to search for a particular title:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">csv</span>

<span class="c1"># Prompt user for title
</span><span class="n">title</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Title: "</span><span class="p">)</span>

<span class="c1"># Open CSV file
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"shows2.csv"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>

    <span class="c1"># Create DictReader
</span>    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">DictReader</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="c1"># Iterate over CSV file
</span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>

        <span class="c1"># Search for title
</span>        <span class="k">if</span> <span class="n">title</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s">"primaryTitle"</span><span class="p">].</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">"primaryTitle"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"genres"</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s">" | "</span><span class="p">)</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We can run this program and see our results, but we can see how SQL can do a better job.</li>
    </ul>
  </li>
  <li data-marker="*">In Python, we can connect to a SQL database and read our file into it once, so we can make lots of queries without writing new programs and without having to read the entire file each time.</li>
  <li data-marker="*">Let’s do this more easily with the CS50 library:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cs50</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="c1"># Create database by opening and closing an empty file first
</span><span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s">"shows3.db"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">).</span><span class="n">close</span><span class="p">()</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">cs50</span><span class="p">.</span><span class="n">SQL</span><span class="p">(</span><span class="s">"sqlite:///shows3.db"</span><span class="p">)</span>

<span class="c1"># Create table called `shows`, and specify the columns we want,
# all of which will be text except `startYear`
</span><span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE TABLE shows (tconst TEXT, primaryTitle TEXT, startYear NUMERIC, genres TEXT)"</span><span class="p">)</span>

<span class="c1"># Open TSV file
# https://datasets.imdbws.com/title.basics.tsv.gz
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"title.basics.tsv"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">titles</span><span class="p">:</span>

    <span class="c1"># Create DictReader
</span>    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">titles</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Iterate over TSV file
</span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>

        <span class="c1"># If non-adult TV show
</span>        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"titleType"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"tvSeries"</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s">"isAdult"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">:</span>

            <span class="c1"># If year not missing
</span>            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\\</span><span class="s">N"</span><span class="p">:</span>

                <span class="c1"># If since 1970
</span>                <span class="n">startYear</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">startYear</span> <span class="o">&gt;=</span> <span class="mi">1970</span><span class="p">:</span>

                    <span class="c1"># Insert show by substituting values into each ? placeholder
</span>                    <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO shows (tconst, primaryTitle, startYear, genres) VALUES(?, ?, ?, ?)"</span><span class="p">,</span>
                               <span class="n">row</span><span class="p">[</span><span class="s">"tconst"</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s">"primaryTitle"</span><span class="p">],</span> <span class="n">startYear</span><span class="p">,</span> <span class="n">genres</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">Now we can run <code class="language-plaintext highlighter-rouge">sqlite3 shows3.db</code> and run commands like before, such as <code class="language-plaintext highlighter-rouge">SELECT * FROM shows LIMIT 10;</code>.</li>
  <li data-marker="*">With <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) FROM shows;</code> we can see that there are more than 150,000 shows in our table, and with <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) FROM shows WHERE startYear = 2019;</code>, we see that there were more than 6000 this year.</li>
</ul>

<h2 id="multiple-tables">Multiple tables</h2>

<ul>
  <li data-marker="*">But each of the rows will only have one column for genres, and the values are multiple genres put together. So we can go back to our import program, and add another table:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cs50</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="c1"># Create database
</span><span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s">"shows4.db"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">).</span><span class="n">close</span><span class="p">()</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">cs50</span><span class="p">.</span><span class="n">SQL</span><span class="p">(</span><span class="s">"sqlite:///shows4.db"</span><span class="p">)</span>

<span class="c1"># Create tables
</span><span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE TABLE shows (id INT, title TEXT, year NUMERIC, PRIMARY KEY(id))"</span><span class="p">)</span>

<span class="c1"># The `genres` table will have a column called `show_id` that references
# the `shows` table above
</span><span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE TABLE genres (show_id INT, genre TEXT, FOREIGN KEY(show_id) REFERENCES shows(id))"</span><span class="p">)</span>

<span class="c1"># Open TSV file
# https://datasets.imdbws.com/title.basics.tsv.gz
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"title.basics.tsv"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">titles</span><span class="p">:</span>

    <span class="c1"># Create DictReader
</span>    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">titles</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Iterate over TSV file
</span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>

        <span class="c1"># If non-adult TV show
</span>        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"titleType"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"tvSeries"</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s">"isAdult"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">:</span>

            <span class="c1"># If year not missing
</span>            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\\</span><span class="s">N"</span><span class="p">:</span>

                <span class="c1"># If since 1970
</span>                <span class="n">startYear</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">"startYear"</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">startYear</span> <span class="o">&gt;=</span> <span class="mi">1970</span><span class="p">:</span>

                    <span class="c1"># Trim prefix from tconst
</span>                    <span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">"tconst"</span><span class="p">][</span><span class="mi">2</span><span class="p">:])</span>

                    <span class="c1"># Insert show
</span>                    <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO shows (id, title, year) VALUES(?, ?, ?)"</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s">"primaryTitle"</span><span class="p">],</span> <span class="n">startYear</span><span class="p">)</span>

                    <span class="c1"># Insert genres
</span>                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">"genres"</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"</span><span class="se">\\</span><span class="s">N"</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">genre</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s">"genres"</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">):</span>
                            <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO genres (show_id, genre) VALUES(?, ?)"</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">genre</span><span class="p">)</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">So now our <code class="language-plaintext highlighter-rouge">shows</code> table no longer has a <code class="language-plaintext highlighter-rouge">genres</code> column, but instead we have a <code class="language-plaintext highlighter-rouge">genres</code> table with each row representing a show and an associated genre. Now, a particular show can have multiple genres we can search for, and we can get other data about the show from the <code class="language-plaintext highlighter-rouge">shows</code> table given its ID.</li>
    </ul>
  </li>
  <li data-marker="*">In fact, we can combine both tables with <code class="language-plaintext highlighter-rouge">SELECT * FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") AND year = 2019;</code>. We’re filtering our <code class="language-plaintext highlighter-rouge">shows</code> table by IDs where the ID in the <code class="language-plaintext highlighter-rouge">genres</code> table has a value of “Comedy” for the <code class="language-plaintext highlighter-rouge">genre</code> column, and has the value of 2019 for the <code class="language-plaintext highlighter-rouge">year</code> column.</li>
  <li data-marker="*">Our tables look like this:<br>
<img src="shows_table_genres_table.png" alt="table labeled shows with entries id, title, and year, and table labeled genres with show_id and genre and arrow from show_id to id">
    <ul>
      <li data-marker="*">Since the ID in the <code class="language-plaintext highlighter-rouge">genre</code> table come from the <code class="language-plaintext highlighter-rouge">shows</code> table, we call it <code class="language-plaintext highlighter-rouge">show_id</code>. And the arrow indicates that a single show ID might have many matching rows in the <code class="language-plaintext highlighter-rouge">genres</code> table.</li>
    </ul>
  </li>
  <li data-marker="*">We see that some datasets from IMDb, like <code class="language-plaintext highlighter-rouge">title.principals.tsv</code>, have only IDs for certain columns that we’ll have to look up in other tables.</li>
  <li data-marker="*">By reading the descriptions for each table, we can see that all of the data can be used to construct these tables:<br>
<img src="imdb_tables.png" alt="table labeled people, shows, genres, ratings, stars, writers with arrows indicating IDs between tables">
    <ul>
      <li data-marker="*">Notice that, for example, a person’s name could also be copied to the <code class="language-plaintext highlighter-rouge">stars</code> or <code class="language-plaintext highlighter-rouge">writers</code> tables, but instead only the <code class="language-plaintext highlighter-rouge">person_id</code> is used to link to the data in the <code class="language-plaintext highlighter-rouge">people</code> table. This way, we only need to update the name in one place if we need to make a change.</li>
    </ul>
  </li>
  <li data-marker="*">We’ll open a database, <code class="language-plaintext highlighter-rouge">shows.db</code>, with these tables to look at some more examples.</li>
  <li data-marker="*">We’ll download a program called <a href="https://sqlitebrowser.org/dl/">DB Browser for SQLite</a>, which will have a graphical user interface to browse our tables and data. We can use the “Execute SQL” tab to run SQL directly in the program, too.</li>
  <li data-marker="*">We can run <code class="language-plaintext highlighter-rouge">SELECT * FROM shows JOIN genres ON show.id = genres.show_id;</code> to join two tables by matching IDs in columns we specify. Then we’ll get back a wider table, with columns from each of those two tables.</li>
  <li data-marker="*">We can take a person’s ID and find them in shows with <code class="language-plaintext highlighter-rouge">SELECT * FROM stars WHERE person_id = 1122;</code>, but we can do a query inside our query with <code class="language-plaintext highlighter-rouge">SELECT show_id FROM stars WHERE person_id = (SELECT id FROM people WHERE name = "Ellen DeGeneres");</code>.</li>
  <li data-marker="*">This gives us back the <code class="language-plaintext highlighter-rouge">show_id</code>, so to get the show data we can run: <code class="language-plaintext highlighter-rouge">SELECT * FROM shows WHERE id IN (...);</code> with <code class="language-plaintext highlighter-rouge">...</code> being the query above.</li>
  <li data-marker="*">We can get the same results with:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT title FROM
people JOIN stars ON people.id = stars.person_id JOIN
shows ON stars.show_id = shows.id
WHERE name = "Ellen DeGeneres"
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We join the <code class="language-plaintext highlighter-rouge">people</code> table with the <code class="language-plaintext highlighter-rouge">stars</code> table, and then with the <code class="language-plaintext highlighter-rouge">shows</code> table by specifying columns that should match between the tables, and then selecting just the <code class="language-plaintext highlighter-rouge">title</code> with a filter on the name.</li>
      <li data-marker="*">But now we can select other fields from our combined tables, too.</li>
    </ul>
  </li>
  <li data-marker="*">It turns out that we can specify columns of our tables to be special types, such as:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">PRIMARY KEY</code>, used as the primary identifier for a row</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">FOREIGN KEY</code>, which points to a row in another table</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">UNIQUE</code>, which means it has to be unique in this table</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">INDEX</code>, which asks our database to create a index to more quickly query based on this column. An index is a data structure like a tree, which helps us search for values.</li>
    </ul>
  </li>
  <li data-marker="*">We can create an index with <code class="language-plaintext highlighter-rouge">CREATE INDEX person_index ON stars (person_id);</code>. Then the <code class="language-plaintext highlighter-rouge">person_id</code> column will have an index called <code class="language-plaintext highlighter-rouge">person_index</code>. With the right indexes, our join query is several hundred times faster.</li>
</ul>

<h2 id="problems">Problems</h2>

<ul>
  <li data-marker="*">One problem with databases is <strong>race conditions</strong>, where the timing of two actions or events cause unexpected behavior.</li>
  <li data-marker="*">For example, consider two roommates and a shared fridge in their dorm. The first roommate comes home, and sees that there is no milk in the fridge. So the first roommate leaves to the store to buy milk, and while they are at the store, the second roommate comes home, sees that there is no milk, and leaves for another store to get milk. Later, there will be two jugs of milk in the fridge. By leaving a note, we can solve this problem. We can even lock the fridge so that our roommate can’t check whether there is milk, until we’ve gotten back.</li>
  <li data-marker="*">This can happen in our database if we have something like this:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rows = db.execute("SELECT likes FROM posts WHERE id=?", id);
likes = rows[0]["likes"]
db.execute("UPDATE posts SET likes = ?", likes + 1);
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">First, we’re getting the number of likes on a post with a given ID. Then, we set the number of likes to that number plus one.</li>
      <li data-marker="*">But now if we have two different web servers both trying to add a like, they might both set it to the same value instead of actually adding one each time. For example, if there are 2 likes, both servers will check the number of likes, see that there are 2, and set the value to 3. One of the likes will then be lost.</li>
    </ul>
  </li>
  <li data-marker="*">To solve this, we can use transactions, where a set of actions is guaranteed to happen together.</li>
  <li data-marker="*">Another problem in SQL is called a <strong>SQL injection attack</strong>, where an adversary can execute their own commands on our database.</li>
  <li data-marker="*">For example, someone might try type in <code class="language-plaintext highlighter-rouge">malan@harvard.edu'--</code> as their email. If we have a SQL query that’s a formatted string (without escaping, or substituting dangerous characters from, the input), such as <code class="language-plaintext highlighter-rouge">f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"</code>, then the query will end up being <code class="language-plaintext highlighter-rouge">f"SELECT * FROM users WHERE username = 'malan@harvard.edu'--' AND password = '{password}'"</code>, which will actually select the row where <code class="language-plaintext highlighter-rouge">username = 'malan@harvard.edu'</code> and turn the rest of the line into a comment. To prevent this, we should use <code class="language-plaintext highlighter-rouge">?</code> placeholders for our SQL library to automatically escape inputs from the user.</li>
</ul>


{% endblock %}

