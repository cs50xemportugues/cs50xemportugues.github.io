{% extends 'layout.html' %}


{% block conteudo %}

<h1 class="no_toc" id="lecture-4">Lecture 4</h1>

<ul id="markdown-toc">
  <li><a href="#hexadecimal" id="markdown-toc-hexadecimal">Hexadecimal</a></li>
  <li><a href="#pointers" id="markdown-toc-pointers">Pointers</a></li>
  <li><a href="#string" id="markdown-toc-string">string</a></li>
  <li><a href="#compare-and-copy" id="markdown-toc-compare-and-copy">Compare and copy</a></li>
  <li><a href="#valgrind" id="markdown-toc-valgrind">valgrind</a></li>
  <li><a href="#swap" id="markdown-toc-swap">Swap</a></li>
  <li><a href="#memory-layout" id="markdown-toc-memory-layout">Memory layout</a></li>
  <li><a href="#get_int" id="markdown-toc-get_int">get_int</a></li>
  <li><a href="#files" id="markdown-toc-files">Files</a></li>
  <li><a href="#jpeg" id="markdown-toc-jpeg">JPEG</a></li>
</ul>

<h2 id="hexadecimal">Hexadecimal</h2>

<ul>
  <li data-marker="*">In week 0, we learned binary, a counting system with 0s and 1s.</li>
  <li data-marker="*">In week 2, we talked about memory and how each byte has an address, or identifier, so we can refer to where our variables are actually stored.</li>
  <li data-marker="*">It turns out that, by convention, the addresses for memory use the counting system <strong>hexadecimal</strong>, where there are 16 digits, 0-9 and A-F.</li>
  <li data-marker="*">Recall that, in binary, each digit stood for a power of 2:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>128 64 32 16  8  4  2  1
  1  1  1  1  1  1  1  1
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">With 8 bits, we can count up to 255.</li>
    </ul>
  </li>
  <li data-marker="*">It turns out that, in hexadecimal, we can perfectly count up to 8 binary bits with just 2 digits:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>16^1 16^0
   F    F
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Here, the <code class="language-plaintext highlighter-rouge">F</code> is a value of 15 in decimal, and each place is a power of 16, so the first <code class="language-plaintext highlighter-rouge">F</code> is 16^1 * 15 = 240, plus the second <code class="language-plaintext highlighter-rouge">F</code> with the value of 16^0 * 15 = 15, for a total of 255.</li>
    </ul>
  </li>
  <li data-marker="*">And <code class="language-plaintext highlighter-rouge">0A</code> is the same as 10 in decimal, and <code class="language-plaintext highlighter-rouge">0F</code> the same as 15. <code class="language-plaintext highlighter-rouge">10</code> in hexadecimal would be 16, and we would say it as “one zero in hexadecimal” instead of “ten”, if we wanted to avoid confusion.</li>
  <li data-marker="*">The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, <code class="language-plaintext highlighter-rouge">000000</code> in hexadecimal means 0 of each red, green, and blue, for a color of black. And <code class="language-plaintext highlighter-rouge">FF0000</code> would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors.</li>
  <li data-marker="*">In writing, we can also indicate a value is in hexadecimal by prefixing it with <code class="language-plaintext highlighter-rouge">0x</code>, as in <code class="language-plaintext highlighter-rouge">0x10</code>, where the value is equal to 16 in decimal, as opposed to 10.</li>
</ul>

<h2 id="pointers">Pointers</h2>

<ul>
  <li data-marker="*">We might create a value <code class="language-plaintext highlighter-rouge">n</code>, and print it out:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">In our computer’s memory, there are now 4 bytes somewhere that have the binary value of 50, labeled <code class="language-plaintext highlighter-rouge">n</code>:<br>
<img src="n.png" alt="grid representing bytes, with four boxes together containing 50 with small n underneath"></li>
  <li data-marker="*">It turns out that, with the billions of bytes in memory, those bytes for the variable <code class="language-plaintext highlighter-rouge">n</code> starts at some unique address that might look like <code class="language-plaintext highlighter-rouge">0x12345678</code>.</li>
  <li data-marker="*">In C, we can actually see the address with the <code class="language-plaintext highlighter-rouge">&amp;</code> operator, which means “get the address of this variable”:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">And in the CS50 IDE, we might see an address like <code class="language-plaintext highlighter-rouge">0x7ffe00b3adbc</code>, where this is a specific location in the server’s memory.</li>
    </ul>
  </li>
  <li data-marker="*">The address of a variable is called a <strong>pointer</strong>, which we can think of as a value that “points” to a location in memory. The <code class="language-plaintext highlighter-rouge">*</code> operator lets us “go to” the location that a pointer is pointing to.</li>
  <li data-marker="*">For example, we can print <code class="language-plaintext highlighter-rouge">*&amp;n</code>, where we “go to” the address of <code class="language-plaintext highlighter-rouge">n</code>, and that will print out the value of <code class="language-plaintext highlighter-rouge">n</code>, <code class="language-plaintext highlighter-rouge">50</code>, since that’s the value at the address of <code class="language-plaintext highlighter-rouge">n</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">We also have to use the <code class="language-plaintext highlighter-rouge">*</code> operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Here, we use <code class="language-plaintext highlighter-rouge">int *p</code> to declare a variable, <code class="language-plaintext highlighter-rouge">p</code>, that has the type of <code class="language-plaintext highlighter-rouge">*</code>, a pointer, to a value of type <code class="language-plaintext highlighter-rouge">int</code>, an integer. Then, we can print its value (something like <code class="language-plaintext highlighter-rouge">0x12345678</code>), or print the value at its location with <code class="language-plaintext highlighter-rouge">printf("%i\n", *p);</code>.</li>
    </ul>
  </li>
  <li data-marker="*">In our computer’s memory, the variables might look like this:<br>
<img src="p.png" alt="grid representing bytes, with four boxes together containing 50 with small 0x12345678 underneath, and eight boxes together containing 0x12345678 with small p underneath">
    <ul>
      <li data-marker="*">We have a pointer, <code class="language-plaintext highlighter-rouge">p</code>, with the address of some variable.</li>
    </ul>
  </li>
  <li data-marker="*">We can abstract away the actual value of the addresses now, since they’ll be different as we declare variables in our programs, and simply think of <code class="language-plaintext highlighter-rouge">p</code> as “pointing at” some value:<br>
<img src="pointing.png" alt="one box containing p pointing at smaller box containing 50"></li>
  <li data-marker="*">Let’s say we have a mailbox labeled “123”, with the number “50” inside it. The mailbox would be <code class="language-plaintext highlighter-rouge">int n</code>, since it stores an integer. We might have another mailbox with the address “456”, inside of which is the value “123”, which is the address of our other mailbox. This would be <code class="language-plaintext highlighter-rouge">int *p</code>, since it’s a pointer to an integer.</li>
  <li data-marker="*">With the ability to use pointers, we can create different data structures, or different ways to organize data in memory that we’ll see next week.</li>
  <li data-marker="*">Many modern computer systems are “64-bit”, meaning that they use 64 bits to address memory, so a pointer will be 8 bytes, twice as big as an integer of 4 bytes.</li>
</ul>

<h2 id="string">string</h2>

<ul>
  <li data-marker="*">We might have a variable <code class="language-plaintext highlighter-rouge">string s</code> for a name like <code class="language-plaintext highlighter-rouge">EMMA</code>, and be able to access each character with <code class="language-plaintext highlighter-rouge">s[0]</code> and so on:<br>
<img src="s_array.png" alt="boxes side by side, containing: E labeled s[0], M labeled s[1], M labeled s[2], A labeled s[3], \0 labeled s[4]"></li>
  <li data-marker="*">But it turns out that each character is stored in memory at a byte with some address, and <code class="language-plaintext highlighter-rouge">s</code> is actually just a pointer with the address of the first character:<br>
<img src="s_pointer.png" alt="box containing 0x123 labeled s, boxes side by side containing E labeled 0x123, M labeled 0x124, M labeled 0x125, A labeled 0x126, \0 labeled 0x127"></li>
  <li data-marker="*">And since <code class="language-plaintext highlighter-rouge">s</code> is just a pointer to the beginning, only the <code class="language-plaintext highlighter-rouge">\0</code> indicates the end of the string.</li>
  <li data-marker="*">In fact, the CS50 Library defines a <code class="language-plaintext highlighter-rouge">string</code> with <code class="language-plaintext highlighter-rouge">typedef char *string</code>, which just says that we want to name a new type, <code class="language-plaintext highlighter-rouge">string</code>, as a <code class="language-plaintext highlighter-rouge">char *</code>, or a pointer to a character.</li>
  <li data-marker="*">Let’s print out a string:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"EMMA"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">This is familiar, but we can just say:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"EMMA"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">This will also print <code class="language-plaintext highlighter-rouge">EMMA</code>.</li>
    </ul>
  </li>
  <li data-marker="*">With <code class="language-plaintext highlighter-rouge">printf("%p\n", s);</code>, we can print <code class="language-plaintext highlighter-rouge">s</code> as its value as a pointer, like <code class="language-plaintext highlighter-rouge">0x42ab52</code>. (<code class="language-plaintext highlighter-rouge">printf</code> knows to go to the address and print the entire string when we use <code class="language-plaintext highlighter-rouge">%s</code> and pass in <code class="language-plaintext highlighter-rouge">s</code>, even though <code class="language-plaintext highlighter-rouge">s</code> only points to the first character.)</li>
  <li data-marker="*">We can also try <code class="language-plaintext highlighter-rouge">printf("%p\n", &amp;s[0]);</code>, which is the address of the first character of <code class="language-plaintext highlighter-rouge">s</code>, and it’s exactly the same as printing <code class="language-plaintext highlighter-rouge">s</code>. And printing <code class="language-plaintext highlighter-rouge">&amp;s[1]</code>, <code class="language-plaintext highlighter-rouge">&amp;s[2]</code>, and <code class="language-plaintext highlighter-rouge">&amp;s[3]</code> gets us the addresses that are the next characters in memory after <code class="language-plaintext highlighter-rouge">&amp;s[0]</code>, like <code class="language-plaintext highlighter-rouge">0x42ab53</code>, <code class="language-plaintext highlighter-rouge">0x42ab54</code>, and <code class="language-plaintext highlighter-rouge">0x42ab55</code>, exactly one byte after another.</li>
  <li data-marker="*">And finally, if we try to <code class="language-plaintext highlighter-rouge">printf("%c\n", *s);</code>, we get a single character <code class="language-plaintext highlighter-rouge">E</code>, since we’re going to the address contained in <code class="language-plaintext highlighter-rouge">s</code>, which has the first character in the string.</li>
  <li data-marker="*">In fact, <code class="language-plaintext highlighter-rouge">s[0]</code>, <code class="language-plaintext highlighter-rouge">s[1]</code>, and <code class="language-plaintext highlighter-rouge">s[2]</code> actually map directly to <code class="language-plaintext highlighter-rouge">*s</code>, <code class="language-plaintext highlighter-rouge">*(s+1)</code>, and <code class="language-plaintext highlighter-rouge">*(s+2)</code>, since each of the next characters are just at the address of the next byte.</li>
</ul>

<h2 id="compare-and-copy">Compare and copy</h2>

<ul>
  <li data-marker="*">Let’s look at <code class="language-plaintext highlighter-rouge">compare0</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get two integers</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"i: "</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"j: "</span><span class="p">);</span>

    <span class="c1">// Compare integers</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Same</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Different</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We can compile and run this, and our program works as we’d expect, with the same values of the two integers giving us “Same” and different values “Different”.</li>
    </ul>
  </li>
  <li data-marker="*">In <code class="language-plaintext highlighter-rouge">compare1</code>, we see that the same string values are causing our program to print “Different”:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get two strings</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"t: "</span><span class="p">);</span>

    <span class="c1">// Compare strings' addresses</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Same</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Different</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Given what we now know about strings, this makes sense because each “string” variable is pointing to a different location in memory, where the first character of each string is stored. So even if the values of the strings are the same, this will always print “Different”.</li>
      <li data-marker="*">For example, our first string might be at address 0x123, our second might be at 0x456, and <code class="language-plaintext highlighter-rouge">s</code> will be <code class="language-plaintext highlighter-rouge">0x123</code> and <code class="language-plaintext highlighter-rouge">t</code> will be <code class="language-plaintext highlighter-rouge">0x456</code>, so those values will be different.</li>
      <li data-marker="*">And <code class="language-plaintext highlighter-rouge">get_string</code>, this whole time, has been returning just a <code class="language-plaintext highlighter-rouge">char *</code>, or a pointer to the first character of a string from the user.</li>
    </ul>
  </li>
  <li data-marker="*">Now let’s try to copy a string:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>

    <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// Print string twice</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"t: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We get a string <code class="language-plaintext highlighter-rouge">s</code>, and copy the value of <code class="language-plaintext highlighter-rouge">s</code> into <code class="language-plaintext highlighter-rouge">t</code>. Then, we capitalize the first letter in <code class="language-plaintext highlighter-rouge">t</code>.</li>
      <li data-marker="*">But when we run our program, we see that both <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> are now capitalized.</li>
      <li data-marker="*">Since we set <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code> to the same values, they’re actually pointers to the same character, and so we capitalized the same character!</li>
    </ul>
  </li>
  <li data-marker="*">To actually make a copy of a string, we have to do a little more work:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"t: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We create a new variable, <code class="language-plaintext highlighter-rouge">t</code>, of the type <code class="language-plaintext highlighter-rouge">char *</code>, with <code class="language-plaintext highlighter-rouge">char *t</code>. Now, we want to point it to a new chunk of memory that’s large enough to store the copy of the string. With <code class="language-plaintext highlighter-rouge">malloc</code>, we can allocate some number of bytes in memory (that aren’t already used to store other values), and we pass in the number of bytes we’d like. We already know the length of <code class="language-plaintext highlighter-rouge">s</code>, so we add 1 to that for the terminating null character. So, our final line of code is <code class="language-plaintext highlighter-rouge">char *t = malloc(strlen(s) + 1);</code>.</li>
      <li data-marker="*">Then, we copy each character, one at a time, and now we can capitalize just the first letter of <code class="language-plaintext highlighter-rouge">t</code>. And we use <code class="language-plaintext highlighter-rouge">i &lt; n + 1</code>, since we actually want to go up to <code class="language-plaintext highlighter-rouge">n</code>, to ensure we copy the terminating character in the string.</li>
      <li data-marker="*">We can actually also use the <code class="language-plaintext highlighter-rouge">strcpy</code> library function with <code class="language-plaintext highlighter-rouge">strcpy(t, s)</code> instead of our loop, to copy the string <code class="language-plaintext highlighter-rouge">s</code> into <code class="language-plaintext highlighter-rouge">t</code>. To be clear, the concept of a “string” is from the C language and well-supported; the only training wheels from CS50 are the type <code class="language-plaintext highlighter-rouge">string</code> instead of <code class="language-plaintext highlighter-rouge">char *</code>, and the <code class="language-plaintext highlighter-rouge">get_string</code> function.</li>
    </ul>
  </li>
  <li data-marker="*">If we didn’t copy the null terminating character, <code class="language-plaintext highlighter-rouge">\0</code>, and tried to print out our string <code class="language-plaintext highlighter-rouge">t</code>, <code class="language-plaintext highlighter-rouge">printf</code> will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a <code class="language-plaintext highlighter-rouge">\0</code>, or crashes entirely, since our program might end up trying to read memory that doesn’t belong to it!</li>
</ul>

<h2 id="valgrind">valgrind</h2>

<ul>
  <li data-marker="*">It turns out that, after we’re done with memory that we’ve allocated with <code class="language-plaintext highlighter-rouge">malloc</code>, we should call <code class="language-plaintext highlighter-rouge">free</code> (as in <code class="language-plaintext highlighter-rouge">free(t)</code>), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again.</li>
  <li data-marker="*">If we kept running our program and allocating memory with <code class="language-plaintext highlighter-rouge">malloc</code>, but never freed the memory after we were done using it, we would have a <strong>memory leak</strong>, which will slow down our computer and use up more and more memory until our computer runs out.</li>
  <li data-marker="*"><code class="language-plaintext highlighter-rouge">valgrind</code> is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with <code class="language-plaintext highlighter-rouge">help50 valgrind ./copy</code> and see, from the error message, that line 10, we allocated memory that we never freed (or “lost”).</li>
  <li data-marker="*">So at the end, we can add a line <code class="language-plaintext highlighter-rouge">free(t)</code>, which won’t change how our program runs, but no errors from valgrind.</li>
  <li data-marker="*">Let’s take a look at <code class="language-plaintext highlighter-rouge">memory.c</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare</span>

<span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">This is an example from valgrind’s documentation (valgrind is a real tool, while help50 was written specifically to help us in this course).</li>
      <li data-marker="*">The function <code class="language-plaintext highlighter-rouge">f</code> allocates enough memory for 10 integers, and stores the address in a pointer called <code class="language-plaintext highlighter-rouge">x</code>. Then we try to set the 11th value of <code class="language-plaintext highlighter-rouge">x</code> with <code class="language-plaintext highlighter-rouge">x[10]</code> to <code class="language-plaintext highlighter-rouge">0</code>, which goes past the array of memory we’ve allocated for our program. This is called <strong>buffer overflow</strong>, where we go past the boundaries of our buffer, or array, and into unknown memory.</li>
    </ul>
  </li>
  <li data-marker="*">valgrind will also tell us there’s an “Invalid write of size 4” for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes).</li>
  <li data-marker="*">And this whole time, the CS50 Library has been freeing memory it’s allocated in <code class="language-plaintext highlighter-rouge">get_string</code>, when our program finishes!</li>
</ul>

<h2 id="swap">Swap</h2>

<ul>
  <li data-marker="*">We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can’t do that without a third cup to pour one of the drink into first.</li>
  <li data-marker="*">Now, let’s say we wanted to swap the values of two integers.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">With a third variable to use as temporary storage space, we can do this pretty easily, by putting <code class="language-plaintext highlighter-rouge">a</code> into <code class="language-plaintext highlighter-rouge">tmp</code>, and then <code class="language-plaintext highlighter-rouge">b</code> to <code class="language-plaintext highlighter-rouge">a</code>, and finally the original value of <code class="language-plaintext highlighter-rouge">a</code>, now in <code class="language-plaintext highlighter-rouge">tmp</code>, into <code class="language-plaintext highlighter-rouge">b</code>.</li>
    </ul>
  </li>
  <li data-marker="*">But, if we tried to use that function in a program, we don’t see any changes:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">It turns out that the <code class="language-plaintext highlighter-rouge">swap</code> function gets its own variables, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> when they are passed in, that are copies of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, and so changing those values don’t change <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in the <code class="language-plaintext highlighter-rouge">main</code> function.</li>
    </ul>
  </li>
</ul>

<h2 id="memory-layout">Memory layout</h2>

<ul>
  <li data-marker="*">Within our computer’s memory, the different types of data that need to be stored for our program are organized into different sections:<br>
<img src="memory_layout.png" alt="Grid with sections, from top to bottom: machine code, globals, heap (with arrow pointing downward), stack (with arrow pointing upward)">
    <ul>
      <li data-marker="*">The <em>machine code</em> section is our compiled program’s binary code. When we run our program, that code is loaded into the “top” of memory.</li>
      <li data-marker="*"><em>Globals</em> are global variables we declare in our program or other shared variables that our entire program can access.</li>
      <li data-marker="*">The <em>heap</em> section is an empty area where <code class="language-plaintext highlighter-rouge">malloc</code> can get free memory from, for our program to use.</li>
      <li data-marker="*">The <em>stack</em> section is used by functions in our program as they are called. For example, our <code class="language-plaintext highlighter-rouge">main</code> function is at the very bottom of the stack, and has the local variables <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. The <code class="language-plaintext highlighter-rouge">swap</code> function, when it’s called, has its own frame, or slice, of memory that’s on top of <code class="language-plaintext highlighter-rouge">main</code>’s, with the local variables <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">tmp</code>:<br>
<img src="stack.png" alt="Stack section with (a, b, tmp) above (x, y)">
        <ul>
          <li data-marker="*">Once the function <code class="language-plaintext highlighter-rouge">swap</code> returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called <code class="language-plaintext highlighter-rouge">swap</code>.</li>
          <li data-marker="*">So by passing in the addresses of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> from <code class="language-plaintext highlighter-rouge">main</code> to <code class="language-plaintext highlighter-rouge">swap</code>, we can actually change the values of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>:
<img src="pointers.png" alt="Stack section with (a, b, tmp) above (x, y), and a pointing to x and b pointing to y"></li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*">By passing in the address of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, our <code class="language-plaintext highlighter-rouge">swap</code> function can actually work:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">The addresses of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are passed in from <code class="language-plaintext highlighter-rouge">main</code> to <code class="language-plaintext highlighter-rouge">swap</code>, and we use the <code class="language-plaintext highlighter-rouge">int *a</code> syntax to declare that our <code class="language-plaintext highlighter-rouge">swap</code> function takes in pointers. We save the value of <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">tmp</code> by following the pointer <code class="language-plaintext highlighter-rouge">a</code>, and then take the value of <code class="language-plaintext highlighter-rouge">y</code> by following the pointer <code class="language-plaintext highlighter-rouge">b</code>, and store that to the location <code class="language-plaintext highlighter-rouge">a</code> is pointing to (<code class="language-plaintext highlighter-rouge">x</code>). Finally, we store the value of <code class="language-plaintext highlighter-rouge">tmp</code> to the location pointed to by <code class="language-plaintext highlighter-rouge">b</code> (<code class="language-plaintext highlighter-rouge">y</code>), and we’re done.</li>
    </ul>
  </li>
  <li data-marker="*">If we call <code class="language-plaintext highlighter-rouge">malloc</code> too many times, we will have a <strong>heap overflow</strong>, where we end up going past our heap. Or, if we have too many functions being called, we will have a <strong>stack overflow</strong>, where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash.</li>
</ul>

<h2 id="get_int">get_int</h2>

<ul>
  <li data-marker="*">We can implement <code class="language-plaintext highlighter-rouge">get_int</code> ourselves with a C library function, <code class="language-plaintext highlighter-rouge">scanf</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x: "</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x: %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">scanf</code> takes a format, <code class="language-plaintext highlighter-rouge">%i</code>, so the input is “scanned” for that format, and the address in memory where we want that input to go. But <code class="language-plaintext highlighter-rouge">scanf</code> doesn’t have much error checking, so we might not get an integer.</li>
    </ul>
  </li>
  <li data-marker="*">We can try to get a string the same way:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">But we haven’t actually allocated any memory for <code class="language-plaintext highlighter-rouge">s</code> (<code class="language-plaintext highlighter-rouge">s</code> is <code class="language-plaintext highlighter-rouge">NULL</code>, or not pointing to anything), so we might want to call <code class="language-plaintext highlighter-rouge">char s[5]</code> to allocate an array of 5 characters for our string. Then, <code class="language-plaintext highlighter-rouge">s</code> will be treated as a pointer in <code class="language-plaintext highlighter-rouge">scanf</code> and <code class="language-plaintext highlighter-rouge">printf</code>.</li>
      <li data-marker="*">Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, <code class="language-plaintext highlighter-rouge">scanf</code> might be trying to write past the end of our array into unknown memory, causing our program to crash.</li>
    </ul>
  </li>
</ul>

<h2 id="files">Files</h2>

<ul>
  <li data-marker="*">With the ability to use pointers, we can also open files:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Open file</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"phonebook.csv"</span><span class="p">,</span> <span class="s">"a"</span><span class="p">);</span>

    <span class="c1">// Get strings from user</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"Name: "</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">number</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">);</span>

    <span class="c1">// Print (write) strings to file</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"%s,%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>

    <span class="c1">// Close file</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">fopen</code> is a new function we can use to open a file. It will return a pointer to a new type, <code class="language-plaintext highlighter-rouge">FILE</code>, that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in (<code class="language-plaintext highlighter-rouge">r</code> for read, <code class="language-plaintext highlighter-rouge">w</code> for write, and <code class="language-plaintext highlighter-rouge">a</code> for append, or adding to).</li>
      <li data-marker="*">After we get some strings, we can use <code class="language-plaintext highlighter-rouge">fprintf</code> to print to a file.</li>
      <li data-marker="*">Finally, we close the file with <code class="language-plaintext highlighter-rouge">fclose</code>.</li>
    </ul>
  </li>
  <li data-marker="*">Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically.</li>
</ul>

<h1 id="jpeg">JPEG</h1>

<ul>
  <li data-marker="*">We can also write a program that opens a file and tells us if it’s a JPEG (image) file:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// Check usage</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Open file</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Read first three bytes</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Check first three bytes</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xd8</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Maybe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"No</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Close file</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Now, if we run this program with <code class="language-plaintext highlighter-rouge">./jpeg brian.jpg</code>, our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with <code class="language-plaintext highlighter-rouge">fread</code>.</li>
      <li data-marker="*">We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they’re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they’re not the same, we know it’s definitely not a JPEG file.</li>
    </ul>
  </li>
  <li data-marker="*">We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week’s problem set!</li>
</ul>


{% endblock %}

