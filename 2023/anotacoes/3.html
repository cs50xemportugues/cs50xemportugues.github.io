<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci√™ncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script src="/static/highlight/highlight.min.js"></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="/static/highlight/styles/atom-one-light.min.css"
    />
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      code {
        border: 1px solid #dee2e6;
      }

      pre {
        padding: 0 !important;
      }

      /* Don't shrink these */
      code,
      pre {
        font-size: inherit;
      }
    </style>
    <title>CS50x em Portugu√™s</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html"
        >Este √© o CS50x</a
      >
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x">O curso de Ci√™ncias da Computa√ß√£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">üò∫</strong></span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1
          <span class="semana-titulo">C</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2
          <span class="semana-titulo"
            >Vetores</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3
          <span class="semana-titulo"
            >Algoritmos</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4
          <span class="semana-titulo"
            >Mem√≥ria</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5
          <span class="semana-titulo"
            >Estruturas de Dados</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6
          <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7
          <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8
          <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9
          <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10
          <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >Ciberseguran√ßa</a
        >
      </li>
    </ul>

    <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html"
          >Projeto Final</a
        >
      </li>
    </ul>

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/manual/index.html"
          >Manual do Programador</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/estilo.html"
          >Guia de Estilo</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade Acad√™mica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          ></a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html"></a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html"
          >Curr√≠culo do Curso</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/"
          >Navegador SQLite</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/"
          >Navegador PostgreSQL</a
        >
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >Documenta√ß√£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>
    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"
        ></a
      >
    </p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Aula 3</h1>
<ul>
<li><a href="#busca">Busca</a></li>
<li><a href="#big-o">Big O</a></li>
<li><a href="#busca-linear">Busca linear</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#ordenacao">Ordena√ß√£o</a></li>
<li><a href="#selection-sort">Selection sort</a></li>
<li><a href="#recursao">Recurs√£o</a></li>
<li><a href="#merge-sort">Merge sort</a></li>
</ul>
<h2>Busca</h2>
<ul>
<li>
<p>Da √∫ltima vez, falamos sobre a mem√≥ria em um computador, ou RAM, e como nossos dados podem ser armazenados como vari√°veis individuais ou como arrays com v√°rios itens, ou elementos.</p>
</li>
<li>
<p>Podemos pensar em um array com v√°rios itens como uma fileira de arm√°rios, onde um computador s√≥ pode abrir um arm√°rio para olhar um item, de cada vez.</p>
</li>
<li>
<p>Por exemplo, se quisermos verificar se um n√∫mero est√° em um array, com um algoritmo que recebe um array como entrada e produz um booleano como resultado, poder√≠amos:</p>
<ul>
<li>
olhar em cada arm√°rio, ou em cada elemento, de cada vez, do in√≠cio ao fim.<ul>
<li>Isso √© chamado de <strong>busca linear</strong>, onde nos movemos em uma linha, j√° que nosso array n√£o est√° ordenado.</li>
</ul>
</li>
<li>
come√ßar no meio e mover para a esquerda ou direita, dependendo do que estamos procurando, se nosso array de itens estiver ordenado.<ul>
<li>Isso √© chamado de <strong>busca bin√°ria</strong>, j√° que podemos dividir nosso problema em dois a cada passo, como David fez com a lista telef√¥nica na semana 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Podemos escrever um pseudoc√≥digo para a busca linear assim:</p>
<pre><code>Para i de 0 a n‚Äì1
    Se o i-√©simo elemento for 50
        Retorna verdadeiro
Retorna falso
</code></pre>
<ul>
<li>Podemos rotular cada um dos arm√°rios, de <code>0</code> a <code>n‚Äì1</code>, e verific√°-los em ordem.</li>
</ul>
</li>
<li>
<p>Para a busca bin√°ria, nosso algoritmo pode ser assim:</p>
<pre><code>Se n√£o houver itens
    Retorna falso
Se o item do meio for 50
    Retorna verdadeiro
Sen√£o, se 50 &lt; item do meio
    Buscar na metade esquerda
Sen√£o, se 50 &gt; item do meio
    Buscar na metade direita
</code></pre>
<ul>
<li>Eventualmente, n√£o teremos mais partes do array sobrando (se o item que queremos n√£o estiver nele), ent√£o podemos retornar <code>falso</code>.</li>
<li>Caso contr√°rio, podemos procurar em cada metade, dependendo do valor do item do meio.</li>
</ul>
</li>
</ul>
<h2>Big O</h2>
<ul>
<li>Na semana 0, vimos diferentes tipos de algoritmos e seus tempos de execu√ß√£o: <img src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" alt="gr√°fico com: &quot;tamanho do problema&quot; como eixo x; &quot;tempo para resolver&quot; como eixo y; linha reta vermelha e √≠ngreme desde a origem at√© o topo do gr√°fico rotulada como &quot;n&quot;; linha reta amarela e menos √≠ngreme desde a origem at√© o topo do gr√°fico rotulada como &quot;n/2&quot;; linha curva verde que fica cada vez menos √≠ngreme desde a origem at√© a direita do gr√°fico rotulada como &quot;log_2 n&quot;" /></li>
<li>A maneira mais formal de descrever isso √© com a nota√ß√£o big <em>O</em>, que podemos pensar como &quot;na ordem de&quot;. Por exemplo, se nosso algoritmo √© a busca linear, ele levar√° aproximadamente <em>O</em>(<em>n</em>) passos, &quot;na ordem de <em>n</em>&quot;. Na verdade, at√© mesmo um algoritmo que olha dois itens de cada vez e leva <em>n</em>/2 passos tem <em>O</em>(<em>n</em>). Isso ocorre porque, √† medida que <em>n</em> fica cada vez maior, apenas o termo maior, <em>n</em>, importa.</li>
<li>Da mesma forma, um tempo de execu√ß√£o logar√≠tmico √© <em>O</em>(log <em>n</em>), n√£o importando qual seja a base, j√° que isso √© apenas uma aproxima√ß√£o do que acontece quando <em>n</em> √© muito grande.</li>
<li>
Existem alguns tempos de execu√ß√£o comuns:<ul>
<li><em>O</em>(_n_2)</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>(busca linear)</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>(busca bin√°ria)</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Os cientistas da computa√ß√£o tamb√©m podem usar o big Œ©, nota√ß√£o big Omega, que √© o limite inferior do n√∫mero de passos para nosso algoritmo. (Big <em>O</em> √© o limite superior do n√∫mero de passos, ou o pior caso, e geralmente √© o que mais nos interessa.) Com a busca linear, por exemplo, o pior caso √© <em>n</em> passos, mas o melhor caso √© 1 passo, j√° que nosso item pode acontecer de ser o primeiro item que verificamos. O melhor caso para a busca bin√°ria tamb√©m √© 1, j√° que nosso item pode estar no meio do array.</li>
<li>
E temos um conjunto similar dos tempos de execu√ß√£o mais comuns em big Œ©:<ul>
<li>Œ©(_n_2)</li>
<li>Œ©(<em>n</em> log <em>n</em>)</li>
<li>
Œ©(<em>n</em>)<ul>
<li>(contando o n√∫mero de itens)</li>
</ul>
</li>
<li>Œ©(log <em>n</em>)</li>
<li>
Œ©(1)<ul>
<li>(busca linear, busca bin√°ria)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Busca linear</h2>
<ul>
<li>
<p>Vamos dar uma olhada no <code>numbers.c</code>:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Um array de n√∫meros
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // Busca por 50
    for (int i = 0; i &lt; 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf(&quot;Encontrado\n&quot;);
            return 0;
        }
    }
    printf(&quot;N√£o encontrado\n&quot;);
    return 1;
}
</code></pre>
<ul>
<li>Aqui, inicializamos um array com alguns valores e verificamos os itens do array um por vez, em ordem.</li>
<li>E em cada caso, dependendo se o valor foi encontrado ou n√£o, podemos retornar um c√≥digo de sa√≠da de 0 (para sucesso) ou 1 (para falha).</li>
</ul>
</li>
<li>
<p>Podemos fazer o mesmo para nomes:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Um array de nomes
    string names[] = {&quot;EMMA&quot;, &quot;RODRIGO&quot;, &quot;BRIAN&quot;, &quot;DAVID&quot;};

    // Busca por EMMA
    for (int i = 0; i &lt; 4; i++)
    {
        if (strcmp(names[i], &quot;EMMA&quot;) == 0)
        {
            printf(&quot;Encontrado\n&quot;);
            return 0;
        }
    }
    printf(&quot;N√£o encontrado\n&quot;);
    return 1;
}
</code></pre>
<ul>
<li>N√£o podemos comparar strings diretamente, pois elas n√£o s√£o um tipo de dados simples, mas sim um array de muitos caracteres, e precisamos compar√°-las de forma diferente. Felizmente, a biblioteca <code>string</code> possui uma fun√ß√£o <code>strcmp</code> que compara strings para n√≥s e retorna <code>0</code> se forem iguais, ent√£o podemos us√°-la.</li>
</ul>
</li>
<li>
<p>Vamos tentar implementar uma lista telef√¥nica com as mesmas ideias:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    string names[] = {&quot;EMMA&quot;, &quot;RODRIGO&quot;, &quot;BRIAN&quot;, &quot;DAVID&quot;};
    string numbers[] = {&quot;617‚Äì555‚Äì0100&quot;, &quot;617‚Äì555‚Äì0101&quot;, &quot;617‚Äì555‚Äì0102&quot;, &quot;617‚Äì555‚Äì0103&quot;};

    for (int i = 0; i &lt; 4; i++)
    {
        if (strcmp(names[i], &quot;EMMA&quot;) == 0)
        {
            printf(&quot;Encontrado %s\n&quot;, numbers[i]);
            return 0;
        }
    }
    printf(&quot;N√£o encontrado\n&quot;);
    return 1;
}
</code></pre>
<ul>
<li>Vamos usar strings para n√∫meros de telefone, pois eles podem incluir formata√ß√£o ou ser muito longos para serem representados como n√∫meros.</li>
<li>Agora, se o nome em um certo √≠ndice no array <code>names</code> corresponder √† pessoa que estamos procurando, retornaremos o n√∫mero de telefone no array <code>numbers</code>, no mesmo √≠ndice. Mas isso significa que precisamos ter cuidado para garantir que cada n√∫mero corresponda ao nome em cada √≠ndice, especialmente se adicionarmos ou removermos nomes e n√∫meros.</li>
</ul>
</li>
</ul>
<h2>Ficheiros Markdown</h2>
<ul>
<li>
<p>Descobrimos que podemos criar os nossos pr√≥prios tipos de dados personalizados chamados de <strong>structs</strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  person;

  int main(void)
  {
      person people[4];

      people[0].name = &quot;EMMA&quot;;
      people[0].number = &quot;617‚Äì555‚Äì0100&quot;;

      people[1].name = &quot;RODRIGO&quot;;
      people[1].number = &quot;617‚Äì555‚Äì0101&quot;;

      people[2].name = &quot;BRIAN&quot;;
      people[2].number = &quot;617‚Äì555‚Äì0102&quot;;

      people[3].name = &quot;DAVID&quot;;
      people[3].number = &quot;617‚Äì555‚Äì0103&quot;;

      // Procurar por EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, &quot;EMMA&quot;) == 0)
          {
              printf(&quot;Encontrado: %s\n&quot;, people[i].number);
              return 0;
          }
      }
      printf(&quot;N√£o encontrado\n&quot;);
      return 1;
  }
</code></pre>
<ul>
<li>Podemos pensar em structs como contentores, dentro dos quais existem v√°rios outros tipos de dados.</li>
<li>Aqui, criamos o nosso pr√≥prio tipo com uma struct chamada <code>person</code>, que ter√° uma <code>string</code> chamada <code>name</code> e uma <code>string</code> chamada <code>number</code>. Ent√£o, podemos criar um array desses tipos de struct e inicializar os valores dentro de cada um deles, usando uma nova sintaxe, <code>.</code>, para acessar as propriedades de cada <code>person</code>.</li>
<li>No nosso loop, agora podemos ter mais certeza de que o <code>number</code> corresponde ao <code>name</code>, pois eles s√£o do mesmo elemento <code>person</code>.</li>
</ul>
</li>
</ul>
<h2>Ordena√ß√£o</h2>
<ul>
<li>
<p>Se a nossa entrada for uma lista n√£o ordenada de n√∫meros, existem v√°rios algoritmos que podemos usar para produzir uma lista ordenada.</p>
</li>
<li>
<p>Com oito volunt√°rios no palco com os seguintes n√∫meros, podemos considerar trocar pares de n√∫meros adjacentes como o primeiro passo.</p>
</li>
<li>
<p>Nossos volunt√°rios come√ßam na seguinte ordem aleat√≥ria:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Olhamos para os dois primeiros n√∫meros e os trocamos para que fiquem em ordem:</p>
<pre><code>  6 3 8 5 2 7 4 1
  ‚Äì ‚Äì
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>O pr√≥ximo par, <code>6</code> e <code>8</code>, j√° est√° em ordem, ent√£o n√£o precisamos troc√°-los.</p>
</li>
<li>
<p>O pr√≥ximo par, <code>8</code> e <code>5</code>, precisa ser trocado:</p>
<pre><code>  3 6 8 5 2 7 4 1
      ‚Äì ‚Äì
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Continuamos at√© chegar ao final da lista:</p>
<pre><code>  3 6 5 2 8 7 4 1
          ‚Äì ‚Äì
  3 6 5 2 7 8 4 1
            ‚Äì ‚Äì
  3 6 5 2 7 4 8 1
              ‚Äì ‚Äì
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>N√£o ordenamos ainda a nossa lista, mas estamos um pouco mais perto da solu√ß√£o, porque o maior valor, <code>8</code>, foi movido para a extrema direita.</p>
</li>
<li>
<p>Repetimos isso com mais uma passagem pela lista:</p>
<pre><code>  3 6 5 2 7 4 1 8
  ‚Äì ‚Äì
  3 6 5 2 7 4 1 8
    ‚Äì ‚Äì
  3 5 6 2 7 4 1 8
      ‚Äì ‚Äì
  3 5 2 6 7 4 1 8
        ‚Äì ‚Äì
  3 5 2 6 7 4 1 8
          ‚Äì ‚Äì
  3 5 2 6 4 7 1 8
              ‚Äì ‚Äì
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Note que n√£o precisamos trocar o 3 e o 6, ou o 6 e o 7.</li>
</ul>
</li>
<li>
<p>Agora, o pr√≥ximo maior valor, <code>7</code>, foi movido para a extrema direita. Se repetirmos isso, mais e mais da lista ficar√° ordenada e, rapidamente, teremos uma lista totalmente ordenada.</p>
</li>
<li>
<p>Esse algoritmo √© chamado de <strong>ordenamento por bolha</strong>, onde valores grandes &quot;borbulham&quot; para a direita. O pseudoc√≥digo para isso pode parecer com:</p>
<pre><code>  Repetir n‚Äì1 vezes
      Para i de 0 at√© n‚Äì2
          Se os i-√©simo e i+1-√©simo elementos estiverem fora de ordem
              Troc√°-los
</code></pre>
<ul>
<li>Como estamos comparando o i-√©simo e o i+1-√©simo elemento, s√≥ precisamos ir at√© <em>n</em> ‚Äì 2 para o <code>i</code>. Em seguida, trocamos os dois elementos se eles estiverem fora de ordem.</li>
<li>E podemos parar depois de fazermos <em>n</em> ‚Äì 1 passagens, j√° que sabemos que os <em>n</em>-1 maiores elementos ter√£o borbulhado para a direita.</li>
</ul>
</li>
<li>
<p>Temos <em>n</em> ‚Äì 2 etapas para o loop interno e <em>n</em> ‚Äì 1 loops, ent√£o obtemos um total de <em>n_2 ‚Äì 3_n</em> + 2 etapas. Mas o termo dominante √© _n_2, √† medida que <code>n</code> fica cada vez maior, ent√£o podemos dizer que o ordenamento por bolha √© <em>O</em>(_n_2).</p>
</li>
<li>
<p>J√° vimos tempos de execu√ß√£o como os seguintes e, mesmo que a busca bin√°ria seja muito mais r√°pida do que a busca linear, pode n√£o valer o custo √∫nico de ordenar a lista primeiro, a menos que fa√ßamos muitas pesquisas ao longo do tempo:</p>
<ul>
<li>
<em>O</em>(_n_2)<ul>
<li>ordenamento por bolha</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>busca linear</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>busca bin√°ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>
<p>E Œ© para o ordenamento por bolha ainda √© _n_2, j√° que ainda verificamos cada par de elementos para <em>n</em> ‚Äì 1 passagens.</p>
</li>
</ul>
<h2>Ordena√ß√£o por sele√ß√£o</h2>
<ul>
<li>
<p>Podemos adotar uma abordagem diferente com o mesmo conjunto de n√∫meros:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Primeiro, vamos analisar cada n√∫mero e lembrar o menor n√∫mero que encontramos. Em seguida, podemos troc√°-lo com o primeiro n√∫mero da nossa lista, j√° que sabemos que √© o menor:</p>
<pre><code>  6 3 8 5 2 7 4 1
  ‚Äì             ‚Äì
  1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Agora sabemos que pelo menos o primeiro elemento da nossa lista est√° no lugar certo, ent√£o podemos procurar o menor elemento entre os restantes e troc√°-lo com o pr√≥ximo elemento n√£o ordenado (agora o segundo elemento):</p>
<pre><code>  1 3 8 5 2 7 4 6
    ‚Äì     ‚Äì
  1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Podemos repetir esse processo v√°rias vezes, at√© obtermos uma lista ordenada.</p>
</li>
<li>
<p>Esse algoritmo √© chamado de <strong>ordena√ß√£o por sele√ß√£o</strong> e poder√≠amos escrever um pseudoc√≥digo assim:</p>
<pre><code>  Para i de 0 a n‚Äì1
      Encontre o item mais pequeno entre o i-√©simo item e o √∫ltimo item
      Troque o item mais pequeno pelo i-√©simo item
</code></pre>
</li>
<li>
<p>Com nota√ß√£o <em>O</em> grande, ainda temos uma complexidade de tempo de execu√ß√£o de <em>O</em>(_n_2), pois estamos olhando aproximadamente para todos os <em>n</em> elementos para encontrar o menor e fazendo <em>n</em> passagens para ordenar todos os elementos.</p>
</li>
<li>
<p>Mais formalmente, podemos usar algumas f√≥rmulas para mostrar que o maior fator √© realmente _n_2:</p>
<pre><code>  n + (n ‚Äì 1) + (n ‚Äì 2) + ... + 1
  n(n + 1)/2
  (n^2 + n)/2
  n^2/2 + n/2
  O(n^2)
</code></pre>
</li>
<li>
<p>Portanto, descobrimos que a ordena√ß√£o por sele√ß√£o √© fundamentalmente igual √† ordena√ß√£o por bolha em termos de tempo de execu√ß√£o:</p>
<ul>
<li>
<em>O</em>(_n_2)<ul>
<li>ordena√ß√£o por bolha, ordena√ß√£o por sele√ß√£o</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>busca linear</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>busca bin√°ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>
<p>O melhor caso, Œ©, tamb√©m √© _n_2.</p>
</li>
<li>
<p>Podemos voltar √† ordena√ß√£o por bolha e alterar seu algoritmo para algo assim, o que nos permitir√° parar cedo se todos os elementos estiverem ordenados:</p>
<pre><code>  Repita at√© n√£o haver trocas
      Para i de 0 a n‚Äì2
          Se o i-√©simo e o (i+1)-√©simo elementos estiverem fora de ordem
              Troque-os
</code></pre>
<ul>
<li>
Agora, s√≥ precisamos analisar cada elemento uma vez, ent√£o o melhor caso agora √© Œ©(<em>n</em>):<ul>
<li>
Œ©(_n_2)<ul>
<li>ordena√ß√£o por sele√ß√£o</li>
</ul>
</li>
<li>Œ©(<em>n</em> log <em>n</em>)</li>
<li>
Œ©(<em>n</em>)<ul>
<li>ordena√ß√£o por bolha</li>
</ul>
</li>
<li>Œ©(log <em>n</em>)</li>
<li>
Œ©(1)<ul>
<li>busca linear, busca bin√°ria</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Podemos ver uma visualiza√ß√£o online <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparando algoritmos de ordena√ß√£o</a> com anima√ß√µes que mostram como os elementos se movem dentro dos arrays tanto para a ordena√ß√£o por bolha quanto para a ordena√ß√£o por sele√ß√£o.</p>
</li>
</ul>
<h2>Recurs√£o</h2>
<ul>
<li>
<p>Lembre-se de que na semana 0, t√≠nhamos um pseudoc√≥digo para encontrar um nome em uma lista telef√¥nica, onde t√≠nhamos linhas nos dizendo para &quot;voltar&quot; e repetir algumas etapas:</p>
<pre><code>1  Pegue a lista telef√¥nica
2  Abra no meio da lista telef√¥nica
3  Olhe a p√°gina
4  Se Smith estiver na p√°gina
5      Ligue para Mike
6  Sen√£o, se Smith estiver antes do meio da lista
7      Abra no meio da metade esquerda da lista
8      **Volte para a linha 3**
9  Sen√£o, se Smith estiver depois do meio da lista
10     Abra no meio da metade direita da lista
11     **Volte para a linha 3**
12 Sen√£o
13     Saia
</code></pre>
</li>
<li>
<p>Em vez disso, poder√≠amos simplesmente repetir todo o nosso algoritmo na metade da lista restante:</p>
<pre><code>1  Pegue a lista telef√¥nica
2  Abra no meio da lista telef√¥nica
3  Olhe a p√°gina
4  Se Smith estiver na p√°gina
5      Ligue para Mike
6  Sen√£o, se Smith estiver antes do meio da lista
7      **Pesquise na metade esquerda da lista**
8
9  Sen√£o, se Smith estiver depois do meio da lista
10     **Pesquise na metade direita da lista**
11
12 Sen√£o
13     Saia
</code></pre>
<ul>
<li>Isso parece um processo c√≠clico que nunca terminar√°, mas na verdade estamos dividindo o problema pela metade a cada vez e parando quando n√£o h√° mais lista restante.</li>
</ul>
</li>
<li>
<p><strong>Recurs√£o</strong> ocorre quando uma fun√ß√£o ou algoritmo se refere a si mesma, como no novo pseudoc√≥digo acima.</p>
</li>
<li>
<p>Na semana 1 tamb√©m implementamos uma &quot;pir√¢mide&quot; de blocos no seguinte formato:</p>
<pre><code>#
##
###
####
</code></pre>
<ul>
<li>
<p>E poder√≠amos ter c√≥digo iterativo como este:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

void draw(int h);

int main(void)
{
    // Obtenha a altura da pir√¢mide
    int altura = get_int(&quot;Altura: &quot;);

    // Desenhe a pir√¢mide
    draw(altura);
}

void draw(int h)
{
    // Desenhe uma pir√¢mide de altura h
    for (int i = 1; i &lt;= h; i++)
    {
        for (int j = 1; j &lt;= i; j++)
        {
            printf(&quot;#&quot;);
        }
        printf(&quot;\n&quot;);
    }
}
</code></pre>
<ul>
<li>Aqui, usamos <code>for</code> loops para imprimir cada bloco em cada linha.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mas observe que uma pir√¢mide de altura 4 √© na verdade uma pir√¢mide de altura 3, com uma linha extra de 4 blocos adicionados. E uma pir√¢mide de altura 3 √© uma pir√¢mide de altura 2, com uma linha extra de 3 blocos. Uma pir√¢mide de altura 2 √© uma pir√¢mide de altura 1, com uma linha extra de 2 blocos. E finalmente, uma pir√¢mide de altura 1 √© apenas uma pir√¢mide de altura 0, ou nada, com mais uma linha adicionada contendo um √∫nico bloco.</p>
</li>
<li>
<p>Com essa ideia em mente, podemos escrever:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

void draw(int h);

int main(void)
{
    // Obtenha a altura da pir√¢mide
    int altura = get_int(&quot;Altura: &quot;);

    // Desenhe a pir√¢mide
    draw(altura);
}

void draw(int h)
{
    // Se n√£o houver nada para desenhar
    if (h == 0)
    {
        return;
    }

    // Desenhe uma pir√¢mide de altura h - 1
    draw(h - 1);

    // Desenhe mais uma linha com largura h
    for (int i = 0; i &lt; h; i++)
    {
        printf(&quot;#&quot;);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<ul>
<li>Agora, nossa fun√ß√£o <code>draw</code> primeiro chama a si mesma <strong>recursivamente</strong>, desenhando uma pir√¢mide de altura <code>h - 1</code>. Mas antes mesmo disso, precisamos parar se <code>h</code> for igual a 0, j√° que n√£o haver√° mais nada para ser desenhado.</li>
<li>Depois, desenhamos a pr√≥xima linha ou uma linha com largura <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>Ordena√ß√£o por intercala√ß√£o</h2>
<ul>
<li>
<p>Podemos aplicar a ideia de recurs√£o √† ordena√ß√£o, com um outro algoritmo chamado ordena√ß√£o por intercala√ß√£o. O pseudoc√≥digo pode ser assim:</p>
<pre><code>  Se tiver apenas um item
    Retorne
  Sen√£o
      Ordenar a metade esquerda dos itens
      Ordenar a metade direita dos itens
      Intercalar as metades ordenadas
</code></pre>
</li>
<li>
<p>Podemos entender melhor com uma lista n√£o ordenada como exemplo:</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Primeiramente, vamos ordenar a metade esquerda (os primeiros quatro elementos):</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì
</code></pre>
</li>
<li>
<p>Para ordenar isso, precisamos primeiro ordenar a metade esquerda da metade esquerda:</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  ‚Äì ‚Äì
</code></pre>
</li>
<li>
<p>Agora, temos apenas um item, <code>7</code>, na metade esquerda, e um item, <code>4</code>, na metade direita. Ent√£o, vamos intercalar os dois, pegando o item menor de cada lista primeiro:</p>
<pre><code>  ‚Äì ‚Äì | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>Agora voltamos para a metade direita da metade esquerda e a ordenamos:</p>
<pre><code>  ‚Äì ‚Äì | ‚Äì ‚Äì | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Agora que ambas as metades da metade esquerda est√£o ordenadas, podemos intercal√°-las. Olhamos para o in√≠cio de cada lista e pegamos o <code>2</code> j√° que √© menor que <code>4</code>. Em seguida, pegamos o <code>4</code> pois √© o menor item do in√≠cio de ambas as listas. Em seguida, pegamos o <code>5</code> e finalmente o <code>7</code>, dando-nos:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | 6 3 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7
</code></pre>
</li>
<li>
<p>Agora vamos ordenar a metade direita da mesma maneira. Primeiro, a metade esquerda da metade direita:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>Em seguida, a metade direita da metade direita:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>Podemos intercalar a metade direita agora:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
<li>
<p>Por fim, podemos intercalar ambas as metades da lista completa, seguindo os mesmos passos de antes. Observe que n√£o precisamos verificar todos os elementos de cada metade para encontrar o menor, pois sabemos que cada metade j√° est√° ordenada. Em vez disso, pegamos o elemento menor das duas metades no in√≠cio de cada uma:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7 | ‚Äì 3 6 8
  1


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì 4 5 7 | ‚Äì 3 6 8
  1 2


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì 4 5 7 | ‚Äì ‚Äì 6 8
  1 2 3


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì 5 7 | ‚Äì ‚Äì 6 8
  1 2 3 4


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì 6 8
  1 2 3 4   5


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì ‚Äì 8
  1 2 3 4   5 6


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì 8
  1 2 3 4   5 6 7


  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  1 2 3 4   5 6 7 8
</code></pre>
</li>
<li>
<p>Foram necess√°rios diversos passos, mas na verdade foram menos passos do que nos outros algoritmos que vimos at√© agora. Dividimos nossa lista pela metade a cada vez, at√© estarmos &quot;ordenando&quot; oito listas com apenas um elemento cada:</p>
<pre><code>  7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
  4   7 | 2   5 | 3   6 | 1   8
  2   4   5   7 | 1   3   6   8
  1   2   3   4   5   6   7   8
</code></pre>
</li>
<li>
<p>Como nosso algoritmo dividiu o problema pela metade a cada vez, seu tempo de execu√ß√£o √© logar√≠tmico com <em>O</em>(log <em>n</em>). E depois de ordenarmos cada metade (ou metade de uma metade), precisamos intercalar todos os elementos, com <em>n</em> passos, j√° que precisamos olhar cada elemento uma vez.</p>
</li>
<li>
<p>Portanto, nosso tempo de execu√ß√£o total √© <em>O</em>(<em>n</em> log <em>n</em>):</p>
<ul>
<li>
<em>O</em>(_n_2)<ul>
<li>ordena√ß√£o bolha (bubble sort), ordena√ß√£o por sele√ß√£o (selection sort)</li>
</ul>
</li>
<li>
<em>O</em>(<em>n</em> log <em>n</em>)<ul>
<li>ordena√ß√£o por intercala√ß√£o (merge sort)</li>
</ul>
</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>busca linear (linear search)</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>busca bin√°ria (binary search)</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>
<p>Como log <em>n</em> √© maior que 1, mas menor que <em>n</em>, <em>n</em> log <em>n</em> est√° entre <em>n</em> (vezes 1) e _n_2.</p>
</li>
<li>
<p>O melhor caso, Œ©, ainda √© <em>n</em> log <em>n</em>, pois ainda ordenamos cada metade primeiro e depois as intercalamos:</p>
<ul>
<li>
Œ©(_n_2)<ul>
<li>ordena√ß√£o por sele√ß√£o (selection sort)</li>
</ul>
</li>
<li>
Œ©(<em>n</em> log <em>n</em>)<ul>
<li>ordena√ß√£o por intercala√ß√£o (merge sort)</li>
</ul>
</li>
<li>
Œ©(<em>n</em>)<ul>
<li>ordena√ß√£o bolha (bubble sort)</li>
</ul>
</li>
<li>Œ©(log <em>n</em>)</li>
<li>
Œ©(1)<ul>
<li>busca linear (linear search), busca bin√°ria (binary search)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Finalmente, h√° outra nota√ß√£o, Œò, Theta, que usamos para descrever os tempos de execu√ß√£o dos algoritmos se o limite superior e o limite inferior forem os mesmos. Por exemplo, a ordena√ß√£o por intercala√ß√£o tem Œò(<em>n</em> log <em>n</em>), j√° que o melhor e o pior caso requerem o mesmo n√∫mero de passos. E a ordena√ß√£o por sele√ß√£o tem Œò(_n_2).</p>
</li>
<li>
<p>Podemos ver uma <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualiza√ß√£o final</a> dos algoritmos de ordena√ß√£o com um maior n√∫mero de entradas, executando ao mesmo tempo.</p>
</li>
</ul>


        </main>
      </div>
    </div>
  </body>
</html>