<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci√™ncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script src="/static/highlight/highlight.min.js"></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="/static/highlight/styles/atom-one-light.min.css"
    />
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      code {
        border: 1px solid #dee2e6;
      }

      pre {
        padding: 0 !important;
      }

      /* Don't shrink these */
      code,
      pre {
        font-size: inherit;
      }
    </style>
    <title>CS50x em Portugu√™s</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html"
        >Este √© o CS50x</a
      >
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x">O curso de Ci√™ncias da Computa√ß√£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">üò∫</strong></span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1
          <span class="semana-titulo">C</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2
          <span class="semana-titulo"
            >Vetores</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3
          <span class="semana-titulo"
            >Algoritmos</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4
          <span class="semana-titulo"
            >Mem√≥ria</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5
          <span class="semana-titulo"
            >Estruturas de Dados</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6
          <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7
          <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8
          <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9
          <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10
          <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >Ciberseguran√ßa</a
        >
      </li>
    </ul>

    <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html"
          >Projeto Final</a
        >
      </li>
    </ul>

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/manual/index.html"
          >Manual do Programador</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/estilo.html"
          >Guia de Estilo</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade Acad√™mica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          ></a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html"></a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html"
          >Curr√≠culo do Curso</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/"
          >Navegador SQLite</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/"
          >Navegador PostgreSQL</a
        >
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >Documenta√ß√£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>
    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"
        ></a
      >
    </p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Aula 1</h1>
<ul>
<li><a href="#c">C</a></li>
<li><a href="#hello-world">ol√°, mundo</a></li>
<li><a href="#compilers">Compiladores</a></li>
<li><a href="#string">String</a></li>
<li><a href="#scratch-blocks-in-c">Blocos Scratch em C</a></li>
<li><a href="#types-formats-operators">Tipos, formatos, operadores</a></li>
<li>
<a href="#more-examples">Mais exemplos</a><ul>
<li><a href="#screens">Telas</a></li>
</ul>
</li>
<li><a href="#memory-imprecision-and-overflow">Mem√≥ria, imprecis√£o e overflow</a></li>
</ul>
<h2>C</h2>
<ul>
<li>
<p>Hoje vamos aprender uma nova linguagem, <strong>C</strong>: uma linguagem de programa√ß√£o que tem todos os recursos do Scratch e mais, mas talvez seja um pouco menos amig√°vel, j√° que √© puramente em texto:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;ol√°, mundo\n&quot;);
}
</code></pre>
<ul>
<li>Embora as palavras sejam novas, as ideias s√£o exatamente as mesmas dos blocos &quot;quando a bandeira verde for clicada&quot; e &quot;dizer (ol√°, mundo)&quot; no Scratch:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/1/when_green_flag.png" alt="bloco rotulado 'quando a bandeira verde for clicada', bloco rotulado 'dizer (ol√°, mundo)'" /></li>
</ul>
</li>
<li>
<p>Embora criptico, n√£o se esque√ßa de que 2/3 dos estudantes do CS50 nunca estudaram CS antes, ent√£o n√£o se intimide! E embora no in√≠cio, para emprestar uma frase do MIT, tentar absorver todos esses novos conceitos possa parecer como beber √°gua de uma mangueira de inc√™ndio, tenha a certeza de que no final do semestre estaremos empoderados e experientes em aprender e aplicar esses conceitos.</p>
</li>
<li>
<p>Podemos comparar muitas das constru√ß√µes em C com blocos que j√° vimos e usamos no Scratch. A sintaxe √© muito menos importante do que os princ√≠pios, aos quais j√° fomos apresentados.</p>
</li>
</ul>
<h2>ol√°, mundo</h2>
<ul>
<li>
<p>O bloco &quot;quando a bandeira verde for clicada&quot; no Scratch inicia o programa principal; clicar na bandeira verde faz com que o conjunto correto de blocos abaixo comece a ser executado. Em C, a primeira linha para o mesmo √© <code>int main(void)</code>, o que aprenderemos mais sobre nas pr√≥ximas semanas, seguido de uma chave aberta <code>{</code> e uma chave fechada <code>}</code>, envolvendo tudo o que deve estar em nosso programa.</p>
<pre><code>int main(void)
{

}
</code></pre>
</li>
<li>
<p>O bloco &quot;dizer (ol√°, mundo)&quot; √© uma fun√ß√£o e corresponde a <code>printf(&quot;ol√°, mundo&quot;);</code>. Em C, a fun√ß√£o para imprimir algo na tela √© <code>printf</code>, onde <code>f</code> significa &quot;formato&quot;, o que significa que podemos formatar a string impressa de diferentes maneiras. Em seguida, usamos par√™nteses para passar o que queremos imprimir. Temos que usar aspas duplas para cercar nosso texto para que ele seja entendido como texto, e finalmente, adicionamos um ponto e v√≠rgula <code>;</code> para encerrar esta linha de c√≥digo.</p>
</li>
<li>
<p>Para fazer nosso programa funcionar, tamb√©m precisamos de outra linha no topo, uma linha de cabe√ßalho <code>#include &lt;stdio.h&gt;</code> que define a fun√ß√£o <code>printf</code> que queremos usar. Em algum lugar do nosso computador, h√° um arquivo, <code>stdio.h</code>, que inclui o c√≥digo que nos permite acessar a fun√ß√£o <code>printf</code>, e a linha <code>#include</code> diz ao computador para incluir esse arquivo em nosso programa.</p>
</li>
<li>
<p>Para escrever nosso primeiro programa no Scratch, abrimos o site do Scratch. Da mesma forma, usaremos o <a href="https://sandbox.cs50.io/">CS50 Sandbox</a> para come√ßar a escrever e executar c√≥digo da mesma maneira. O CS50 Sandbox √© um ambiente virtual baseado em nuvem com as bibliotecas e ferramentas j√° instaladas para escrever programas em v√°rias linguagens. Na parte superior, h√° um editor de c√≥digo simples, onde podemos digitar texto. Abaixo, temos uma janela do terminal na qual podemos digitar comandos:
<img src="https://cs50.harvard.edu/x/2020/notes/1/cs50_sandbox.png" alt="dois pain√©is, parte superior rotulada hello.c, parte inferior rotulada Terminal" /></p>
</li>
<li>
<p>Digitaremos nosso c√≥digo anterior no topo, ap√≥s usar o sinal de <code>+</code> para criar um novo arquivo chamado <code>hello.c</code>:
<img src="https://cs50.harvard.edu/x/2020/notes/1/editor.png" alt="ol√°, mundo no editor" /></p>
</li>
<li>
<p>Terminamos o arquivo do nosso programa com <code>.c</code> por conven√ß√£o, para indicar que √© um programa em C. Observe que nosso c√≥digo est√° colorizado, para que certas coisas sejam mais vis√≠veis.</p>
</li>
</ul>
<h2>Compiladores</h2>
<ul>
<li>Uma vez que salvamos o c√≥digo que escrevemos, chamado de <strong>c√≥digo-fonte</strong>, precisamos convert√™-lo em <strong>c√≥digo de m√°quina</strong>, instru√ß√µes bin√°rias que o computador entende diretamente.</li>
<li>Usamos um programa chamado <strong>compilador</strong> para compilar nosso c√≥digo-fonte em c√≥digo de m√°quina.</li>
<li>
Para fazer isso, usamos o painel do <strong>Terminal</strong>, que possui um <strong>prompt de comando</strong>. O <code>$</code> √† esquerda √© um prompt, ap√≥s o qual podemos digitar comandos.<ul>
<li>Digitamos <code>clang hello.c</code> (onde <code>clang</code> significa &quot;C languages&quot;, um compilador escrito por um grupo de pessoas). Mas antes de pressionarmos enter, clique no √≠cone da pasta no canto superior esquerdo do CS50 Sandbox. Vemos nosso arquivo, <code>hello.c</code>. Ent√£o pressionamos enter na janela do terminal e vemos que agora temos outro arquivo chamado <code>a.out</code> (abrevia√ß√£o de &quot;assembly output&quot;). Dentro desse arquivo est√° o c√≥digo do nosso programa, em bin√°rio. Agora, podemos digitar <code>./a.out</code> no prompt do terminal para executar o programa <code>a.out</code> em nossa pasta atual. Acabamos de escrever, compilar e executar nosso primeiro programa!</li>
</ul>
</li>
</ul>
<h2>String</h2>
<ul>
<li>
<p>Mas depois de executarmos nosso programa, vemos <code>hello, world$</code>, com o novo prompt na mesma linha que a sa√≠da. Acontece que precisamos especificar precisamente que precisamos de uma nova linha ap√≥s nosso programa, ent√£o podemos atualizar nosso c√≥digo para incluir um caractere de nova linha especial, <code>\n</code>:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;hello, world\n&quot;);
}
</code></pre>
<ul>
<li>Agora precisamos lembrar de recompilar nosso programa com <code>clang hello.c</code> antes de podermos executar essa nova vers√£o.</li>
</ul>
</li>
<li>
<p>A linha 2 de nosso programa est√° intencionalmente em branco, pois queremos iniciar uma nova se√ß√£o de c√≥digo, assim como iniciar novos par√°grafos em ensaios. N√£o √© estritamente necess√°rio para que nosso programa seja executado corretamente, mas ajuda os humanos a lerem programas mais longos com mais facilidade.</p>
</li>
<li>
<p>Podemos alterar o nome de nosso programa de <code>a.out</code> para outra coisa tamb√©m. Podemos passar <strong>argumentos de linha de comando</strong>, ou op√ß√µes adicionais, para programas no terminal, dependendo do que o programa est√° escrito para entender. Por exemplo, podemos digitar <code>clang -o hello hello.c</code>, e <code>-o hello</code> est√° dizendo ao programa <code>clang</code> para salvar a sa√≠da compilada apenas como <code>hello</code>. Em seguida, podemos simplesmente executar <code>./hello</code>.</p>
</li>
<li>
<p>Em nosso prompt de comando, podemos executar outros comandos, como <code>ls</code> (listar), que mostra os arquivos em nossa pasta atual:</p>
<pre><code>$ ls
a.out* hello* hello.c
</code></pre>
<ul>
<li>O asterisco, <code>*</code>, indica que esses arquivos s√£o execut√°veis, ou que podem ser executados pelo nosso computador.</li>
</ul>
</li>
<li>
<p>Podemos usar o comando <code>rm</code> (remover) para excluir um arquivo:</p>
<pre><code>$ rm a.out
rm: remove regular file &#x27;a.out&#x27;?
</code></pre>
<ul>
<li>Podemos digitar <code>y</code> ou <code>yes</code> para confirmar e usar <code>ls</code> novamente para ver que ele desapareceu permanentemente.</li>
</ul>
</li>
<li>
<p>Agora, vamos tentar obter entrada do usu√°rio, como fizemos no Scratch quando quer√≠amos dizer &quot;hello, David&quot;:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/1/ask_say_join.png" alt="captura de tela dos blocos &quot;perguntar qual √© o seu nome? e esperar&quot;, &quot;dizer junte ol√°, resposta&quot;" /></p>
<pre><code>string answer = get_string(&quot;Qual √© o seu nome?\n&quot;);
printf(&quot;hello, %s\n&quot;, answer);
</code></pre>
<ul>
<li>Primeiro, precisamos de uma <strong>string</strong>, ou seja, um peda√ßo de texto (especificamente, zero ou mais caracteres em sequ√™ncia entre aspas duplas, como <code>&quot;&quot;</code>, <code>&quot;ba&quot;</code> ou ‚Äúbananas‚Äù), que podemos pedir ao usu√°rio usando a fun√ß√£o <code>get_string</code>. Passamos o prompt, ou o que queremos perguntar ao usu√°rio, para a fun√ß√£o com <code>&quot;Qual √© o seu nome?\n&quot;</code> dentro dos par√™nteses. √Ä esquerda, queremos criar uma vari√°vel, <code>answer</code>, cujo valor ser√° o que o usu√°rio digitar. (O sinal de igual <code>=</code> est√° definindo o valor da direita para a esquerda.) Por fim, o tipo de vari√°vel que queremos √© <code>string</code>, ent√£o especificamos isso √† esquerda de <code>answer</code>.</li>
<li>Em seguida, dentro da fun√ß√£o <code>printf</code>, queremos o valor de <code>answer</code> naquilo que imprimimos. Usamos um espa√ßo reservado para nossa vari√°vel de string, <code>%s</code>, dentro da frase que queremos imprimir, como <code>&quot;hello, %s\n&quot;</code>, e em seguida, damos a <code>printf</code> outro argumento, ou op√ß√£o, para informar que queremos que a vari√°vel <code>answer</code> seja substitu√≠da.</li>
</ul>
</li>
<li>
<p>Se cometemos um erro, como escrever <code>printf(&quot;hello, world&quot;\n);</code> com o <code>\n</code> fora das aspas duplas para nossa string, veremos erros do nosso compilador:</p>
<pre><code>$ clang -o hello hello.c
hello.c:5:26: error: expected &#x27;)&#x27;
    printf(&quot;hello, world&quot;\n);
                         ^
hello.c:5:11: note: to match this &#x27;(&#x27;
    printf(&quot;hello, world&quot;\n);
          ^
1 error generated.
</code></pre>
<ul>
<li>A primeira linha do erro nos diz para olhar para <code>hello.c</code>, linha 5, coluna 26, onde o compilador esperava um par√™ntese de fechamento, em vez de uma barra invertida.</li>
</ul>
</li>
<li>
<p>Para simplificar as coisas (pelo menos no in√≠cio), incluiremos uma biblioteca, ou conjunto de c√≥digo, do CS50. A biblioteca fornece-nos o tipo de vari√°vel <code>string</code>, a fun√ß√£o <code>get_string</code> e muito mais. S√≥ temos que escrever uma linha no topo para <code>include</code> o arquivo <code>cs50.h</code>:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string name = get_string(&quot;Qual √© o seu nome?\n&quot;);
    printf(&quot;hello, name\n&quot;);
}
</code></pre>
</li>
<li>
<p>Ent√£o vamos criar um novo arquivo, <code>string.c</code>, com este c√≥digo:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    string name = get_string(&quot;Qual √© o seu nome?\n&quot;);
    printf(&quot;hello, %s\n&quot;, name);
}
</code></pre>
</li>
<li>
<p>Agora, se tentarmos compilar esse c√≥digo, obtemos v√°rias linhas de erros. √Äs vezes, um erro significa que o compilador passa a interpretar c√≥digo correto incorretamente, gerando mais erros do que realmente existem. Portanto, come√ßamos com nosso primeiro erro:</p>
<pre><code>$ clang -o string string.c
string.c:5:5: error: use of undeclared identifier &#x27;string&#x27;; did you mean &#x27;stdin&#x27;?
  string name = get_string(&quot;Qual √© o seu nome?\n&quot;);
  ^~~~~~
  stdin
/usr/include/stdio.h:135:25: note: &#x27;stdin&#x27; declared here
extern struct _IO_FILE *stdin;          /* Fluxo de entrada padr√£o.  */
</code></pre>
<ul>
<li>N√£o quer√≠amos dizer <code>stdin</code> (entrada padr√£o) em vez de <code>string</code>, portanto, essa mensagem de erro n√£o foi √∫til. Na verdade, precisamos importar outro arquivo que defina o tipo <code>string</code> (na verdade, uma rodinha de treinamento do CS50, como descobriremos nas pr√≥ximas semanas).</li>
</ul>
</li>
<li>
<p>Portanto, podemos incluir outro arquivo, <code>cs50.h</code>, que tamb√©m inclui a fun√ß√£o <code>get_string</code>, entre outras.</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string name = get_string(&quot;Qual √© o seu nome?\n&quot;);
    printf(&quot;hello, %s\n&quot;, name);
}
</code></pre>
</li>
<li>
<p>Agora, quando tentamos compilar nosso programa, temos apenas um erro:</p>
<pre><code>$ clang -o string string.c
/tmp/string-aca94d.o: In function `main&#x27;:
string.c:(.text+0x19): undefined reference to `get_string&#x27;
clang-7: error: comando do vinculador falhou com o c√≥digo de sa√≠da 1 (use -v para ver a invoca√ß√£o)
</code></pre>
<ul>
<li>Acontece que tamb√©m precisamos dizer ao compilador para adicionar nosso arquivo especial da biblioteca CS50, com <code>clang -o string string.c -lcs50</code>, com <code>-l</code> para &quot;link&quot;.</li>
</ul>
</li>
<li>
<p>Podemos at√© abstrair isso e simplesmente digitar <code>make string</code>. Vemos que, por padr√£o no CS50 Sandbox, <code>make</code> usa <code>clang</code> para compilar nosso c√≥digo de <code>string.c</code> em <code>string</code>, com todos os argumentos necess√°rios, ou flags, passados.
'</p>
</li>
</ul>
<h2>Blocos Scratch em C</h2>
<ul>
<li>
<p>O bloco &quot;definir [contador] para (0)&quot; est√° criando uma vari√°vel, e em C n√≥s escrever√≠amos <code>int contador = 0;</code>, onde <code>int</code> especifica que o tipo da nossa vari√°vel √© um inteiro:
<img src="https://cs50.harvard.edu/x/2020/notes/1/set_counter_to_0.png" alt="bloco rotulado 'definir contador para (0)'" /></p>
</li>
<li>
<p>&quot;mudar [contador] por (1)&quot; √© <code>contador = contador + 1;</code> em C. (Em C, o <code>=</code> n√£o √© como um sinal de igual em uma equa√ß√£o, onde estamos dizendo que <code>contador</code> √© o mesmo que <code>contador + 1</code>. Em vez disso, <code>=</code> √© um operador de atribui√ß√£o que significa &quot;copie o valor √† direita para o valor √† esquerda&quot;.) E observe que n√£o precisamos mais dizer <code>int</code>, j√° que presumimos que j√° especificamos anteriormente que <code>contador</code> √© um <code>int</code>, com algum valor existente. Tamb√©m podemos dizer <code>contador += 1;</code> ou <code>contador++;</code>, ambos t√™m o mesmo efeito com menos caracteres para digitar.
<img src="https://cs50.harvard.edu/x/2020/notes/1/change_counter_by_1.png" alt="bloco rotulado 'mudar contador por (1)'" /></p>
</li>
<li>
<p>Uma condi√ß√£o seria mapeada como:
<img src="https://cs50.harvard.edu/x/2020/notes/1/if_x_y.png" alt="bloco rotulado 'se &lt; (x) &lt; (y)&gt;', dentro do qual h√° um bloco rotulado 'dizer (x √© menor que y)'" /></p>
<pre><code>if (x &lt; y)
{
    printf(&quot;x √© menor que y\n&quot;);
}
</code></pre>
<ul>
<li>Observe que em C usamos <code>{</code> e <code>}</code> (bem como indenta√ß√£o) para indicar como as linhas de c√≥digo devem ser aninhadas.</li>
</ul>
</li>
<li>
<p>Tamb√©m podemos ter condi√ß√µes de if-else:
<img src="https://cs50.harvard.edu/x/2020/notes/1/if_else.png" alt="bloco rotulado 'se &lt; (x) &lt; (y)&gt;', dentro do qual h√° um bloco rotulado 'dizer (x √© menor que y)', bloco pai tamb√©m tem um 'sen√£o', dentro do qual h√° um bloco rotulado 'dizer (x n√£o √© menor que y)'" /></p>
<pre><code>if (x &lt; y)
{
    printf(&quot;x √© menor que y\n&quot;);
}
else
{
    printf(&quot;x n√£o √© menor que y\n&quot;);
}
</code></pre>
<ul>
<li>Observe que as linhas de c√≥digo que n√£o s√£o uma a√ß√£o em si (<code>if...</code> e as chaves) n√£o terminam com um ponto e v√≠rgula.</li>
</ul>
</li>
<li>
<p>E at√© mesmo <code>else if</code>:
<img src="https://cs50.harvard.edu/x/2020/notes/1/if_else_if.png" alt="bloco rotulado 'se &lt; (x) &lt; (y)&gt;', dentro do qual h√° um bloco rotulado 'dizer (x √© menor que y)', bloco pai tamb√©m tem um 'sen√£o', dentro do qual h√° um aninhamento de um bloco rotulado 'se &lt; (x) &gt; (y) &gt;', dentro do qual h√° um bloco rotulado 'dizer (x √© maior que y)', bloco pai tamb√©m tem um 'sen√£o', dentro do qual h√° um bloco rotulado 'se &lt; (x) = (y) &gt;', dentro do qual h√° um bloco rotulado 'dizer (x √© igual a y)'" /></p>
<pre><code>if (x &lt; y)
{
    printf(&quot;x √© menor que y\n&quot;);
}
else if (x &gt; y)
{
    printf(&quot;x √© maior que y\n&quot;);
}
else if (x == y)
{
    printf(&quot;x √© igual a y\n&quot;);
}
</code></pre>
<ul>
<li>Observe que, para comparar dois valores em C, usamos <code>==</code>, dois sinais de igual.</li>
<li>E, logicamente, n√£o precisamos do <code>if (x == y)</code> na condi√ß√£o final, j√° que esse √© o √∫nico caso restante, e podemos usar apenas <code>else</code>.</li>
</ul>
</li>
<li>
<p>Loops podem ser escritos da seguinte forma:
<img src="https://cs50.harvard.edu/x/2020/notes/1/forever.png" alt="bloco rotulado 'para sempre', dentro do qual h√° um bloco rotulado 'dizer (ol√°, mundo)'" /></p>
<pre><code>while (true)
{
    printf(&quot;ol√°, mundo\n&quot;);
}
</code></pre>
<ul>
<li>A palavra-chave <code>while</code> tamb√©m requer uma condi√ß√£o, ent√£o usamos <code>true</code> como a express√£o booleana para garantir que nosso loop ser√° executado para sempre. Nosso programa verificar√° se a express√£o avalia para <code>true</code> (o que sempre acontecer√° neste caso) e ent√£o executar√° as linhas dentro das chaves. Em seguida, ele repetir√° isso at√© que a express√£o n√£o seja mais verdadeira (o que n√£o mudar√° neste caso).</li>
</ul>
</li>
<li>
<p>Podemos fazer algo um certo n√∫mero de vezes com <code>while</code>:
<img src="https://cs50.harvard.edu/x/2020/notes/1/repeat.png" alt="bloco rotulado 'repetir (50)', dentro do qual h√° um bloco rotulado 'dizer (ol√°, mundo)'" /></p>
<pre><code>int i = 0;
while (i &lt; 50)
{
    printf(&quot;ol√°, mundo\n&quot;);
    i++;
}
</code></pre>
<ul>
<li>Criamos uma vari√°vel, <code>i</code>, e a definimos como 0. Ent√£o, enquanto <code>i &lt; 50</code>, executamos algumas linhas de c√≥digo e adicionamos 1 a <code>i</code> ap√≥s cada execu√ß√£o.</li>
<li>As chaves em torno das duas linhas dentro do loop <code>while</code> indicam que essas linhas se repetir√£o, e podemos adicionar linhas adicionais ao nosso programa depois, se desejarmos.</li>
</ul>
</li>
<li>
<p>Para fazer a mesma repeti√ß√£o, mais comumente usamos a palavra-chave <code>for</code>:</p>
<pre><code>for (int i = 0; i &lt; 50; i++)
{
    printf(&quot;ol√°, mundo\n&quot;);
}
</code></pre>
<ul>
<li>Novamente, primeiro criamos uma vari√°vel chamada <code>i</code> e a definimos como 0. Em seguida, verificamos se <code>i &lt; 50</code> toda vez que alcan√ßamos o topo do loop, antes de executar qualquer c√≥digo dentro. Se essa express√£o for verdadeira, executamos o c√≥digo interno. Por fim, depois de executarmos o c√≥digo interno, usamos <code>i++</code> para adicionar um a <code>i</code>, e o loop se repete.</li>
</ul>
</li>
</ul>
<h2>Tipos, formatos, operadores</h2>
<ul>
<li>
Existem outros tipos que podemos usar para nossas vari√°veis<ul>
<li><code>bool</code>, uma express√£o booleana de <code>true</code> ou <code>false</code></li>
<li><code>char</code>, um √∫nico caractere como <code>a</code> ou <code>2</code></li>
<li><code>double</code>, um valor de ponto flutuante com ainda mais d√≠gitos</li>
<li><code>float</code>, um valor de ponto flutuante ou n√∫mero real com um valor decimal</li>
<li><code>int</code>, inteiros at√© um certo tamanho ou n√∫mero de bits</li>
<li><code>long</code>, inteiros com mais bits, permitindo contar mais alto</li>
<li><code>string</code>, uma sequ√™ncia de caracteres</li>
</ul>
</li>
<li>
A biblioteca CS50 possui fun√ß√µes correspondentes para obter entrada de v√°rios tipos:<ul>
<li><code>get_char</code></li>
<li><code>get_double</code></li>
<li><code>get_float</code></li>
<li><code>get_int</code></li>
<li><code>get_long</code></li>
<li><code>get_string</code></li>
</ul>
</li>
<li>
Para o <code>printf</code>, tamb√©m existem diferentes espa√ßos reservados para cada tipo:<ul>
<li><code>%c</code> para caracteres</li>
<li><code>%f</code> para floats, doubles</li>
<li><code>%i</code> para inteiros</li>
<li><code>%li</code> para longs</li>
<li><code>%s</code> para strings</li>
</ul>
</li>
<li>
E existem alguns operadores matem√°ticos que podemos usar:<ul>
<li><code>+</code> para adi√ß√£o</li>
<li><code>-</code> para subtra√ß√£o</li>
<li><code>*</code> para multiplica√ß√£o</li>
<li><code>/</code> para divis√£o</li>
<li><code>%</code> para resto</li>
</ul>
</li>
</ul>
<h1>Mais exemplos</h1>
<ul>
<li>
<p>Para cada um desses exemplos, voc√™ pode clicar nos <a href="../../weeks/1/">links de sandbox</a> para executar e editar suas pr√≥prias c√≥pias deles.</p>
</li>
<li>
<p>No arquivo <code>int.c</code>, obtemos e imprimimos um n√∫mero inteiro:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int age = get_int(&quot;Qual a sua idade?\n&quot;);
    int days = age * 365;
    printf(&quot;Voc√™ tem pelo menos %i dias de idade.\n&quot;, days);
}
</code></pre>
<ul>
<li>
<p>Observe que usamos <code>%i</code> para imprimir um n√∫mero inteiro.</p>
</li>
<li>
<p>Agora podemos executar <code>make int</code> e rodar nosso programa com <code>./int</code>.</p>
</li>
<li>
<p>Podemos combinar linhas e remover a vari√°vel <code>days</code> com:</p>
<pre><code>int age = get_int(&quot;Qual a sua idade?\n&quot;);
printf(&quot;Voc√™ tem pelo menos %i dias de idade.\n&quot;, age * 365);
</code></pre>
</li>
<li>
<p>Ou at√© mesmo combinar tudo em uma √∫nica linha:</p>
<pre><code>printf(&quot;Voc√™ tem pelo menos %i dias de idade.\n&quot;, get_int(&quot;Qual a sua idade?\n&quot;) * 365);
</code></pre>
</li>
<li>
<p>No entanto, quando uma linha fica muito longa ou complicada, pode ser melhor dividir em duas ou at√© tr√™s linhas para melhorar a legibilidade.</p>
</li>
</ul>
</li>
<li>
<p>No arquivo <code>float.c</code>, podemos obter n√∫meros decimais (chamados de valores de ponto flutuante nos computadores, porque a v√≠rgula decimal pode &quot;flutuar&quot; entre os d√≠gitos, dependendo do n√∫mero):</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    float price = get_float(&quot;Qual √© o pre√ßo?\n&quot;);
    printf(&quot;O total √© %f.\n&quot;, price * 1.0625);
}
</code></pre>
<ul>
<li>Agora, se compilarmos e executarmos nosso programa, veremos um pre√ßo impresso com imposto.</li>
<li>Podemos especificar o n√∫mero de d√≠gitos impressos ap√≥s a v√≠rgula decimal com um espa√ßo reservado como <code>%.2f</code> para dois d√≠gitos ap√≥s a v√≠rgula.</li>
</ul>
</li>
<li>
<p>Com <code>parity.c</code>, podemos verificar se um n√∫mero √© par ou √≠mpar:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int n = get_int(&quot;n: &quot;);

    if (n % 2 == 0)
    {
        printf(&quot;par\n&quot;);
    }
    else
    {
        printf(&quot;√≠mpar\n&quot;);
    }
}
</code></pre>
<ul>
<li>Com o operador <code>%</code> (m√≥dulo), podemos obter o resto de <code>n</code> ap√≥s dividir por 2. Se o resto for 0, sabemos que <code>n</code> √© par. Caso contr√°rio, sabemos que <code>n</code> √© √≠mpar.</li>
<li>E fun√ß√µes como <code>get_int</code> da biblioteca CS50 fazem verifica√ß√£o de erros, onde apenas entradas do usu√°rio que correspondem ao tipo que desejamos s√£o aceitas.</li>
</ul>
</li>
<li>
<p>No arquivo <code>conditions.c</code>, transformamos os trechos de condi√ß√£o anteriores em um programa:</p>
<pre><code>// Condi√ß√µes e operadores relacionais

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Solicita ao usu√°rio um valor para x
    int x = get_int(&quot;x: &quot;);

    // Solicita ao usu√°rio um valor para y
    int y = get_int(&quot;y: &quot;);

    // Compara x e y
    if (x &lt; y)
    {
        printf(&quot;x √© menor que y\n&quot;);
    }
    else if (x &gt; y)
    {
        printf(&quot;x √© maior que y\n&quot;);
    }
    else
    {
        printf(&quot;x √© igual a y\n&quot;);
    }
}
</code></pre>
<ul>
<li>Linhas que come√ßam com <code>//</code> s√£o coment√°rios, ou notas para os seres humanos que o compilador ignorar√°.</li>
<li>Para David compilar e executar este programa em seu sandbox, ele precisava executar o comando <code>cd src1</code> no terminal. Isso muda o diret√≥rio, ou pasta, para aquele em que ele salvou todos os arquivos de origem da palestra. Em seguida, ele pode executar <code>make conditions</code> e <code>./conditions</code>. Com <code>pwd</code>, ele pode ver que est√° em uma pasta <code>src1</code> (dentro de outras pastas). E <code>cd</code> sozinho, sem argumentos, nos levar√° de volta √† nossa pasta padr√£o no sandbox.</li>
</ul>
</li>
<li>
<p>No arquivo <code>agree.c</code>, podemos pedir ao usu√°rio para confirmar ou negar algo:</p>
<pre><code>// Operadores l√≥gicos

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Solicita ao usu√°rio para concordar
    char c = get_char(&quot;Voc√™ concorda?\n&quot;);

    // Verifica se concordou
    if (c == &#x27;Y&#x27; || c == &#x27;y&#x27;)
    {
        printf(&quot;Concordou.\n&quot;);
    }
    else if (c == &#x27;N&#x27; || c == &#x27;n&#x27;)
    {
        printf(&quot;N√£o concordou.\n&quot;);
    }
}
</code></pre>
<ul>
<li>Usamos duas barras verticais, <code>||</code>, para indicar um &quot;ou&quot; l√≥gico, ou seja, qualquer uma das express√µes pode ser verdadeira para que a condi√ß√£o seja seguida.</li>
<li>E se nenhuma das express√µes for verdadeira, nada acontecer√°, pois nosso programa n√£o possui um loop.</li>
</ul>
</li>
<li>
<p>Vamos implementar o programa de tossir da semana 0:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;tossir\n&quot;);
    printf(&quot;tossir\n&quot;);
    printf(&quot;tossir\n&quot;);
}
</code></pre>
</li>
<li>
<p>Poder√≠amos usar um loop <code>for</code>:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    for (int i = 0; i &lt; 3; i++)
    {
        printf(&quot;tossir\n&quot;);
    }
}
</code></pre>
<ul>
<li>Por conven√ß√£o, os programadores tendem a come√ßar a contar em 0, ent√£o <code>i</code> ter√° os valores <code>0</code>, <code>1</code> e <code>2</code> antes de parar, totalizando tr√™s itera√ß√µes. Tamb√©m poder√≠amos escrever <code>for (int i = 1; i &lt;= 3; i++)</code> para o mesmo efeito final.</li>
</ul>
</li>
<li>
<p>Podemos mover a linha <code>printf</code> para sua pr√≥pria fun√ß√£o:</p>
<pre><code>#include &lt;stdio.h&gt;

void tossir(void);

int main(void)
{
    for (int i = 0; i &lt; 3; i++)
    {
        tossir();
    }
}

void tossir(void)
{
    printf(&quot;tossir\n&quot;);
}
</code></pre>
<ul>
<li>Declaramos uma nova fun√ß√£o com <code>void tossir(void);</code>, antes de nossa fun√ß√£o <code>main</code> cham√°-la. O compilador C l√™ nosso c√≥digo de cima para baixo, ent√£o precisamos inform√°-lo que a fun√ß√£o <code>tossir</code> existe antes de us√°-la. Depois, ap√≥s nossa fun√ß√£o <code>main</code>, podemos implementar a fun√ß√£o <code>tossir</code>. Dessa forma, o compilador sabe que a fun√ß√£o existe e podemos manter nossa fun√ß√£o <code>main</code> pr√≥xima ao topo.</li>
<li>E nossa fun√ß√£o <code>tossir</code> n√£o recebe nenhuma entrada, ent√£o temos <code>tossir(void)</code>.</li>
</ul>
</li>
<li>
<p>Podemos abstrair ainda mais a fun√ß√£o <code>tossir</code>:</p>
<pre><code>#include &lt;stdio.h&gt;

void tossir(int n);

int main(void)
{
    tossir(3);
}

void tossir(int n)
{
    for (int i = 0; i &lt; n; i++)
    {
        printf(&quot;tossir\n&quot;);
    }
}
</code></pre>
<ul>
<li>Agora, quando quisermos imprimir &quot;tossir&quot; qualquer n√∫mero de vezes, podemos simplesmente chamar a mesma fun√ß√£o. Observe que, com <code>void tossir(int n)</code>, indicamos que a fun√ß√£o <code>tossir</code> recebe como entrada um inteiro (<code>int</code>), que chamamos de <code>n</code>. E dentro de <code>tossir</code>, usamos <code>n</code> em nosso loop <code>for</code> para imprimir &quot;tossir&quot; o n√∫mero certo de vezes.</li>
</ul>
</li>
<li>
<p>Vamos dar uma olhada em <code>positive.c</code>:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int get_positive_int(void);

int main(void)
{
    int i = get_positive_int();
    printf(&quot;%i\n&quot;, i);
}

// Solicita ao usu√°rio um inteiro positivo
int get_positive_int(void)
{
    int n;
    do
    {
        n = get_int(&quot;%s&quot;, &quot;Inteiro Positivo: &quot;);
    }
    while (n &lt; 1);
    return n;
}
</code></pre>
<ul>
<li>A biblioteca CS50 n√£o possui uma fun√ß√£o <code>get_positive_int</code>, mas podemos escrever uma por conta pr√≥pria. Nossa fun√ß√£o <code>int get_positive_int(void)</code> solicitar√° ao usu√°rio um n√∫mero inteiro (<code>int</code>) e retornar√° esse n√∫mero, que nossa fun√ß√£o <code>main</code> armazena como <code>i</code>. Em <code>get_positive_int</code>, inicializamos uma vari√°vel <code>int n</code> sem atribuir um valor a ela ainda. Em seguida, temos uma nova constru√ß√£o, <code>do ... while</code>, que faz algo <em>primeiro</em>, verifica uma condi√ß√£o e repete at√© que a condi</li>
</ul>
</li>
</ul>
<h2>Telas</h2>
<ul>
<li>
<p>Talvez queiramos um programa que imprima uma parte de uma tela de um video game como Super Mario Bros. No arquivo <code>mario0.c</code>, temos:</p>
<pre><code>// Imprime uma fileira de 4 pontos de interroga√ß√£o

#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;????\n&quot;);
}
</code></pre>
</li>
<li>
<p>Podemos pedir ao usu√°rio um n√∫mero de pontos de interroga√ß√£o e, em seguida, imprimi-los, com <code>mario2.c</code>:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int n;
    do
    {
        n = get_int(&quot;Largura: &quot;);
    }
    while (n &lt; 1);
    for (int i = 0; i &lt; n; i++)
    {
        printf(&quot;?&quot;);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
</li>
<li>
<p>E podemos imprimir um conjunto bidimensional de blocos com <code>mario8.c</code>:</p>
<pre><code>// Imprime uma grade de tijolos de tamanho n com um loop

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int n;
    do
    {
        n = get_int(&quot;Tamanho: &quot;);
    }
    while (n &lt; 1);
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; n; j++)
        {
            printf(&quot;#&quot;);
        }
        printf(&quot;\n&quot;);
    }
}
</code></pre>
<ul>
<li>Observe que temos dois loops aninhados, onde o loop externo usa <code>i</code> para executar tudo dentro dele <code>n</code> vezes, e o loop interno usa <code>j</code>, uma vari√°vel diferente, para fazer algo <code>n</code> vezes para cada uma daquelas vezes. Em outras palavras, o loop externo imprime <code>n</code> &quot;linhas&quot; ou linhas, e o loop interno imprime <code>n</code> &quot;colunas&quot; ou caracteres <code>#</code>, em cada linha.</li>
</ul>
</li>
<li>
<p>Outros exemplos n√£o abordados na palestra est√£o dispon√≠veis em &quot;C√≥digo-fonte&quot; para <a href="../../weeks/1/">Semana 1</a>.</p>
</li>
</ul>
<h1>Mem√≥ria, imprecis√£o e estouro</h1>
<p>Nosso computador tem mem√≥ria, em chips de hardware chamados RAM, mem√≥ria de acesso aleat√≥rio. Nossos programas usam essa RAM para armazenar dados enquanto s√£o executados, mas essa mem√≥ria √© finita. Portanto, com um n√∫mero finito de bits, n√£o podemos representar todos os n√∫meros poss√≠veis (dos quais h√° um n√∫mero infinito). Ent√£o, nosso computador tem um certo n√∫mero de bits para cada float e int, e precisa arredondar para o valor decimal mais pr√≥ximo em determinado ponto.
Com <code>floats.c</code>, podemos ver o que acontece quando usamos floats:</p>
<pre><code class="language-c">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Solicitar x ao usu√°rio
    float x = get_float(&quot;x: &quot;);

    // Solicitar y ao usu√°rio
    float y = get_float(&quot;y: &quot;);

    // Realizar a divis√£o
    printf(&quot;x / y = %.50f\n&quot;, x / y);
}
</code></pre>
<p>Com <code>%50f</code>, podemos especificar o n√∫mero de casas decimais exibidas.
Hmm, agora obtemos ...</p>
<pre><code>x: 1
y: 10
x / y = 0.10000000149011611938476562500000000000000000000000
</code></pre>
<p>Acontece que isso √© chamado de <strong>imprecis√£o de ponto flutuante</strong>, onde n√£o temos bits suficientes para armazenar todos os valores poss√≠veis, ent√£o o computador precisa armazenar o valor mais pr√≥ximo poss√≠vel de 1 dividido por 10.</p>
<p>Podemos ver um problema semelhante em <code>overflow.c</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf(&quot;%i\n&quot;, i);
        sleep(1);
    }
}
</code></pre>
<p>Em nosso loop <code>for</code>, definimos <code>i</code> como <code>1</code> e dobramos seu valor com <code>*= 2</code>. (E continuaremos fazendo isso para sempre, ent√£o n√£o h√° condi√ß√£o que verifiquemos.)
Tamb√©m usamos a fun√ß√£o <code>sleep</code> de <code>unistd.h</code> para pausar nosso programa a cada vez.
Agora, quando executamos este programa, vemos o n√∫mero ficando cada vez maior, at√© que:</p>
<pre><code>1073741824
overflow.c:6:25: erro em tempo de execu√ß√£o: estouro de inteiro assinado: 1073741824 * 2 n√£o pode ser representado no tipo &#x27;int&#x27;
-2147483648
0
0
...
</code></pre>
<p>Acontece que nosso programa reconheceu que um inteiro assinado (um inteiro com sinal positivo ou negativo) n√£o poderia armazenar aquele pr√≥ximo valor e exibiu um erro. Em seguida, como tentou dobrar mesmo assim, <code>i</code> se tornou um n√∫mero negativo e depois 0.
Esse problema √© chamado de <strong>estouro de inteiro</strong>, onde um inteiro s√≥ pode ser t√£o grande antes de ficar sem bits e &quot;voltar ao in√≠cio&quot;. Podemos imaginar adicionando 1 a 999 em decimal. O √∫ltimo d√≠gito se torna 0, carregamos o 1, ent√£o o pr√≥ximo d√≠gito se torna 0 e obtemos 1000. Mas se tiv√©ssemos apenas tr√™s d√≠gitos, ficar√≠amos com 000, pois n√£o h√° lugar para colocar o 1 final!
O problema do ano 2000 surgiu porque muitos programas armazenavam o ano do calend√°rio com apenas dois d√≠gitos, como 98 para 1998 e 99 para 1999. Mas quando o ano 2000 se aproximou, os programas teriam armazenado 00, causando confus√£o entre os anos 1900 e 2000.
Um avi√£o Boeing 787 tamb√©m tinha um bug, onde um contador no gerador sofre um estouro ap√≥s um certo n√∫mero de dias de opera√ß√£o cont√≠nua, pois o n√∫mero de segundos em que ele estava em execu√ß√£o n√£o poderia mais ser armazenado nesse contador.
Portanto, vimos alguns problemas que podem ocorrer, mas agora entendemos por que eles acontecem e como evit√°-los.
Com o conjunto de problemas desta semana, usaremos o Laborat√≥rio CS50, constru√≠do sobre o Sandbox CS50, para escrever alguns programas com tutoriais para nos orientar.</p>


        </main>
      </div>
    </div>
  </body>
</html>