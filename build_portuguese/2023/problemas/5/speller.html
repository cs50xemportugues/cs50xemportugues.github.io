<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci√™ncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <title>CS50x em Portugu√™s</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html">Este √© o CS50x</a>
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x"
        >O curso de Ci√™ncias da Computa√ß√£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">üò∫</strong></span
          ></a
        >
      </li>

      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1 <span class="semana-titulo">C</span></a
        >
      </li>

      
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2 <span class="semana-titulo">Vetores</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3 <span class="semana-titulo">Algoritmos</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4 <span class="semana-titulo">Mem√≥ria</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5 <span class="semana-titulo">Estruturas de Dados</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6 <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7 <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8 <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9 <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10 <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >Ciberseguran√ßa</a
        >
      </li>
    </ul>

  <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html">Projeto Final</a>
      </li>
    </ul> -->

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade Acad√™mica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          >Perguntas Frequentes</a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html">Equipe</a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html">Curr√≠culo do Curso</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/">Navegador SQLite</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/">Navegador PostgreSQL</a>
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >Documenta√ß√£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>

    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"></a></p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Speller</h1>
<div class="alert" data-alert="danger" role="alert"><p><strong>Leia esta especifica√ß√£o inteiramente antes de come√ßar para saber o que fazer e como faz√™-lo!</strong></p></div>
<p>Neste problema, voc√™ implementar√° um programa que verifica a ortografia de um arquivo, como no exemplo abaixo, usando uma tabela hash.</p>
<pre><code>$ ./speller texts/lalaland.txt
MISSPELLED WORDS

[...]
AHHHHHHHHHHHHHHHHHHHHHHHHHHHT
[...]
Shangri
[...]
fianc
[...]
Sebastian&#x27;s
[...]

WORDS MISSPELLED:
WORDS IN DICTIONARY:
WORDS IN TEXT:
TIME IN load:
TIME IN check:
TIME IN size:
TIME IN unload:
TIME IN TOTAL:
</code></pre>
<h2>Introdu√ß√£o</h2>
<p>Conecte-se ao <a href="https://code.cs50.io/">code.cs50.io</a>, clique na janela do seu terminal e execute o comando <code>cd</code>. Voc√™ deve ver que o prompt da sua janela de terminal se assemelha ao seguinte:</p>
<pre><code>$
</code></pre>
<p>Em seguida, execute o comando</p>
<pre><code>wget https://cdn.cs50.net/2022/fall/psets/5/speller.zip
</code></pre>
<p>para baixar um arquivo ZIP chamado de <code>speller.zip</code> em seu espa√ßo de c√≥digos.</p>
<p>Em seguida, execute o comando</p>
<pre><code>unzip speller.zip
</code></pre>
<p>para criar uma pasta chamada <code>speller</code>. Voc√™ n√£o precisa mais do arquivo ZIP, portanto voc√™ pode executar o comando:</p>
<pre><code>rm speller.zip
</code></pre>
<p>e responda &quot;y&quot; seguido de Enter no prompt para remover o arquivo ZIP que voc√™ baixou.</p>
<p>Agora digite</p>
<pre><code>cd speller
</code></pre>
<p>seguido de Enter para mover-se para dentro desse diret√≥rio. Seu prompt deve se parecer com o seguinte:</p>
<pre><code>speller/ $
</code></pre>
<p>Execute o comando <code>ls</code> e voc√™ ver√° alguns arquivos e pastas:</p>
<pre><code>dictionaries/  dictionary.c  dictionary.h  keys/  Makefile  speller.c  speller50  texts/
</code></pre>
<p>Se voc√™ tiver algum problema durante este processo, siga esses mesmos passos novamente e veja se consegue determinar onde errou!</p>
<h2>Distribui√ß√£o</h2>
<h3>Compreens√£o</h3>
<p>Teoricamente, em uma entrada de tamanho <em>n</em>, um algoritmo com tempo de execu√ß√£o <em>n</em> √© &quot;assintoticamente equivalente&quot;, em termos de <em>O</em>, a um algoritmo com tempo de execu√ß√£o de <em>2n</em>. Na verdade, ao descrever o tempo de execu√ß√£o de um algoritmo, normalmente nos concentramos no termo dominante (ou seja, mais impactante) (ou seja, <em>n</em> neste caso, j√° que <em>n</em> pode ser muito maior do que 2). No mundo real, no entanto, a verdade √© que <em>2n</em> parece duas vezes mais lento que <em>n</em>.</p>
<p>O desafio √† sua frente √© implementar o verificador ortogr√°fico mais r√°pido que puder! Mas quando dizemos &quot;o mais r√°pido&quot;, estamos falando de tempo &quot;real&quot;, n√£o assint√≥tico.</p>
<p>Em <code>speller.c </code>, criamos um programa projetado para verificar a ortografia de um arquivo ap√≥s carregar um dicion√°rio de palavras do disco na mem√≥ria. Esse dicion√°rio, enquanto isso, √© implementado em um arquivo chamado <code>dictionary.c</code>. (Poderia ser implementado em<code> speller.c</code>, mas √† medida que os programas se tornam mais complexos, geralmente √© conveniente dividi-los em v√°rios arquivos.) Os prot√≥tipos das fun√ß√µes do arquivo, enquanto isso, n√£o s√£o definidos em <code>dictionary.c</code> em si, mas sim em <code>dictionary.h</code>. Dessa forma, tanto <code>speller.c</code> quanto <code>dictionary.c</code> podem incluir o arquivo. Infelizmente, n√£o conseguimos implementar a parte de carregamento. Nem a parte de verifica√ß√£o. Ambos (e um pouco mais) deixamos com voc√™! Mas primeiro, uma turn√™.</p>
<h4><code>dictionary.h</code></h4>
<p>Abra o arquivo <code>dictionary.h</code> e voc√™ ver√° alguma nova sintaxe, incluindo algumas linhas que menciona <code>DICTIONARY_H</code>. N√£o se preocupe com isso, mas, se curioso, essas linhas apenas garantem que, mesmo que <code>dictionary.c</code> e <code>speller.c</code>(que voc√™ ver√° em um momento) incluam este arquivo, o <code>clang</code> o compilar√° apenas uma vez.</p>
<p>A seguir, observe como inclu√≠mos um arquivo chamado <code>stdbool.h</code>. Esse √© o arquivo no qual <code>bool</code> √© definido. Voc√™ n√£o precisou dele antes, j√° que a Biblioteca CS50 o incluia para voc√™.</p>
<p>Observe tamb√©m nosso uso de <code>#define</code>, uma &quot;diretiva de pr√©-processador&quot; que define uma &quot;constante&quot; chamada <code>LENGTH</code> que tem um valor de <code>45</code>. √â uma constante no sentido de que voc√™ n√£o pode (acidentalmente) alter√°-la em seu pr√≥prio c√≥digo. De fato, o <code>clang</code> substituir√° qualquer men√ß√£o a <code>LENGTH</code> em seu pr√≥prio c√≥digo por, literalmente, <code>45</code>. Em outras palavras, n√£o √© uma vari√°vel, apenas um truque de encontrar e substituir.</p>
<p>Finalmente, observe os prot√≥tipos de cinco fun√ß√µes: <code>check</code>, <code>hash</code>, <code>load</code>, <code>size</code> e <code>unload</code>. Observe como tr√™s deles recebem um ponteiro como argumento, de acordo com o <code>*</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">check</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">word</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">word</span><span class="p">);</span>
<span class="n">bool</span> <span class="nf">load</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dictionary</span><span class="p">);</span>
</code></pre></div></div>
<p>Lembre-se de que <code>char *</code> √© o que costum√°vamos chamar de <code>string</code>. Portanto, esses tr√™s prot√≥tipos s√£o essencialmente:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">check</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="n">word</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="n">word</span><span class="p">);</span>
<span class="n">bool</span> <span class="nf">load</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="n">dictionary</span><span class="p">);</span>
</code></pre></div></div>
<p>E, enquanto isso, <code>const</code> apenas diz que essas strings, quando passadas como argumentos, devem permanecer constantes; voc√™ n√£o poder√° alter√°-las, acidentalmente ou n√£o!</p>
<h4><code>dictionary.c</code></h4>
<p>Agora abra o arquivo <code>dictionary.c</code>. Observe como, no topo do arquivo, definimos uma <code>struct</code> chamada <code>node</code> que representa um n√≥ em uma tabela de hash. E declaramos uma array do ponteiro global, <code>table</code>, que representar√° (em breve) a tabela de hash que voc√™ usar√° para acompanhar as palavras no dicion√°rio. A array cont√©m <code>N</code> ponteiros de n√≥, e definimos <code>N</code> como <code>26</code> por enquanto, para corresponder √† fun√ß√£o <code>hash</code> padr√£o, conforme descrito abaixo. Voc√™ provavelmente desejar√° aumentar isso, dependendo de sua pr√≥pria implementa√ß√£o de <code>hash</code>.</p>
<p>Em seguida, observe que implementamos <code>load</code>, <code>check</code>, <code>size</code> e <code>unload</code>, mas apenas o suficiente para que o c√≥digo compile. Observe tamb√©m que implementamos a fun√ß√£o <code>hash</code> com um algoritmo de exemplo com base na primeira letra da palavra. Seu trabalho, em √∫ltima an√°lise, √© reimplementar essas fun√ß√µes da maneira mais inteligente poss√≠vel para que este verificador de ortografia funcione conforme anunciado. E r√°pido!</p>
<h4><code>speller.c</code></h4>
<p>Ok, agora abra o arquivo <code>speller.c</code> e passe algum tempo examinando o c√≥digo e os coment√°rios nele. Voc√™ n√£o precisar√° mudar nada neste arquivo, e n√£o precisar√° entend√™-lo na √≠ntegra, mas tente obter uma ideia de sua funcionalidade, mesmo assim. Observe como, por meio da fun√ß√£o chamada <code>getrusage</code>, &quot;teremos&quot; o &quot;benchmark&quot; (ou seja, cronometragem da execu√ß√£o de) suas implementa√ß√µes de <code>check</code>, <code>load</code>, <code>size</code> e <code>unload</code>. Al√©m disso, observe como passamos o <code>check</code>, palavra por palavra, em conte√∫do de algum arquivo a ser verificado ortograficamente. Por fim, relatamos cada palavra mal escrita naquele arquivo junto com muitas estat√≠sticas.</p>
<p>Observe, incidentalmente, que definimos o uso do <code>speller</code> como</p>
<pre><code>Uso: speller [dicion√°rio] texto
</code></pre>
<p>onde o <code>dicion√°rio</code> √© assumido como um arquivo contendo uma lista de palavras em min√∫sculas, uma por linha, e <code>texto</code> √© um arquivo a ser verificado a ortografia. Como os colchetes sugerem, a provis√£o de um <code>dicion√°rio</code> √© opcional; se esse argumento for omitido, o <code>speller</code> usar√° <code>dictionaries/large</code> por padr√£o. Em outras palavras, executar</p>
<pre><code>./speller texto
</code></pre>
<p>ser√° equivalente a executar</p>
<pre><code>./speller dictionaries/large text
</code></pre>
<p>onde <code>texto</code> √© o arquivo que voc√™ deseja verificar a ortografia. Isso tudo e claro, o <code>speller</code> n√£o poder√° carregar quaisquer dicion√°rios at√© voc√™ implementar <code>load</code> em <code>dictionary.c</code>! At√© ent√£o, voc√™ ver√° <code>Could not load</code>.</p>
<p>Dentro do dicion√°rio padr√£o, h√° 143.091 palavras, todas as quais devem ser carregadas na mem√≥ria! De fato, d√™ uma olhada nesse arquivo para ter uma ideia de sua estrutura e tamanho. Observe que toda palavra nesse arquivo aparece em min√∫sculo (at√© mesmo, por simplicidade, os nomes pr√≥prios e siglas). De cima para baixo, o arquivo √© classificado lexicograficamente, com apenas uma palavra por linha (cada uma das quais termina com <code>\n</code>). Nenhuma palavra tem mais de 45 caracteres, e nenhuma palavra aparece mais de uma vez. Durante o desenvolvimento, pode ser √∫til fornecer um <code>dicion√°rio</code> pr√≥prio ao <code>speller</code> que contenha muito menos palavras, para que voc√™ n√£o tenha dificuldade em depurar uma estrutura enorme na mem√≥ria. Em <code>dictionaries/small</code> existe um dicion√°rio desses. Para us√°-lo, execute</p>
<pre><code>./speller dictionaries/small text
</code></pre>
<p>onde <code>texto</code> √© o arquivo que voc√™ deseja verificar a ortografia. N√£o prossiga at√© ter certeza de que entende como o <code>speller</code> funciona!</p>
<p>√â prov√°vel que voc√™ n√£o tenha passado tempo suficiente examinando o <code>speller.c</code>. Volte uma casa e passe por ele novamente!</p>
<h4><code>texts/</code></h4>
<p>Para que voc√™ possa testar sua implementa√ß√£o do <code>speller</code>, tamb√©m fornecemos uma s√©rie de textos, entre eles, o roteiro de <em>La La Land</em>, o texto da Lei de Assist√™ncia Acess√≠vel, tr√™s milh√µes de bytes de Tolstoy, algumas passagens dos <em>Federalist Papers</em> e Shakespeare e mais. Para que voc√™ saiba o que esperar, abra e examine cada um desses arquivos, que est√£o em um diret√≥rio chamado <code>texts</code> dentro do seu diret√≥rio <code>pset5</code>.</p>
<p>Agora, como voc√™ deve saber depois de ter lido o <code>speller.c</code> cuidadosamente, a sa√≠da do <code>speller</code>, se executada com, digamos,</p>
<pre><code>./speller texts/lalaland.txt
</code></pre>
<p>ir√° se assemelhar eventualmente ao abaixo.</p>
<p>Abaixo segue alguns exemplos de palavras mal escritas que voc√™ ver√°. E por n√£o querer estragar a divers√£o, omitimos nossas pr√≥prias estat√≠sticas por agora.</p>
<pre><code>PALAVRAS MAL ESCRITAS

[...]
AHHHHHHHHHHHHHHHHHHHHHHHHHHHT
[...]
Shangri
[...]
fianc
[...]
Sebastian&#x27;s
[...]

PALAVRAS MAL ESCRITAS:
PALAVRAS NO DICION√ÅRIO:
PALAVRAS NO TEXTO:
TEMPO EM load:
TEMPO EM check:
TEMPO EM tamanho:
TEMPO EM unload:
TEMPO EM TOTAL:
</code></pre>
<p><code>TEMPO EM load</code> representa o n√∫mero de segundos que o <code>speller</code> passa executando sua implementa√ß√£o de <code>load</code>. <code>TEMPO EM check</code> representa o n√∫mero de segundos que o <code>speller</code> passa, no total, executando sua implementa√ß√£o de <code>check</code>. <code>TEMPO EM tamanho</code> representa o n√∫mero de segundos que o <code>speller</code> passa executando sua implementa√ß√£o de <code>size</code>. <code>TEMPO EM unload</code> representa o n√∫mero de segundos que o <code>speller</code> passa executando sua implementa√ß√£o de <code>unload</code>. <code>TEMPO EM TOTAL</code> √© a soma dessas quatro medidas.</p>
<p>Observe que esses tempos podem variar ligeiramente em execu√ß√µes diferentes do <code>speller</code>, dependendo do que mais sua √°rea de trabalho est√° fazendo, mesmo que voc√™ n√£o altere seu c√≥digo.</p>
<p>Ali√°s, para ficar claro, &quot;mal escritas&quot; significa apenas que alguma palavra n√£o est√° no <code>dicion√°rio</code> fornecido.</p>
<h4><code>Makefile</code></h4>
<p>E, por √∫ltimo, lembre-se de que o <code>make</code> automatiza a compila√ß√£o do seu c√≥digo para que voc√™ n√£o precise executar o <code>clang</code> manualmente junto com um monte de chaves. No entanto, √† medida que seus programas crescem em tamanho, o <code>make</code> n√£o poder√° inferir mais do contexto como compilar seu c√≥digo; voc√™ precisar√° come√ßar a dizer ao <code>make</code> como compilar seu programa, principalmente quando envolve v√°rios arquivos de origem (ou seja, <code>.c</code>), como no caso deste problema. E ent√£o usaremos um <code>Makefile</code>, um arquivo de configura√ß√£o que diz ao <code>make</code> exatamente o que fazer. Abra o <code>Makefile</code>, e voc√™ ver√° quatro linhas:</p>
<ol>
<li>A primeira linha diz ao <code>make</code> para executar as linhas subsequentes sempre que voc√™ mesmo executar <code>make speller</code> (ou apenas <code>make</code>).</li>
<li>A segunda linha diz ao <code>make</code> como compilar <code>speller.c</code> em c√≥digo de m√°quina (ou seja, <code>speller.o</code>).</li>
<li>A terceira linha diz ao <code>make</code> como compilar <code>dictionary.c</code> em c√≥digo de m√°quina (ou seja, <code>dictionary.o</code>).</li>
<li>A quarta linha diz ao <code>make</code> para vincular <code>speller.o</code> e <code>dictionary.o</code> em um arquivo chamado <code>speller</code>.</li>
</ol>
<p><strong>Certifique-se de compilar <code>speller</code> executando o <code>make speller</code> (ou apenas <code>make</code>). Executar <code>make dictionary</code> n√£o funcionar√°!</strong></p>
<h2>Especifica√ß√£o</h2>
<p>Tudo bem, o desafio agora para voc√™ √© implementar, em ordem, <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> e <code>unload</code> da maneira mais eficiente poss√≠vel usando uma tabela hash, de tal forma que <code>TIME IN load</code>, <code>TIME IN check</code>, <code>TIME IN size</code> e <code>TIME IN unload</code> sejam minimizados. Certamente, n√£o √© √≥bvio o que significa ser minimizado, j√° que essas refer√™ncias certamente variar√£o √† medida que voc√™ alimentar o <code>speller</code> com diferentes valores para <code>dictionary</code> e para <code>text</code>. Mas a√≠ est√° o desafio, se n√£o a divers√£o, desse problema. Este problema √© sua chance de projetar. Embora convidemos voc√™ a minimizar o espa√ßo, o seu inimigo final √© o tempo. Mas antes de come√ßar, algumas especifica√ß√µes de nossa parte.</p>
<ul>
<li>Voc√™ n√£o pode alterar <code>speller.c</code> ou <code>Makefile</code>.</li>
<li>Voc√™ pode alterar <code>dictionary.c</code> (e, de fato, deve faz√™-lo para concluir as implementa√ß√µes de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> e <code>unload</code>), mas n√£o pode alterar as declara√ß√µes (ou seja, prot√≥tipos) de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> ou <code>unload</code>. Voc√™ pode, no entanto, adicionar novas fun√ß√µes e vari√°veis (locais ou globais) a <code>dictionary.c</code>.</li>
<li>Voc√™ pode alterar o valor de <code>N</code> em <code>dictionary.c</code>, para que sua tabela hash possa ter mais buckets.</li>
<li>Voc√™ pode alterar <code>dictionary.h</code>, mas n√£o pode alterar as declara√ß√µes de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> ou <code>unload</code>.</li>
<li>Sua implementa√ß√£o de <code>check</code> deve ser insens√≠vel a mai√∫sculas e min√∫sculas. Em outras palavras, se <code>foo</code> estiver no dicion√°rio, ent√£o <code>check</code> deve retornar verdadeiro para qualquer capitaliza√ß√£o do mesmo; nenhum dos <code>foo</code>, <code>foO</code>, <code>fOo</code>, <code>fOO</code>, <code>fOO</code>, <code>Foo</code>, <code>FoO</code>, <code>FOo</code> e <code>FOO</code> devem ser considerados como ignorados.</li>
<li>Com rela√ß√£o √† capitaliza√ß√£o, sua implementa√ß√£o de <code>check</code> s√≥ deve retornar <code>true</code> para as palavras que realmente estiverem no <code>dictionary</code>. Tenha cuidado para n√£o codificar palavras comuns (por exemplo, <code>a</code>), para que n√£o venhamos a passar para sua implementa√ß√£o um <code>dictionary</code> sem essas mesmas palavras. Al√©m disso, somente os possessivos permitidos s√£o aqueles que realmente est√£o no <code>dictionary</code>. Em outras palavras, mesmo que <code>foo</code> esteja no <code>dictionary</code>, <code>check</code> deve retornar <code>false</code> para <code>foo&#x27;s</code> se <code>foo&#x27;s</code> tamb√©m n√£o estiver no <code>dictionary</code>.</li>
<li>Voc√™ pode pressupor que qualquer <code>dictionary</code> passado para o seu programa ter√° a mesma estrutura que a nossa, classificada em ordem alfab√©tica de cima para baixo com uma palavra por linha, cada uma das quais termina com <code>\n</code>. Voc√™ tamb√©m pode assumir que o <code>dictionary</code> conter√° pelo menos uma palavra, que nenhuma palavra ter√° mais de <code>LENGTH</code> (uma constante definida em <code>dictionary.h</code>) caracteres, que nenhuma palavra aparecer√° mais de uma vez, que cada palavra conter√° apenas caracteres alfab√©ticos min√∫sculos e possivelmente apostrofes, e que nenhuma palavra come√ßar√° com um ap√≥strofo.</li>
<li>Voc√™ pode pressupor que o <code>check</code> s√≥ receber√° palavras que contenham caracteres alfab√©ticos (mai√∫sculos ou min√∫sculos) e possivelmente apostrofes.</li>
<li>Seu corretor ortogr√°fico pode somente receber <code>text</code> e, opcionalmente, <code>dictionary</code> como entrada. Embora voc√™ possa estar inclinado (particularmente se √© mais experiente) a ‚Äúpre-processar‚Äù nosso dicion√°rio padr√£o para derivar uma ‚Äúfun√ß√£o hash ideal‚Äù para ele, voc√™ n√£o pode salvar a sa√≠da de qualquer pr√©-processamento em disco com o intuito de carreg√°-la novamente na mem√≥ria em execu√ß√µes subsequentes do verificador ortogr√°fico para ganhar uma vantagem.</li>
<li>Seu corretor ortogr√°fico n√£o deve vazar mem√≥ria. Certifique-se de verificar vazamentos com <code>valgrind</code>.</li>
<li><strong>A fun√ß√£o hash que voc√™ escreve deve ser sua, n√£o aquela que voc√™ procura online.</strong> H√° muitas maneiras de implementar uma fun√ß√£o hash al√©m de usar o primeiro caractere (ou caracteres) de uma palavra. Considere uma fun√ß√£o hash que usa a soma dos valores ASCII ou o comprimento de uma palavra. Uma boa fun√ß√£o hash tende a reduzir as ‚Äúcolis√µes‚Äù e tem uma distribui√ß√£o bastante uniforme em ‚Äúbuckets‚Äù da tabela hash.</li>
</ul>
<p>Ok, prontos para come√ßar?</p>
<ul>
<li>Implemente <code>load</code>.</li>
<li>Implemente <code>hash</code>.</li>
<li>Implemente <code>size</code>.</li>
<li>Implemente <code>check</code>.</li>
<li>Implemente <code>unload</code>.</li>
</ul>
<h2>Guias</h2>
<p>Observe que h√° 6 v√≠deos na playlist abaixo.</p>
<div class="alert" data-alert="danger" role="alert"><p>Embora o guia de Speller indique que √© razo√°vel usar uma fun√ß√£o hash encontrada on-line, este v√≠deo √© de uma vers√£o anterior do problema em que permitimos isso. Conforme a especifica√ß√£o acima, a fun√ß√£o hash que voc√™ escrever deve ser sua; voc√™ <strong>n√£o pode</strong> usar uma fun√ß√£o hash que encontrar on-line. Certifique-se de citar quaisquer fontes externas que voc√™ tenha referenciado ao escrever sua fun√ß√£o hash.</p></div>
<div class="ratio ratio-16x9" data-video=""><iframe allow="aceler√¥metro; autoplay; encrypted-media; girosc√≥pio; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/_z57x5PGF4w?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T382T4b6jjwX_qbU23E_Unwcz"></iframe></div>
<h2>Dicas</h2>
<p>Para comparar duas strings ignorando as diferen√ßas entre letras mai√∫sculas e min√∫sculas, voc√™ pode usar a fun√ß√£o <a href="https://man.cs50.io/3/strcasecmp"><code>strcasecmp</code></a>, declarada em <code>strings.h</code>! Voc√™ tamb√©m deve garantir que sua fun√ß√£o de hash n√£o leve em considera√ß√£o as diferen√ßas entre letras mai√∫sculas e min√∫sculas, para que as palavras &quot;foo&quot; e &quot;FOO&quot; tenham o mesmo valor de hash.</p>
<p>Por fim, certifique-se de liberar toda mem√≥ria alocada em <code>load</code> ao implementar a fun√ß√£o <code>unload</code>! Lembre-se de que <code>valgrind</code> √© seu novo melhor amigo. Saiba que <code>valgrind</code> verifica vazamentos de mem√≥ria enquanto seu programa est√° em execu√ß√£o, ent√£o, certifique-se de fornecer argumentos na linha de comando caso queira que <code>valgrind</code> analise <code>speller</code> enquanto voc√™ usa um dicion√°rio e/ou texto espec√≠fico, como abaixo. √â melhor usar um texto curto, sen√£o <code>valgrind</code> pode demorar bastante para rodar.</p>
<pre><code>valgrind ./speller texts/cat.txt
</code></pre>
<p>Se voc√™ executar <code>valgrind</code> sem especificar um <code>texto</code> para <code>speller</code>, suas implementa√ß√µes de <code>load</code> e <code>unload</code> n√£o ser√£o chamadas (e, portanto, n√£o ser√£o analisadas).</p>
<p>Se n√£o tiver certeza de como interpretar a sa√≠da do <code>valgrind</code>, basta pedir ajuda ao <code>help50</code>:</p>
<pre><code>help50 valgrind ./speller texts/cat.txt
</code></pre>
<h2>Testando</h2>
<p>Como verificar se o programa est√° identificando as palavras incorretas? Bem, voc√™ pode consultar a chave de respostas que est√° no diret√≥rio <code>keys</code>, que est√° dentro do diret√≥rio <code>speller</code>. Por exemplo, dentro do arquivo <code>keys/lalaland.txt</code>, h√° todas as palavras que o seu programa <em>deveria</em> considerar como incorretas.</p>
<p>Ent√£o, voc√™ pode executar seu programa em um texto em uma janela e, em outra janela, executar a solu√ß√£o da equipe no mesmo texto, como abaixo.</p>
<pre><code>./speller texts/lalaland.txt
./speller50 texts/lalaland.txt
</code></pre>
<p>E ent√£o voc√™ pode comparar as janelas visualmente lado a lado. Por√©m, isso pode ficar tedioso rapidamente. Portanto, voc√™ pode querer redirecionar a sa√≠da do programa para um arquivo, como abaixo.</p>
<pre><code>./speller texts/lalaland.txt &gt; student.txt
./speller50 texts/lalaland.txt &gt; staff.txt
</code></pre>
<p>Em seguida, voc√™ pode comparar ambos os arquivos lado a lado na mesma janela com um programa como <code>diff</code>, como abaixo.</p>
<pre><code>diff -y student.txt staff.txt
</code></pre>
<p>Ou ent√£o, para economizar tempo, voc√™ pode comparar a sa√≠da do seu programa (supondo que voc√™ redirecionou-a para, por exemplo, <code>student.txt</code>) com uma das chaves de resposta sem executar a solu√ß√£o da equipe, como abaixo.</p>
<pre><code>diff -y student.txt keys/lalaland.txt
</code></pre>
<p>Se a sa√≠da do seu programa corresponder √†s da equipe, o <code>diff</code> exibir√° duas colunas que devem ser id√™nticas, exceto talvez pelos tempos de execu√ß√£o na parte inferior. Entretanto, se as colunas diferirem, voc√™ ver√° um <code>&gt;</code> ou <code>|</code> onde elas diferem. Por exemplo, se voc√™ vir</p>
<pre><code>MISSPELLED WORDS                                                MISSPELLED WORDS

TECHNO                                                          TECHNO
L                                                               L
                                                              &gt; Thelonious
Prius                                                           Prius
                                                              &gt; MIA
L                                                               L
</code></pre>
<p>isso significa que seu programa (cuja sa√≠da est√° √† esquerda) n√£o considera que <code>Thelonious</code> ou <code>MIA</code> sejam palavras incorretas, mesmo que a sa√≠da da equipe (√† direita) considere, como √© mostrado pela aus√™ncia de, digamos, <code>Thelonious</code> na coluna da esquerda e pela presen√ßa de <code>Thelonious</code> na coluna da direita.</p>
<h3><code>check50</code></h3>
<p>Para testar seu c√≥digo de maneira menos manual (embora ainda n√£o exaustiva), voc√™ tamb√©m pode executar o comando abaixo.</p>
<pre><code>check50 cs50/problems/2023/x/speller
</code></pre>
<p>Observe que <code>check50</code> tamb√©m verifica vazamentos de mem√≥ria, portanto, certifique-se de que voc√™ tenha executado o <code>valgrind</code> tamb√©m.</p>
<h3>style50</h3>
<p>Execute o comando abaixo para avaliar o estilo de seu c√≥digo usando o <code>style50</code>.</p>
<pre><code>style50 dictionary.c
</code></pre>
<h2>Solu√ß√£o da equipe</h2>
<p>Como avaliar a velocidade (e a corre√ß√£o) do seu c√≥digo? Bem, como sempre, sinta-se a vontade para brincar com a solu√ß√£o da equipe e comparar seus resultados, como abaixo.</p>
<pre><code>./speller50 texts/lalaland.txt
</code></pre>
<h2>Enviar</h2>
<p>No seu terminal, execute o comando abaixo para enviar seu trabalho.</p>
<pre><code>submit50 cs50/problems/2023/x/speller&quot;
</code></pre>


        </main>
      </div>
    </div>
  </body>
</html>