<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci√™ncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <title>CS50x em Portugu√™s</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html">Este √© o CS50x</a>
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x"
        >O curso de Ci√™ncias da Computa√ß√£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">üò∫</strong></span
          ></a
        >
      </li>

      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1 <span class="semana-titulo">C</span></a
        >
      </li>

      
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2 <span class="semana-titulo">Vetores</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3 <span class="semana-titulo">Algoritmos</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4 <span class="semana-titulo">Mem√≥ria</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5 <span class="semana-titulo">Estruturas de Dados</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6 <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7 <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8 <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9 <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10 <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >Ciberseguran√ßa</a
        >
      </li>
    </ul>

  <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html">Projeto Final</a>
      </li>
    </ul> -->

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade Acad√™mica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          >Perguntas Frequentes</a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html">Equipe</a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html">Curr√≠culo do Curso</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/">Navegador SQLite</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/">Navegador PostgreSQL</a>
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >Documenta√ß√£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>

    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"></a></p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Filtro</h1>
<p>Implemente um programa que aplique filtros a arquivos BMP conforme abaixo.</p>
<pre><code>$ ./filter -r IMAGEM.bmp REFLETIDA.bmp
</code></pre>
<p>onde <code>IMAGEM.bmp</code> √© o nome do arquivo de imagem e <code>REFLETIDA.bmp</code> √© o nome atribu√≠do a um arquivo de imagem de sa√≠da, agora refletida.</p>
<h2>Contexto</h2>
<h3>Bitmaps</h3>
<p>A maneira mais simples de representar uma imagem √© com uma grade de pixels (ou pontos), cada um dos quais pode ter uma cor diferente. Para imagens em preto e branco, portanto, precisamos de 1 bit por pixel, j√° que 0 pode representar preto e 1 pode representar branco, como o exemplo abaixo.</p>
<p><img src="https://cs50.harvard.edu/x/2023/psets/4/filter/more/bitmap.png" alt="um bitmap simples" /></p>
<p>Nesse sentido, ent√£o, uma imagem √© apenas um bitmap (ou seja, um mapa de bits). Para imagens mais coloridas, voc√™ simplesmente precisa de mais bits por pixel. Um formato de arquivo (como <a href="https://pt.wikipedia.org/wiki/BMP">BMP</a>, <a href="https://pt.wikipedia.org/wiki/JPEG">JPEG</a> ou <a href="https://pt.wikipedia.org/wiki/PNG">PNG</a>) que suporte &quot;cor de 24 bits&quot; usa 24 bits por pixel (o BMP realmente suporta cores de 1, 4, 8, 16, 24 e 32 bits).</p>
<p>Um BMP de 24 bits usa 8 bits para indicar a quantidade de vermelho na cor de um pixel, 8 bits para indicar a quantidade de verde na cor de um pixel e 8 bits para indicar a quantidade de azul na cor de um pixel. Se os valores R, G e B de algum pixel em um BMP forem, digamos, <code>0xff</code>, <code>0x00</code> e <code>0x00</code> em hexadecimal, esse pixel √© puramente vermelho, pois <code>0xff</code> (tamb√©m conhecido como <code>255</code> em decimal) implica &quot;muito vermelho&quot;, enquanto <code>0x00</code> e <code>0x00</code> implicam &quot;nenhum verde&quot; e &quot;nenhum azul&quot;, respectivamente.</p>
<h3>Um pouco mais t√©cnico</h3>
<p>Lembre-se de que um arquivo √© apenas uma sequ√™ncia de bits, organizados de alguma maneira. Um arquivo BMP de 24 bits, ent√£o, √© basicamente apenas uma sequ√™ncia de bits, (quase) todos os quais representam a cor de um pixel. Mas um arquivo BMP tamb√©m cont√©m alguns &quot;metadados&quot;, informa√ß√µes como a altura e a largura de uma imagem. Esses metadados s√£o armazenados no in√≠cio do arquivo na forma de duas estruturas de dados geralmente referidas como &quot;cabe√ßalhos&quot;, para n√£o serem confundidas com os arquivos de cabe√ßalho C. (Ali√°s, esses cabe√ßalhos evolu√≠ram ao longo do tempo. Este problema usa a vers√£o mais recente do formato BMP da Microsoft, 4.0, que estreou com o Windows 95.)</p>
<p>O primeiro desses cabe√ßalhos, chamado <code>BITMAPFILEHEADER</code>, tem 14 bytes de comprimento. (Lembre-se de que 1 byte equivale a 8 bits.) O segundo desses cabe√ßalhos, chamado <code>BITMAPINFOHEADER</code>, tem 40 bytes de comprimento. Logo ap√≥s esses cabe√ßalhos vem o bitmap real: uma matriz de bytes, trios dos quais representam a cor de um pixel. No entanto, o BMP armazena esses trios ao contr√°rio (ou seja, como BGR), com 8 bits para azul, seguidos de 8 bits para verde, seguidos de 8 bits para vermelho. (Alguns BMPs tamb√©m armazenam todo o bitmap ao contr√°rio, com a linha superior da imagem no final do arquivo BMP. Mas armazenamos os BMPs deste conjunto de problemas conforme descrito aqui, com a primeira linha superior de cada bitmap e a √∫ltima linha inferior.) Em outras palavras, se convertermos o smiley de 1 bit acima para um smiley de 24 bits, substituindo o preto por vermelho, um BMP de 24 bits armazenaria este bitmap da seguinte forma, onde <code>0000ff</code> significa vermelho e <code>ffffff</code> significa branco. Destacamos em vermelho todas as inst√¢ncias de <code>0000ff</code>.</p>
<p><img src="https://cs50.harvard.edu/x/2023/psets/4/filter/more/red_smile.png" alt="sorriso vermelho" /></p>
<p>Como apresentamos esses bits da esquerda para a direita, de cima para baixo, em 8 colunas, voc√™ pode realmente ver o sorriso vermelho se der um passo para tr√°s.</p>
<p>Para ficar claro, lembre-se de que um d√≠gito hexadecimal representa 4 bits. Por conseguinte, <code>ffffff</code> em hexadecimal realmente significa <code>111111111111111111111111</code> em bin√°rio.</p>
<p>Observe que voc√™ pode representar um bitmap como uma matriz tridimensional de pixels: onde a imagem √© uma matriz de linhas, cada linha √© uma matriz de pixels. De fato, √© assim que escolhemos representar imagens bitmap neste problema.</p>
<h3>Filtro de Imagens</h3>
<p>O que significa, exatamente, filtrar uma imagem? Podemos pensar em filtrar uma imagem como pegar os pixels de uma imagem original e modificar cada pixel de tal forma que um efeito particular seja aparente na nova imagem resultante.</p>
<h4>Escala de Cinza</h4>
<p>Um filtro comum √© o filtro &quot;escala de cinza&quot;, onde queremos converter uma imagem em uma imagem preto e branco. Como isso funciona?</p>
<p>Lembre-se de que se os valores em vermelho, verde e azul forem todos definidos como <code>0x00</code> (hexadecimal para <code>0</code>), o pixel ser√° preto. E se todos os valores forem definidos como <code>0xff</code> (hexadecimal para <code>255</code>), o pixel ser√° branco. Desde que os valores em vermelho, verde e azul sejam iguais, o resultado ser√° tons variados de cinza ao longo da escala preto-branco, com valores mais altos significando tons mais claros (mais pr√≥ximos do branco) e valores mais baixos significando tons mais escuros (mais pr√≥ximos do preto).</p>
<p>Portanto, para converter um pixel em escala de cinza, precisamos apenas garantir que os valores vermelho, verde e azul sejam iguais. Mas como saber qual valor dar a eles? Bem, provavelmente √© razo√°vel esperar que, se os valores originais em vermelho, verde e azul forem todos altos, ent√£o o novo valor tamb√©m deve ser alto. E se os valores originais forem todos baixos, o novo valor tamb√©m deve ser baixo.</p>
<p>Na verdade, para garantir que cada pixel da nova imagem ainda tenha o mesmo brilho geral ou escurid√£o que a velha imagem, podemos tirar uma m√©dia dos valores vermelho, verde e azul para determinar que tom de cinza dar ao novo pixel.</p>
<p>Se aplicarmos isso a cada pixel da imagem, o resultado ser√° uma imagem convertida em escala de cinza.</p>
<h4>Reflex√£o</h4>
<p>Alguns filtros podem mover pixels. Refletir uma imagem, por exemplo, √© um filtro onde a imagem resultante √© o que voc√™ obteria colocando a imagem original na frente de um espelho. Portanto, quaisquer pixels no lado esquerdo da imagem devem acabar no lado direito e vice-versa.</p>
<p>Observe que todos os pixels originais da imagem ainda estar√£o presentes na imagem refletida, √© apenas que esses pixels podem ter rearranjado para estar em um lugar diferente na imagem.</p>
<h4>Desfoque</h4>
<p>Existem v√°rias maneiras de criar o efeito de desfoque ou suavidade em uma imagem. Para este problema, usaremos o &quot;desfoque de caixa&quot; que funciona tomando cada pixel e, para cada valor de cor, dando a ele um novo valor pela m√©dia dos valores de cores dos pixels vizinhos.</p>
<p>Considere a seguinte grade de pixels, onde cada pixel est√° numerado.</p>
<p><img src="https://cs50.harvard.edu/x/2023/psets/4/filter/more/grid.png" alt="a grid of pixels" /></p>
<p>O novo valor de cada pixel seria a m√©dia dos valores de todos os pixels que est√£o dentro de 1 linha e coluna do pixel original (formando uma caixa 3x3). Por exemplo, cada um dos valores de cor do pixel 6 seria obtido pela m√©dia dos valores de cor originais dos pixels 1, 2, 3, 5, 6, 7, 9, 10 e 11 (observe que o pixel 6 em si est√° inclu√≠do na m√©dia). Da mesma forma, os valores de cor do pixel 11 seriam obtidos pela m√©dia dos valores de cor dos pixels 6, 7, 8, 10, 11, 12, 14, 15 e 16.</p>
<p>Para um pixel na borda ou no canto, como o pixel 15, ainda procurar√≠amos todos os pixels dentro de 1 linha e coluna: nesse caso, os pixels 10, 11, 12, 14, 15 e 16.</p>
<h4>Bordas</h4>
<p>Em algoritmos de intelig√™ncia artificial para processamento de imagem, muitas vezes √© √∫til detectar bordas em uma imagem: linhas na imagem que criam um limite entre um objeto e outro. Uma maneira de alcan√ßar esse efeito √© aplicando o operador <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel</a> √† imagem.</p>
<p>Assim como no desfoque de imagem, a detec√ß√£o de bordas funciona tomando cada pixel e modificando-o com base na grade 3x3 de pixels que o rodeia. Mas em vez de apenas tirar a m√©dia dos nove pixels, o operador Sobel calcula o novo valor de cada pixel, fazendo uma soma ponderada dos valores dos pixels circundantes. E como as bordas entre objetos podem ocorrer em dire√ß√µes tanto vertical quanto horizontal, na verdade, voc√™ calcular√° duas somas ponderadas: uma para detectar bordas na dire√ß√£o x e outra para detectar bordas na dire√ß√£o y. Em particular, voc√™ usar√° os seguintes dois &quot;kernels&quot;:</p>
<p><img src="https://cs50.harvard.edu/x/2023/psets/4/filter/more/sobel.png" alt="Sobel kernels" /></p>
<p>Como interpretar esses kernels? Resumidamente, para cada um dos tr√™s valores de cor para cada pixel, calcularemos duas valores <code>Gx</code> e <code>Gy</code>. Para calcular <code>Gx</code> para o valor do canal vermelho de um pixel, por exemplo, pegaremos os valores vermelhos originais dos nove pixels que formam uma caixa 3x3 ao redor do pixel, multiplicaremos cada um deles pelo valor correspondente no kernel <code>Gx</code> e levaremos a soma dos valores resultantes.</p>
<p>Por que esses valores particulares para o kernel? Na dire√ß√£o <code>Gx</code>, por exemplo, estamos multiplicando os pixels √† direita do pixel alvo por um n√∫mero positivo e os pixels √† esquerda do pixel alvo por um n√∫mero negativo. Quando tiramos a soma, se os pixels √† direita forem de uma cor semelhante aos pixels √† esquerda, o resultado ser√° pr√≥ximo de 0 (os n√∫meros se cancelam).Mas se os pixels √† direita forem muito diferentes dos pixels √† esquerda, o valor resultante ser√° muito positivo ou muito negativo, indicando uma mudan√ßa na cor que provavelmente √© o resultado de um limite entre objetos. E um argumento semelhante √© v√°lido para calcular bordas na dire√ß√£o <code>y</code>.</p>
<p>Usando esses kernels, podemos gerar um valor <code>Gx</code> e <code>Gy</code> para cada um dos canais de vermelho, verde e azul para um pixel. Mas cada canal s√≥ pode ter um valor, n√£o dois: portanto, precisamos de alguma maneira de combinar <code>Gx</code> e <code>Gy</code> em um √∫nico valor. O algoritmo do filtro Sobel combina <code>Gx</code> e <code>Gy</code> em um valor final calculando a raiz quadrada de <code>Gx^2 + Gy^2</code>. E como os valores do canal s√≥ podem ter valores inteiros de 0 a 255, certifique-se de que o valor resultante seja arredondado para o inteiro mais pr√≥ximo e limitado a 255!</p>
<p>E quanto ao tratamento de pixels na borda ou no canto da imagem? Existem muitas maneiras de lidar com pixels na borda, mas, para os fins deste problema, pediremos que voc√™ trate a imagem como se houvesse uma borda preta s√≥lida de 1 pixel ao redor da borda da imagem: portanto, tentar acessar um pixel al√©m da borda da imagem deve ser tratado como um pixel preto s√≥lido (valores de 0 para cada vermelho, verde e azul). Isso efetivamente ignorar√° esses pixels de nossos c√°lculos de <code>Gx</code> e <code>Gy</code>.</p>
<h2>Come√ßando</h2>
<p>Fa√ßa login em [code.cs50.io] (https://code.cs50.io/), clique na sua janela do terminal e execute o comando <code>cd</code> . Voc√™ deve perceber que o prompt da sua janela do terminal se parece com o abaixo:</p>
<pre><code> $
 
</code></pre>
<p>Em seguida, execute</p>
<pre><code>wget https://cdn.cs50.net/2022/fall/psets/4/filter-more.zip
</code></pre>
<p>para baixar um arquivo ZIP chamado <code>filter-more.zip</code> em seu espa√ßo de c√≥digos.</p>
<p>Em seguida, execute</p>
<pre><code>unzip filter-more.zip
</code></pre>
<p>para criar uma pasta chamada <code>filter-more</code>. Voc√™ n√£o precisa mais do arquivo ZIP, portanto, execute</p>
<pre><code>rm filter-more.zip
</code></pre>
<p>e responda com &quot;y&quot; seguido de Enter no prompt para remover o arquivo ZIP que voc√™ baixou.</p>
<p>Agora digite</p>
<pre><code>cd filter-more
</code></pre>
<p>seguido de Enter para se mover para (&quot;abrir&quot;) esse diret√≥rio. Seu prompt agora deve se parecer com o abaixo.</p>
<pre><code>filter-more/ $
</code></pre>
<p>Execute <code>ls</code> isoladamente e voc√™ deve ver alguns arquivos: <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code> e <code>Makefile</code>. Voc√™ tamb√©m deve ver uma pasta chamada <code>images</code> com quatro arquivos BMP. Se voc√™ tiver algum problema, siga essas mesmas etapas novamente e veja se consegue determinar onde ocorreu o erro!</p>
<h2>Compreens√£o</h2>
<p>Agora vamos dar uma olhada em alguns dos arquivos fornecidos para voc√™ como c√≥digo de distribui√ß√£o para entender o que h√° dentro deles.</p>
<h3><code>bmp.h</code></h3>
<p>Abra <code>bmp.h</code> (clicando duas vezes nele no navegador de arquivos) e d√™ uma olhada.</p>
<p>Voc√™ ver√° defini√ß√µes dos cabe√ßalhos que mencionamos (<code>BITMAPINFOHEADER</code> e <code>BITMAPFILEHEADER</code>). Al√©m disso, esse arquivo define <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code> e <code>WORD</code>, tipos de dados normalmente encontrados no mundo da programa√ß√£o do Windows. Observe como eles s√£o apenas aliases para primitivos com os quais voc√™ est√° (esperan√ßosamente) familiarizado. Parece que <code>BITMAPFILEHEADER</code> e <code>BITMAPINFOHEADER</code> usam esses tipos.</p>
<p>Talvez o mais importante para voc√™, este arquivo tamb√©m define um <code>struct</code> chamado <code>RGBTRIPLE</code> que, simplesmente, &quot;encapsula&quot; tr√™s bytes: um azul, um verde e um vermelho (a ordem, lembre-se, na qual esperamos encontrar triples RGB no disco).</p>
<p>Por que essas <code>struct</code>s s√£o √∫teis? Bem, lembre-se de que um arquivo √© apenas uma sequ√™ncia de bytes (ou, em √∫ltima an√°lise, bits) no disco. Mas esses bytes geralmente est√£o ordenados de tal forma que os primeiros representam algo, os pr√≥ximos representam outra coisa e assim por diante. Existem &quot;formatos de arquivo&quot; porque o mundo padronizou o que os bytes significam. Agora, poder√≠amos simplesmente ler um arquivo do disco para a RAM como um grande array de bytes. E poder√≠amos simplesmente lembrar que o byte em <code>array[i]</code> representa uma coisa, enquanto o byte em <code>array[j]</code> representa outra. Mas por que n√£o dar nomes a alguns desses bytes para que possamos recuper√°-los da mem√≥ria com mais facilidade? √â precisamente isso que as <code>struct</code>s em <code>bmp.h</code> nos permitem fazer. Em vez de pensar em algum arquivo como uma longa sequ√™ncia de bytes, podemos pensar nele como uma sequ√™ncia de <code>struct</code>s.</p>
<h3><code>filter.c</code></h3>
<p>Agora, vamos abrir <code>filter.c</code>. Este arquivo j√° foi escrito para voc√™, mas h√° alguns pontos importantes que vale a pena observar aqui.</p>
<p>Em primeiro lugar, observe a defini√ß√£o de <code>filters</code> na linha 10. Essa string informa ao programa quais s√£o os argumentos permitidos na linha de comando do programa: <code>b</code>, <code>e</code>, <code>g</code> e <code>r</code>. Cada um deles especifica um filtro diferente que podemos aplicar √†s nossas imagens: desfoque, detec√ß√£o de borda, escala de cinza e reflex√£o.</p>
<p>As pr√≥ximas v√°rias linhas abrem um arquivo de imagem, certificam-se de que √© de fato um arquivo BMP e leem todas as informa√ß√µes de pixel em uma matriz 2D chamada <code>image</code>.</p>
<p>Role para baixo at√© a instru√ß√£o <code>switch</code> que come√ßa na linha 101. Observe que, dependendo do <code>filter</code> que escolhemos, uma fun√ß√£o diferente √© chamada: se o usu√°rio escolher o filtro <code>b</code>, o programa chama a fun√ß√£o <code>blur</code>; se <code>e</code>, ent√£o <code>edges</code> √© chamada; se <code>g</code>, ent√£o <code>grayscale</code> √© chamada; e se <code>r</code>, ent√£o <code>reflect</code> √© chamada. Observe tamb√©m que cada uma dessas fun√ß√µes recebe como argumentos a altura da imagem, a largura da imagem e a matriz 2D de pixels.</p>
<p>Essas s√£o as fun√ß√µes que voc√™ implementar√° em breve. Como voc√™ pode imaginar, o objetivo √© que cada uma dessas fun√ß√µes edite a matriz 2D de pixels de tal forma que o filtro desejado seja aplicado √† imagem.</p>
<p>As √∫ltimas linhas do programa levam a imagem resultante e a gravam em um novo arquivo de imagem.</p>
<h3><code>helpers.h</code></h3>
<p>A seguir, d√™ uma olhada em <code>helpers.h</code>. Este arquivo √© bastante curto e fornece apenas os prot√≥tipos de fun√ß√£o para as fun√ß√µes que voc√™ viu anteriormente.</p>
<p>Observe aqui que cada fun√ß√£o recebe como argumento uma matriz 2D chamada <code>image</code>, onde <code>image</code> √© um array com muitas linhas <code>height</code>, e cada linha √©, por si s√≥, outro array de <code>width</code> <code>RGBTRIPLE</code>s. Ent√£o, se <code>image</code> representa a imagem completa, ent√£o <code>image[0]</code> representa a primeira linha e <code>image[0][0]</code> representa o pixel no canto superior esquerdo da imagem.</p>
<h3><code>helpers.c</code></h3>
<p>Agora, abra <code>helpers.c</code>. √â aqui que a implementa√ß√£o das fun√ß√µes declaradas em <code>helpers.h</code> devem estar. Mas observe que, no momento, as implementa√ß√µes est√£o faltando! Essa parte depende de voc√™.</p>
<h3><code>Makefile</code></h3>
<p>Por fim, vamos dar uma olhada em <code>Makefile</code>. Este arquivo especifica o que deve acontecer quando executamos um comando no terminal como <code>make filter</code>. Enquanto programas que voc√™ pode ter escrito antes estavam confinados a apenas um arquivo, <code>filter</code> parece usar v√°rios arquivos: <code>filter.c</code> e <code>helpers.c</code>. Portanto, precisamos dizer ao <code>make</code> como compilar este arquivo.</p>
<p>Tente compilar <code>filter</code> por si mesmo indo para o terminal e executando</p>
<pre><code>$ make filter
</code></pre>
<p>Em seguida, voc√™ pode executar o programa digitando:</p>
<pre><code>$ ./filter -g images/yard.bmp out.bmp
</code></pre>
<p>que pega a imagem em <code>images/yard.bmp</code> e gera uma nova imagem chamada <code>out.bmp</code> depois de passar os pixels pela fun√ß√£o <code>grayscale</code>. No entanto, <code>grayscale</code> ainda n√£o faz nada, ent√£o a imagem de sa√≠da deve ficar igual √† imagem original do quintal.</p>
<h2>Especifica√ß√£o</h2>
<p>Implemente as fun√ß√µes em <code>helpers.c</code> para que um usu√°rio possa aplicar filtros de escala de cinza, reflex√£o, desfoque ou detec√ß√£o de borda em suas imagens.</p>
<ul>
<li>A fun√ß√£o <code>grayscale</code> deve pegar uma imagem e transform√°-la em uma vers√£o em preto e branco da mesma imagem.</li>
<li>A fun√ß√£o <code>reflect</code> deve pegar uma imagem e refleti-la horizontalmente.</li>
<li>A fun√ß√£o <code>blur</code> deve pegar uma imagem e transform√°-la em uma vers√£o desfocada da mesma imagem.</li>
<li>A fun√ß√£o <code>edges</code> deve pegar uma imagem e destacar as bordas entre objetos, de acordo com o operador Sobel.</li>
</ul>
<p>Voc√™ n√£o deve modificar nenhuma das assinaturas de fun√ß√£o, nem deve modificar nenhum outro arquivo al√©m de <code>helpers.c</code>.</p>
<h2>Walkthrough</h2>
<p><strong>Observe que h√° 5 v√≠deos nesta lista de reprodu√ß√£o.</strong></p>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/vsOsctDernw?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T382OwvMbZuaMGtD9wZkhnhYj"></iframe></div>
<h2>Uso</h2>
<p>Seu programa deve se comportar como nos exemplos abaixo. <code>INFILE.bmp</code> √© o nome da imagem de entrada e <code>OUTFILE.bmp</code> √© o nome da imagem resultante ap√≥s a aplica√ß√£o de um filtro.</p>
<pre><code>$ ./filter -g INFILE.bmp OUTFILE.bmp
</code></pre>
<pre><code>$ ./filter -r INFILE.bmp OUTFILE.bmp
</code></pre>
<pre><code>$ ./filter -b INFILE.bmp OUTFILE.bmp
</code></pre>
<pre><code>$ ./filter -e INFILE.bmp OUTFILE.bmp
</code></pre>
<h2>Dicas</h2>
<ul>
<li>Os valores dos componentes <code>rgbtRed</code>, <code>rgbtGreen</code> e <code>rgbtBlue</code> de um pixel s√£o todos n√∫meros inteiros. Certifique-se de arredondar quaisquer n√∫meros de ponto flutuante para o inteiro mais pr√≥ximo ao atribu√≠-los a um valor de pixel!</li>
</ul>
<h2>Testando</h2>
<p>Certifique-se de testar todos os seus filtros nos arquivos de bitmap de amostra fornecidos!</p>
<p>Execute o comando abaixo para avaliar a corre√ß√£o do seu c√≥digo usando <code>check50</code>. Mas certifique-se de compil√°-lo e test√°-lo tamb√©m!</p>
<pre><code>check50 cs50/problems/2023/x/filter/more
</code></pre>
<p>Execute o comando abaixo para avaliar o estilo do seu c√≥digo usando <code>style50</code>.</p>
<pre><code>style50 helpers.c
</code></pre>
<h2>Como Enviar</h2>
<p>No terminal, execute o comando abaixo para enviar seu trabalho.</p>
<pre><code>submit50 cs50/problems/2023/x/filter/more
</code></pre>


        </main>
      </div>
    </div>
  </body>
</html>