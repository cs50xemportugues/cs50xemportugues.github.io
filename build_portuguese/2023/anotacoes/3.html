<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="IntroduÃ§Ã£o Ã s faculdades intelectuais da ciÃªncia da computaÃ§Ã£o e a arte da programaÃ§Ã£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os tÃ³picos incluem abstraÃ§Ã£o, algoritmos, estruturas de dados, encapsulaÃ§Ã£o, gerenciamento de recursos, seguranÃ§a, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas sÃ£o inspiradas pelas Ã¡reas das artes, humanas, ciÃªncias sociais, e ciÃªncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script src="/static/highlight/highlight.min.js"></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="/static/highlight/styles/atom-one-light.min.css"
    />
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      code {
        border: 1px solid #dee2e6;
      }

      pre {
        padding: 0 !important;
      }

      /* Don't shrink these */
      code,
      pre {
        font-size: inherit;
      }
    </style>
    <title>CS50x em PortuguÃªs</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html"
        >Este Ã© o CS50x</a
      >
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x">O curso de CiÃªncias da ComputaÃ§Ã£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">ðŸ˜º</strong></span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1
          <span class="semana-titulo">C</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2
          <span class="semana-titulo"
            >Vetores</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3
          <span class="semana-titulo"
            >Algoritmos</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4
          <span class="semana-titulo"
            >MemÃ³ria</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5
          <span class="semana-titulo"
            >Estruturas de Dados</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6
          <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7
          <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8
          <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9
          <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10
          <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >CiberseguranÃ§a</a
        >
      </li>
    </ul>

    <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html"
          >Projeto Final</a
        >
      </li>
    </ul>

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/manual/index.html"
          >Manual do Programador</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/estilo.html"
          >Guia de Estilo</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade AcadÃªmica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          ></a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html"></a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html"
          >CurrÃ­culo do Curso</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/"
          >Navegador SQLite</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/"
          >Navegador PostgreSQL</a
        >
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >DocumentaÃ§Ã£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>
    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"
        ></a
      >
    </p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Aula 3</h1>
<ul>
<li><a href="#busca">Busca</a></li>
<li><a href="#big-o">Big O</a></li>
<li><a href="#busca-linear">Busca linear</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#ordenacao">OrdenaÃ§Ã£o</a></li>
<li><a href="#selection-sort">Selection sort</a></li>
<li><a href="#recursao">RecursÃ£o</a></li>
<li><a href="#merge-sort">Merge sort</a></li>
</ul>
<h2>Busca</h2>
<ul>
<li>
<p>Da Ãºltima vez, falamos sobre a memÃ³ria em um computador, ou RAM, e como nossos dados podem ser armazenados como variÃ¡veis individuais ou como arrays com vÃ¡rios itens, ou elementos.</p>
</li>
<li>
<p>Podemos pensar em um array com vÃ¡rios itens como uma fileira de armÃ¡rios, onde um computador sÃ³ pode abrir um armÃ¡rio para olhar um item, de cada vez.</p>
</li>
<li>
<p>Por exemplo, se quisermos verificar se um nÃºmero estÃ¡ em um array, com um algoritmo que recebe um array como entrada e produz um booleano como resultado, poderÃ­amos:</p>
<ul>
<li>
olhar em cada armÃ¡rio, ou em cada elemento, de cada vez, do inÃ­cio ao fim.<ul>
<li>Isso Ã© chamado de <strong>busca linear</strong>, onde nos movemos em uma linha, jÃ¡ que nosso array nÃ£o estÃ¡ ordenado.</li>
</ul>
</li>
<li>
comeÃ§ar no meio e mover para a esquerda ou direita, dependendo do que estamos procurando, se nosso array de itens estiver ordenado.<ul>
<li>Isso Ã© chamado de <strong>busca binÃ¡ria</strong>, jÃ¡ que podemos dividir nosso problema em dois a cada passo, como David fez com a lista telefÃ´nica na semana 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Podemos escrever um pseudocÃ³digo para a busca linear assim:</p>
<pre><code>Para i de 0 a nâ€“1
    Se o i-Ã©simo elemento for 50
        Retorna verdadeiro
Retorna falso
</code></pre>
<ul>
<li>Podemos rotular cada um dos armÃ¡rios, de <code>0</code> a <code>nâ€“1</code>, e verificÃ¡-los em ordem.</li>
</ul>
</li>
<li>
<p>Para a busca binÃ¡ria, nosso algoritmo pode ser assim:</p>
<pre><code>Se nÃ£o houver itens
    Retorna falso
Se o item do meio for 50
    Retorna verdadeiro
SenÃ£o, se 50 &lt; item do meio
    Buscar na metade esquerda
SenÃ£o, se 50 &gt; item do meio
    Buscar na metade direita
</code></pre>
<ul>
<li>Eventualmente, nÃ£o teremos mais partes do array sobrando (se o item que queremos nÃ£o estiver nele), entÃ£o podemos retornar <code>falso</code>.</li>
<li>Caso contrÃ¡rio, podemos procurar em cada metade, dependendo do valor do item do meio.</li>
</ul>
</li>
</ul>
<h2>Big O</h2>
<ul>
<li>Na semana 0, vimos diferentes tipos de algoritmos e seus tempos de execuÃ§Ã£o: <img src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" alt="grÃ¡fico com: &quot;tamanho do problema&quot; como eixo x; &quot;tempo para resolver&quot; como eixo y; linha reta vermelha e Ã­ngreme desde a origem atÃ© o topo do grÃ¡fico rotulada como &quot;n&quot;; linha reta amarela e menos Ã­ngreme desde a origem atÃ© o topo do grÃ¡fico rotulada como &quot;n/2&quot;; linha curva verde que fica cada vez menos Ã­ngreme desde a origem atÃ© a direita do grÃ¡fico rotulada como &quot;log_2 n&quot;" /></li>
<li>A maneira mais formal de descrever isso Ã© com a notaÃ§Ã£o big <em>O</em>, que podemos pensar como &quot;na ordem de&quot;. Por exemplo, se nosso algoritmo Ã© a busca linear, ele levarÃ¡ aproximadamente <em>O</em>(<em>n</em>) passos, &quot;na ordem de <em>n</em>&quot;. Na verdade, atÃ© mesmo um algoritmo que olha dois itens de cada vez e leva <em>n</em>/2 passos tem <em>O</em>(<em>n</em>). Isso ocorre porque, Ã  medida que <em>n</em> fica cada vez maior, apenas o termo maior, <em>n</em>, importa.</li>
<li>Da mesma forma, um tempo de execuÃ§Ã£o logarÃ­tmico Ã© <em>O</em>(log <em>n</em>), nÃ£o importando qual seja a base, jÃ¡ que isso Ã© apenas uma aproximaÃ§Ã£o do que acontece quando <em>n</em> Ã© muito grande.</li>
<li>
Existem alguns tempos de execuÃ§Ã£o comuns:<ul>
<li><em>O</em>(_n_2)</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>(busca linear)</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>(busca binÃ¡ria)</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Os cientistas da computaÃ§Ã£o tambÃ©m podem usar o big Î©, notaÃ§Ã£o big Omega, que Ã© o limite inferior do nÃºmero de passos para nosso algoritmo. (Big <em>O</em> Ã© o limite superior do nÃºmero de passos, ou o pior caso, e geralmente Ã© o que mais nos interessa.) Com a busca linear, por exemplo, o pior caso Ã© <em>n</em> passos, mas o melhor caso Ã© 1 passo, jÃ¡ que nosso item pode acontecer de ser o primeiro item que verificamos. O melhor caso para a busca binÃ¡ria tambÃ©m Ã© 1, jÃ¡ que nosso item pode estar no meio do array.</li>
<li>
E temos um conjunto similar dos tempos de execuÃ§Ã£o mais comuns em big Î©:<ul>
<li>Î©(_n_2)</li>
<li>Î©(<em>n</em> log <em>n</em>)</li>
<li>
Î©(<em>n</em>)<ul>
<li>(contando o nÃºmero de itens)</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>
Î©(1)<ul>
<li>(busca linear, busca binÃ¡ria)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Busca linear</h2>
<ul>
<li>
<p>Vamos dar uma olhada no <code>numbers.c</code>:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Um array de nÃºmeros
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // Busca por 50
    for (int i = 0; i &lt; 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf(&quot;Encontrado\n&quot;);
            return 0;
        }
    }
    printf(&quot;NÃ£o encontrado\n&quot;);
    return 1;
}
</code></pre>
<ul>
<li>Aqui, inicializamos um array com alguns valores e verificamos os itens do array um por vez, em ordem.</li>
<li>E em cada caso, dependendo se o valor foi encontrado ou nÃ£o, podemos retornar um cÃ³digo de saÃ­da de 0 (para sucesso) ou 1 (para falha).</li>
</ul>
</li>
<li>
<p>Podemos fazer o mesmo para nomes:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Um array de nomes
    string names[] = {&quot;EMMA&quot;, &quot;RODRIGO&quot;, &quot;BRIAN&quot;, &quot;DAVID&quot;};

    // Busca por EMMA
    for (int i = 0; i &lt; 4; i++)
    {
        if (strcmp(names[i], &quot;EMMA&quot;) == 0)
        {
            printf(&quot;Encontrado\n&quot;);
            return 0;
        }
    }
    printf(&quot;NÃ£o encontrado\n&quot;);
    return 1;
}
</code></pre>
<ul>
<li>NÃ£o podemos comparar strings diretamente, pois elas nÃ£o sÃ£o um tipo de dados simples, mas sim um array de muitos caracteres, e precisamos comparÃ¡-las de forma diferente. Felizmente, a biblioteca <code>string</code> possui uma funÃ§Ã£o <code>strcmp</code> que compara strings para nÃ³s e retorna <code>0</code> se forem iguais, entÃ£o podemos usÃ¡-la.</li>
</ul>
</li>
<li>
<p>Vamos tentar implementar uma lista telefÃ´nica com as mesmas ideias:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    string names[] = {&quot;EMMA&quot;, &quot;RODRIGO&quot;, &quot;BRIAN&quot;, &quot;DAVID&quot;};
    string numbers[] = {&quot;617â€“555â€“0100&quot;, &quot;617â€“555â€“0101&quot;, &quot;617â€“555â€“0102&quot;, &quot;617â€“555â€“0103&quot;};

    for (int i = 0; i &lt; 4; i++)
    {
        if (strcmp(names[i], &quot;EMMA&quot;) == 0)
        {
            printf(&quot;Encontrado %s\n&quot;, numbers[i]);
            return 0;
        }
    }
    printf(&quot;NÃ£o encontrado\n&quot;);
    return 1;
}
</code></pre>
<ul>
<li>Vamos usar strings para nÃºmeros de telefone, pois eles podem incluir formataÃ§Ã£o ou ser muito longos para serem representados como nÃºmeros.</li>
<li>Agora, se o nome em um certo Ã­ndice no array <code>names</code> corresponder Ã  pessoa que estamos procurando, retornaremos o nÃºmero de telefone no array <code>numbers</code>, no mesmo Ã­ndice. Mas isso significa que precisamos ter cuidado para garantir que cada nÃºmero corresponda ao nome em cada Ã­ndice, especialmente se adicionarmos ou removermos nomes e nÃºmeros.</li>
</ul>
</li>
</ul>
<h2>Ficheiros Markdown</h2>
<ul>
<li>
<p>Descobrimos que podemos criar os nossos prÃ³prios tipos de dados personalizados chamados de <strong>structs</strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  person;

  int main(void)
  {
      person people[4];

      people[0].name = &quot;EMMA&quot;;
      people[0].number = &quot;617â€“555â€“0100&quot;;

      people[1].name = &quot;RODRIGO&quot;;
      people[1].number = &quot;617â€“555â€“0101&quot;;

      people[2].name = &quot;BRIAN&quot;;
      people[2].number = &quot;617â€“555â€“0102&quot;;

      people[3].name = &quot;DAVID&quot;;
      people[3].number = &quot;617â€“555â€“0103&quot;;

      // Procurar por EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, &quot;EMMA&quot;) == 0)
          {
              printf(&quot;Encontrado: %s\n&quot;, people[i].number);
              return 0;
          }
      }
      printf(&quot;NÃ£o encontrado\n&quot;);
      return 1;
  }
</code></pre>
<ul>
<li>Podemos pensar em structs como contentores, dentro dos quais existem vÃ¡rios outros tipos de dados.</li>
<li>Aqui, criamos o nosso prÃ³prio tipo com uma struct chamada <code>person</code>, que terÃ¡ uma <code>string</code> chamada <code>name</code> e uma <code>string</code> chamada <code>number</code>. EntÃ£o, podemos criar um array desses tipos de struct e inicializar os valores dentro de cada um deles, usando uma nova sintaxe, <code>.</code>, para acessar as propriedades de cada <code>person</code>.</li>
<li>No nosso loop, agora podemos ter mais certeza de que o <code>number</code> corresponde ao <code>name</code>, pois eles sÃ£o do mesmo elemento <code>person</code>.</li>
</ul>
</li>
</ul>
<h2>OrdenaÃ§Ã£o</h2>
<ul>
<li>
<p>Se a nossa entrada for uma lista nÃ£o ordenada de nÃºmeros, existem vÃ¡rios algoritmos que podemos usar para produzir uma lista ordenada.</p>
</li>
<li>
<p>Com oito voluntÃ¡rios no palco com os seguintes nÃºmeros, podemos considerar trocar pares de nÃºmeros adjacentes como o primeiro passo.</p>
</li>
<li>
<p>Nossos voluntÃ¡rios comeÃ§am na seguinte ordem aleatÃ³ria:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Olhamos para os dois primeiros nÃºmeros e os trocamos para que fiquem em ordem:</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“ â€“
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>O prÃ³ximo par, <code>6</code> e <code>8</code>, jÃ¡ estÃ¡ em ordem, entÃ£o nÃ£o precisamos trocÃ¡-los.</p>
</li>
<li>
<p>O prÃ³ximo par, <code>8</code> e <code>5</code>, precisa ser trocado:</p>
<pre><code>  3 6 8 5 2 7 4 1
      â€“ â€“
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Continuamos atÃ© chegar ao final da lista:</p>
<pre><code>  3 6 5 2 8 7 4 1
          â€“ â€“
  3 6 5 2 7 8 4 1
            â€“ â€“
  3 6 5 2 7 4 8 1
              â€“ â€“
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>NÃ£o ordenamos ainda a nossa lista, mas estamos um pouco mais perto da soluÃ§Ã£o, porque o maior valor, <code>8</code>, foi movido para a extrema direita.</p>
</li>
<li>
<p>Repetimos isso com mais uma passagem pela lista:</p>
<pre><code>  3 6 5 2 7 4 1 8
  â€“ â€“
  3 6 5 2 7 4 1 8
    â€“ â€“
  3 5 6 2 7 4 1 8
      â€“ â€“
  3 5 2 6 7 4 1 8
        â€“ â€“
  3 5 2 6 7 4 1 8
          â€“ â€“
  3 5 2 6 4 7 1 8
              â€“ â€“
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Note que nÃ£o precisamos trocar o 3 e o 6, ou o 6 e o 7.</li>
</ul>
</li>
<li>
<p>Agora, o prÃ³ximo maior valor, <code>7</code>, foi movido para a extrema direita. Se repetirmos isso, mais e mais da lista ficarÃ¡ ordenada e, rapidamente, teremos uma lista totalmente ordenada.</p>
</li>
<li>
<p>Esse algoritmo Ã© chamado de <strong>ordenamento por bolha</strong>, onde valores grandes &quot;borbulham&quot; para a direita. O pseudocÃ³digo para isso pode parecer com:</p>
<pre><code>  Repetir nâ€“1 vezes
      Para i de 0 atÃ© nâ€“2
          Se os i-Ã©simo e i+1-Ã©simo elementos estiverem fora de ordem
              TrocÃ¡-los
</code></pre>
<ul>
<li>Como estamos comparando o i-Ã©simo e o i+1-Ã©simo elemento, sÃ³ precisamos ir atÃ© <em>n</em> â€“ 2 para o <code>i</code>. Em seguida, trocamos os dois elementos se eles estiverem fora de ordem.</li>
<li>E podemos parar depois de fazermos <em>n</em> â€“ 1 passagens, jÃ¡ que sabemos que os <em>n</em>-1 maiores elementos terÃ£o borbulhado para a direita.</li>
</ul>
</li>
<li>
<p>Temos <em>n</em> â€“ 2 etapas para o loop interno e <em>n</em> â€“ 1 loops, entÃ£o obtemos um total de <em>n_2 â€“ 3_n</em> + 2 etapas. Mas o termo dominante Ã© _n_2, Ã  medida que <code>n</code> fica cada vez maior, entÃ£o podemos dizer que o ordenamento por bolha Ã© <em>O</em>(_n_2).</p>
</li>
<li>
<p>JÃ¡ vimos tempos de execuÃ§Ã£o como os seguintes e, mesmo que a busca binÃ¡ria seja muito mais rÃ¡pida do que a busca linear, pode nÃ£o valer o custo Ãºnico de ordenar a lista primeiro, a menos que faÃ§amos muitas pesquisas ao longo do tempo:</p>
<ul>
<li>
<em>O</em>(_n_2)<ul>
<li>ordenamento por bolha</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>busca linear</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>busca binÃ¡ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>
<p>E Î© para o ordenamento por bolha ainda Ã© _n_2, jÃ¡ que ainda verificamos cada par de elementos para <em>n</em> â€“ 1 passagens.</p>
</li>
</ul>
<h2>OrdenaÃ§Ã£o por seleÃ§Ã£o</h2>
<ul>
<li>
<p>Podemos adotar uma abordagem diferente com o mesmo conjunto de nÃºmeros:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Primeiro, vamos analisar cada nÃºmero e lembrar o menor nÃºmero que encontramos. Em seguida, podemos trocÃ¡-lo com o primeiro nÃºmero da nossa lista, jÃ¡ que sabemos que Ã© o menor:</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“             â€“
  1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Agora sabemos que pelo menos o primeiro elemento da nossa lista estÃ¡ no lugar certo, entÃ£o podemos procurar o menor elemento entre os restantes e trocÃ¡-lo com o prÃ³ximo elemento nÃ£o ordenado (agora o segundo elemento):</p>
<pre><code>  1 3 8 5 2 7 4 6
    â€“     â€“
  1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Podemos repetir esse processo vÃ¡rias vezes, atÃ© obtermos uma lista ordenada.</p>
</li>
<li>
<p>Esse algoritmo Ã© chamado de <strong>ordenaÃ§Ã£o por seleÃ§Ã£o</strong> e poderÃ­amos escrever um pseudocÃ³digo assim:</p>
<pre><code>  Para i de 0 a nâ€“1
      Encontre o item mais pequeno entre o i-Ã©simo item e o Ãºltimo item
      Troque o item mais pequeno pelo i-Ã©simo item
</code></pre>
</li>
<li>
<p>Com notaÃ§Ã£o <em>O</em> grande, ainda temos uma complexidade de tempo de execuÃ§Ã£o de <em>O</em>(_n_2), pois estamos olhando aproximadamente para todos os <em>n</em> elementos para encontrar o menor e fazendo <em>n</em> passagens para ordenar todos os elementos.</p>
</li>
<li>
<p>Mais formalmente, podemos usar algumas fÃ³rmulas para mostrar que o maior fator Ã© realmente _n_2:</p>
<pre><code>  n + (n â€“ 1) + (n â€“ 2) + ... + 1
  n(n + 1)/2
  (n^2 + n)/2
  n^2/2 + n/2
  O(n^2)
</code></pre>
</li>
<li>
<p>Portanto, descobrimos que a ordenaÃ§Ã£o por seleÃ§Ã£o Ã© fundamentalmente igual Ã  ordenaÃ§Ã£o por bolha em termos de tempo de execuÃ§Ã£o:</p>
<ul>
<li>
<em>O</em>(_n_2)<ul>
<li>ordenaÃ§Ã£o por bolha, ordenaÃ§Ã£o por seleÃ§Ã£o</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>busca linear</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>busca binÃ¡ria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>
<p>O melhor caso, Î©, tambÃ©m Ã© _n_2.</p>
</li>
<li>
<p>Podemos voltar Ã  ordenaÃ§Ã£o por bolha e alterar seu algoritmo para algo assim, o que nos permitirÃ¡ parar cedo se todos os elementos estiverem ordenados:</p>
<pre><code>  Repita atÃ© nÃ£o haver trocas
      Para i de 0 a nâ€“2
          Se o i-Ã©simo e o (i+1)-Ã©simo elementos estiverem fora de ordem
              Troque-os
</code></pre>
<ul>
<li>
Agora, sÃ³ precisamos analisar cada elemento uma vez, entÃ£o o melhor caso agora Ã© Î©(<em>n</em>):<ul>
<li>
Î©(_n_2)<ul>
<li>ordenaÃ§Ã£o por seleÃ§Ã£o</li>
</ul>
</li>
<li>Î©(<em>n</em> log <em>n</em>)</li>
<li>
Î©(<em>n</em>)<ul>
<li>ordenaÃ§Ã£o por bolha</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>
Î©(1)<ul>
<li>busca linear, busca binÃ¡ria</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Podemos ver uma visualizaÃ§Ã£o online <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparando algoritmos de ordenaÃ§Ã£o</a> com animaÃ§Ãµes que mostram como os elementos se movem dentro dos arrays tanto para a ordenaÃ§Ã£o por bolha quanto para a ordenaÃ§Ã£o por seleÃ§Ã£o.</p>
</li>
</ul>
<h2>RecursÃ£o</h2>
<ul>
<li>
<p>Lembre-se de que na semana 0, tÃ­nhamos um pseudocÃ³digo para encontrar um nome em uma lista telefÃ´nica, onde tÃ­nhamos linhas nos dizendo para &quot;voltar&quot; e repetir algumas etapas:</p>
<pre><code>1  Pegue a lista telefÃ´nica
2  Abra no meio da lista telefÃ´nica
3  Olhe a pÃ¡gina
4  Se Smith estiver na pÃ¡gina
5      Ligue para Mike
6  SenÃ£o, se Smith estiver antes do meio da lista
7      Abra no meio da metade esquerda da lista
8      **Volte para a linha 3**
9  SenÃ£o, se Smith estiver depois do meio da lista
10     Abra no meio da metade direita da lista
11     **Volte para a linha 3**
12 SenÃ£o
13     Saia
</code></pre>
</li>
<li>
<p>Em vez disso, poderÃ­amos simplesmente repetir todo o nosso algoritmo na metade da lista restante:</p>
<pre><code>1  Pegue a lista telefÃ´nica
2  Abra no meio da lista telefÃ´nica
3  Olhe a pÃ¡gina
4  Se Smith estiver na pÃ¡gina
5      Ligue para Mike
6  SenÃ£o, se Smith estiver antes do meio da lista
7      **Pesquise na metade esquerda da lista**
8
9  SenÃ£o, se Smith estiver depois do meio da lista
10     **Pesquise na metade direita da lista**
11
12 SenÃ£o
13     Saia
</code></pre>
<ul>
<li>Isso parece um processo cÃ­clico que nunca terminarÃ¡, mas na verdade estamos dividindo o problema pela metade a cada vez e parando quando nÃ£o hÃ¡ mais lista restante.</li>
</ul>
</li>
<li>
<p><strong>RecursÃ£o</strong> ocorre quando uma funÃ§Ã£o ou algoritmo se refere a si mesma, como no novo pseudocÃ³digo acima.</p>
</li>
<li>
<p>Na semana 1 tambÃ©m implementamos uma &quot;pirÃ¢mide&quot; de blocos no seguinte formato:</p>
<pre><code>#
##
###
####
</code></pre>
<ul>
<li>
<p>E poderÃ­amos ter cÃ³digo iterativo como este:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

void draw(int h);

int main(void)
{
    // Obtenha a altura da pirÃ¢mide
    int altura = get_int(&quot;Altura: &quot;);

    // Desenhe a pirÃ¢mide
    draw(altura);
}

void draw(int h)
{
    // Desenhe uma pirÃ¢mide de altura h
    for (int i = 1; i &lt;= h; i++)
    {
        for (int j = 1; j &lt;= i; j++)
        {
            printf(&quot;#&quot;);
        }
        printf(&quot;\n&quot;);
    }
}
</code></pre>
<ul>
<li>Aqui, usamos <code>for</code> loops para imprimir cada bloco em cada linha.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mas observe que uma pirÃ¢mide de altura 4 Ã© na verdade uma pirÃ¢mide de altura 3, com uma linha extra de 4 blocos adicionados. E uma pirÃ¢mide de altura 3 Ã© uma pirÃ¢mide de altura 2, com uma linha extra de 3 blocos. Uma pirÃ¢mide de altura 2 Ã© uma pirÃ¢mide de altura 1, com uma linha extra de 2 blocos. E finalmente, uma pirÃ¢mide de altura 1 Ã© apenas uma pirÃ¢mide de altura 0, ou nada, com mais uma linha adicionada contendo um Ãºnico bloco.</p>
</li>
<li>
<p>Com essa ideia em mente, podemos escrever:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

void draw(int h);

int main(void)
{
    // Obtenha a altura da pirÃ¢mide
    int altura = get_int(&quot;Altura: &quot;);

    // Desenhe a pirÃ¢mide
    draw(altura);
}

void draw(int h)
{
    // Se nÃ£o houver nada para desenhar
    if (h == 0)
    {
        return;
    }

    // Desenhe uma pirÃ¢mide de altura h - 1
    draw(h - 1);

    // Desenhe mais uma linha com largura h
    for (int i = 0; i &lt; h; i++)
    {
        printf(&quot;#&quot;);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<ul>
<li>Agora, nossa funÃ§Ã£o <code>draw</code> primeiro chama a si mesma <strong>recursivamente</strong>, desenhando uma pirÃ¢mide de altura <code>h - 1</code>. Mas antes mesmo disso, precisamos parar se <code>h</code> for igual a 0, jÃ¡ que nÃ£o haverÃ¡ mais nada para ser desenhado.</li>
<li>Depois, desenhamos a prÃ³xima linha ou uma linha com largura <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>OrdenaÃ§Ã£o por intercalaÃ§Ã£o</h2>
<ul>
<li>
<p>Podemos aplicar a ideia de recursÃ£o Ã  ordenaÃ§Ã£o, com um outro algoritmo chamado ordenaÃ§Ã£o por intercalaÃ§Ã£o. O pseudocÃ³digo pode ser assim:</p>
<pre><code>  Se tiver apenas um item
    Retorne
  SenÃ£o
      Ordenar a metade esquerda dos itens
      Ordenar a metade direita dos itens
      Intercalar as metades ordenadas
</code></pre>
</li>
<li>
<p>Podemos entender melhor com uma lista nÃ£o ordenada como exemplo:</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Primeiramente, vamos ordenar a metade esquerda (os primeiros quatro elementos):</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  â€“ â€“ â€“ â€“
</code></pre>
</li>
<li>
<p>Para ordenar isso, precisamos primeiro ordenar a metade esquerda da metade esquerda:</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  â€“ â€“
</code></pre>
</li>
<li>
<p>Agora, temos apenas um item, <code>7</code>, na metade esquerda, e um item, <code>4</code>, na metade direita. EntÃ£o, vamos intercalar os dois, pegando o item menor de cada lista primeiro:</p>
<pre><code>  â€“ â€“ | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>Agora voltamos para a metade direita da metade esquerda e a ordenamos:</p>
<pre><code>  â€“ â€“ | â€“ â€“ | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Agora que ambas as metades da metade esquerda estÃ£o ordenadas, podemos intercalÃ¡-las. Olhamos para o inÃ­cio de cada lista e pegamos o <code>2</code> jÃ¡ que Ã© menor que <code>4</code>. Em seguida, pegamos o <code>4</code> pois Ã© o menor item do inÃ­cio de ambas as listas. Em seguida, pegamos o <code>5</code> e finalmente o <code>7</code>, dando-nos:</p>
<pre><code>  â€“ â€“ â€“ â€“ | 6 3 8 1
  â€“ â€“ â€“ â€“
  2 4 5 7
</code></pre>
</li>
<li>
<p>Agora vamos ordenar a metade direita da mesma maneira. Primeiro, a metade esquerda da metade direita:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | 8 1
  â€“ â€“ â€“ â€“ | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>Em seguida, a metade direita da metade direita:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | â€“ â€“
  â€“ â€“ â€“ â€“ | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>Podemos intercalar a metade direita agora:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
<li>
<p>Por fim, podemos intercalar ambas as metades da lista completa, seguindo os mesmos passos de antes. Observe que nÃ£o precisamos verificar todos os elementos de cada metade para encontrar o menor, pois sabemos que cada metade jÃ¡ estÃ¡ ordenada. Em vez disso, pegamos o elemento menor das duas metades no inÃ­cio de cada uma:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  2 4 5 7 | â€“ 3 6 8
  1


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ 4 5 7 | â€“ 3 6 8
  1 2


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ 4 5 7 | â€“ â€“ 6 8
  1 2 3


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ 5 7 | â€“ â€“ 6 8
  1 2 3 4


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ 7 | â€“ â€“ 6 8
  1 2 3 4   5


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ 7 | â€“ â€“ â€“ 8
  1 2 3 4   5 6


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ 8
  1 2 3 4   5 6 7


  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  1 2 3 4   5 6 7 8
</code></pre>
</li>
<li>
<p>Foram necessÃ¡rios diversos passos, mas na verdade foram menos passos do que nos outros algoritmos que vimos atÃ© agora. Dividimos nossa lista pela metade a cada vez, atÃ© estarmos &quot;ordenando&quot; oito listas com apenas um elemento cada:</p>
<pre><code>  7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
  4   7 | 2   5 | 3   6 | 1   8
  2   4   5   7 | 1   3   6   8
  1   2   3   4   5   6   7   8
</code></pre>
</li>
<li>
<p>Como nosso algoritmo dividiu o problema pela metade a cada vez, seu tempo de execuÃ§Ã£o Ã© logarÃ­tmico com <em>O</em>(log <em>n</em>). E depois de ordenarmos cada metade (ou metade de uma metade), precisamos intercalar todos os elementos, com <em>n</em> passos, jÃ¡ que precisamos olhar cada elemento uma vez.</p>
</li>
<li>
<p>Portanto, nosso tempo de execuÃ§Ã£o total Ã© <em>O</em>(<em>n</em> log <em>n</em>):</p>
<ul>
<li>
<em>O</em>(_n_2)<ul>
<li>ordenaÃ§Ã£o bolha (bubble sort), ordenaÃ§Ã£o por seleÃ§Ã£o (selection sort)</li>
</ul>
</li>
<li>
<em>O</em>(<em>n</em> log <em>n</em>)<ul>
<li>ordenaÃ§Ã£o por intercalaÃ§Ã£o (merge sort)</li>
</ul>
</li>
<li>
<em>O</em>(<em>n</em>)<ul>
<li>busca linear (linear search)</li>
</ul>
</li>
<li>
<em>O</em>(log <em>n</em>)<ul>
<li>busca binÃ¡ria (binary search)</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>
<p>Como log <em>n</em> Ã© maior que 1, mas menor que <em>n</em>, <em>n</em> log <em>n</em> estÃ¡ entre <em>n</em> (vezes 1) e _n_2.</p>
</li>
<li>
<p>O melhor caso, Î©, ainda Ã© <em>n</em> log <em>n</em>, pois ainda ordenamos cada metade primeiro e depois as intercalamos:</p>
<ul>
<li>
Î©(_n_2)<ul>
<li>ordenaÃ§Ã£o por seleÃ§Ã£o (selection sort)</li>
</ul>
</li>
<li>
Î©(<em>n</em> log <em>n</em>)<ul>
<li>ordenaÃ§Ã£o por intercalaÃ§Ã£o (merge sort)</li>
</ul>
</li>
<li>
Î©(<em>n</em>)<ul>
<li>ordenaÃ§Ã£o bolha (bubble sort)</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>
Î©(1)<ul>
<li>busca linear (linear search), busca binÃ¡ria (binary search)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Finalmente, hÃ¡ outra notaÃ§Ã£o, Î˜, Theta, que usamos para descrever os tempos de execuÃ§Ã£o dos algoritmos se o limite superior e o limite inferior forem os mesmos. Por exemplo, a ordenaÃ§Ã£o por intercalaÃ§Ã£o tem Î˜(<em>n</em> log <em>n</em>), jÃ¡ que o melhor e o pior caso requerem o mesmo nÃºmero de passos. E a ordenaÃ§Ã£o por seleÃ§Ã£o tem Î˜(_n_2).</p>
</li>
<li>
<p>Podemos ver uma <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualizaÃ§Ã£o final</a> dos algoritmos de ordenaÃ§Ã£o com um maior nÃºmero de entradas, executando ao mesmo tempo.</p>
</li>
</ul>


        </main>
      </div>
    </div>
  </body>
</html>