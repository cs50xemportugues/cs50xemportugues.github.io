<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci√™ncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script src="/static/highlight/highlight.min.js"></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="/static/highlight/styles/atom-one-light.min.css"
    />
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      code {
        border: 1px solid #dee2e6;
      }

      pre {
        padding: 0 !important;
      }

      /* Don't shrink these */
      code,
      pre {
        font-size: inherit;
      }
    </style>
    <title>CS50x em Portugu√™s</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html"
        >Este √© o CS50x</a
      >
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x">O curso de Ci√™ncias da Computa√ß√£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">üò∫</strong></span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1
          <span class="semana-titulo">C</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2
          <span class="semana-titulo"
            >Loops</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3
          <span class="semana-titulo"
            >Exceptions</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4
          <span class="semana-titulo"
            >Libraries</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5
          <span class="semana-titulo"
            >Unit Tests</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6
          <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7
          <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8
          <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9
          <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10
          <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >Ciberseguran√ßa</a
        >
      </li>
    </ul>

    <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html"
          >Projeto Final</a
        >
      </li>
    </ul>

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/manual/index.html"
          >Manual do Programador</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade Acad√™mica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          ></a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html"></a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html"
          >Curr√≠culo do Curso</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/"
          >Navegador SQLite</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/"
          >Navegador PostgreSQL</a
        >
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >Documenta√ß√£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>
    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"
        ></a
      >
    </p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Aula 4</h1>
<ul>
<li><a href="#hexadecimal">Hexadecimal</a></li>
<li><a href="#ponteiros">Ponteiros</a></li>
<li><a href="#string">string</a></li>
<li><a href="#comparar-e-copiar">Comparar e copiar</a></li>
<li><a href="#valgrind">valgrind</a></li>
<li><a href="#swap">Swap</a></li>
<li><a href="#layout-de-mem%C3%B3ria">Layout de mem√≥ria</a></li>
<li><a href="#get_int">get_int</a></li>
<li><a href="#arquivos">Arquivos</a></li>
<li><a href="#jpeg">JPEG</a></li>
</ul>
<h2>Hexadecimal</h2>
<ul>
<li>
<p>Na semana 0, aprendemos bin√°rio, um sistema de contagem com 0s e 1s.</p>
</li>
<li>
<p>Na semana 2, falamos sobre mem√≥ria e como cada byte possui um endere√ßo, ou identificador, para que possamos nos referir aonde nossas vari√°veis est√£o realmente armazenadas.</p>
</li>
<li>
<p>Acontece que, por conven√ß√£o, os endere√ßos de mem√≥ria utilizam o sistema de contagem <strong>hexadecimal</strong>, no qual existem 16 d√≠gitos, de 0 a 9 e A-F.</p>
</li>
<li>
<p>Lembre-se de que, em bin√°rio, cada d√≠gito representava uma pot√™ncia de 2:</p>
<pre><code>128 64 32 16  8  4  2  1
  1  1  1  1  1  1  1  1
</code></pre>
<ul>
<li>Com 8 bits, podemos contar at√© 255.</li>
</ul>
</li>
<li>
<p>Acontece que, em hexadecimal, podemos contar perfeitamente at√© 8 bits bin√°rios com apenas 2 d√≠gitos:</p>
<pre><code>16^1 16^0
   F    F
</code></pre>
<ul>
<li>Aqui, o <code>F</code> tem o valor de 15 em decimal, e cada lugar √© uma pot√™ncia de 16, ent√£o o primeiro <code>F</code> √© igual a 16^1 * 15 = 240, mais o segundo <code>F</code> com o valor de 16^0 * 15 = 15, resultando em um total de 255.</li>
</ul>
</li>
<li>
<p>E <code>0A</code> √© o mesmo que 10 em decimal, e <code>0F</code> o mesmo que 15. <code>10</code> em hexadecimal seria 16, e n√≥s dir√≠amos &quot;um zero em hexadecimal&quot; em vez de &quot;dez&quot;, se quis√©ssemos evitar confus√£o.</p>
</li>
<li>
<p>O sistema de cor RGB tamb√©m convencionalmente utiliza hexadecimal para descrever a quantidade de cada cor. Por exemplo, <code>000000</code> em hexadecimal significa 0 de vermelho, verde e azul, resultando na cor preta. E <code>FF0000</code> seria 255, ou o m√°ximo poss√≠vel, de vermelho. Com valores diferentes para cada cor, podemos representar milh√µes de cores diferentes.</p>
</li>
<li>
<p>Na escrita, tamb√©m podemos indicar que um valor est√° em hexadecimal prefixando-o com <code>0x</code>, como em <code>0x10</code>, onde o valor √© igual a 16 em decimal, ao inv√©s de 10.</p>
</li>
</ul>
<h2>Ponteiros</h2>
<ul>
<li>
<p>Podemos criar um valor <code>n</code> e imprimi-lo:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    printf(&quot;%i\n&quot;, n);
}
</code></pre>
</li>
<li>
<p>Na mem√≥ria do nosso computador, agora existem 4 bytes em algum lugar que possuem o valor bin√°rio de 50, rotulados como <code>n</code>:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/4/n.png" alt="grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno n embaixo" /></p>
</li>
<li>
<p>Acontece que, dos bilh√µes de bytes na mem√≥ria, esses bytes para a vari√°vel <code>n</code> come√ßam em algum endere√ßo √∫nico que pode se parecer com <code>0x12345678</code>.</p>
</li>
<li>
<p>Em C, na verdade podemos ver o endere√ßo com o operador <code>&amp;</code>, que significa &quot;obter o endere√ßo desta vari√°vel&quot;:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    printf(&quot;%p\n&quot;, &amp;n);
}
</code></pre>
<ul>
<li>E no CS50 IDE, podemos ver um endere√ßo como <code>0x7ffe00b3adbc</code>, onde este √© um local espec√≠fico na mem√≥ria do servidor.</li>
</ul>
</li>
<li>
<p>O endere√ßo de uma vari√°vel √© chamado de <strong>ponteiro</strong>, que podemos pensar como um valor que &quot;aponta&quot; para uma localiza√ß√£o na mem√≥ria. O operador <code>*</code> permite que &quot;vamos para&quot; a localiza√ß√£o apontada por um ponteiro.</p>
</li>
<li>
<p>Por exemplo, podemos imprimir <code>*&amp;n</code>, onde &quot;vamos para&quot; o endere√ßo de <code>n</code>, e isso imprimir√° o valor de <code>n</code>, <code>50</code>, j√° que esse √© o valor no endere√ßo de <code>n</code>:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    printf(&quot;%i\n&quot;, *&amp;n);
}
</code></pre>
</li>
<li>
<p>Tamb√©m precisamos usar o operador <code>*</code> (de uma forma infelizmente confusa) para declarar uma vari√°vel que queremos que seja um ponteiro:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
   int n = 50;
   int *p = &amp;n;
   printf(&quot;%p\n&quot;, p);
}
</code></pre>
<ul>
<li>Aqui, usamos <code>int *p</code> para declarar uma vari√°vel, <code>p</code>, que possui o tipo <code>*</code>, um ponteiro, para um valor do tipo <code>int</code>, um inteiro. Em seguida, podemos imprimir seu valor (algo como <code>0x12345678</code>), ou imprimir o valor em seu local com <code>printf(&quot;%i\n&quot;, *p);</code>.</li>
</ul>
</li>
<li>
<p>Na mem√≥ria do nosso computador, as vari√°veis poderiam ser assim:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/4/p.png" alt="grade representando bytes, com quatro caixas juntas contendo 50 com um pequeno 0x12345678 embaixo, e oito caixas juntas contendo 0x12345678 com um pequeno p embaixo" /></p>
<ul>
<li>Temos um ponteiro, <code>p</code>, com o endere√ßo de alguma vari√°vel.</li>
</ul>
</li>
<li>
<p>Podemos abstrair o valor real dos endere√ßos agora, j√° que eles ser√£o diferentes conforme declaramos vari√°veis em nossos programas, e simplismente pensar em <code>p</code> como &quot;apontando para&quot; algum valor:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/4/pointing.png" alt="uma caixa contendo p apontando para uma caixa menor contendo 50" /></p>
</li>
<li>
<p>Digamos que temos uma caixa de correio rotulada como &quot;123&quot;, com o n√∫mero &quot;50&quot; dentro dela. A caixa de correio seria <code>int n</code>, j√° que armazena um inteiro. Poder√≠amos ter outra caixa de correio com o endere√ßo &quot;456&quot;, dentro da qual est√° o valor &quot;123&quot;, que √© o endere√ßo de nossa outra caixa de correio. Isso seria <code>int *p</code>, j√° que √© um ponteiro para um inteiro.</p>
</li>
<li>
<p>Com a capacidade de usar ponteiros, podemos criar diferentes estruturas de dados, ou diferentes maneiras de organizar os dados na mem√≥ria que veremos na pr√≥xima semana.</p>
</li>
<li>
<p>Muitos sistemas de computador modernos s√£o &quot;64 bits&quot;, o que significa que eles usam 64 bits para endere√ßar a mem√≥ria, ent√£o um ponteiro ser√° de 8 bytes, o dobro de um inteiro de 4 bytes.</p>
</li>
</ul>
<h2>string</h2>
<ul>
<li>
<p>Podemos ter uma vari√°vel <code>string s</code> para um nome como <code>EMMA</code> e ser capaz de acessar cada caractere com <code>s[0]</code> e assim por diante:
<img src="https://cs50.harvard.edu/x/2020/notes/4/s_array.png" alt="caixas lado a lado, contendo: E rotulado como s[0], M rotulado como s[1], M rotulado como s[2], A rotulado como s[3], \0 rotulado como s[4]" /></p>
</li>
<li>
<p>Mas acontece que cada caractere √© armazenado na mem√≥ria em um byte com algum endere√ßo, e <code>s</code> √© na verdade apenas um ponteiro com o endere√ßo do primeiro caractere:
<img src="https://cs50.harvard.edu/x/2020/notes/4/s_pointer.png" alt="caixa contendo 0x123 rotulado como s, caixas lado a lado contendo E rotulado como 0x123, M rotulado como 0x124, M rotulado como 0x125, A rotulado como 0x126, \0 rotulado como 0x127" /></p>
</li>
<li>
<p>E como <code>s</code> √© apenas um ponteiro para o in√≠cio, apenas o <code>\0</code> indica o fim da string.</p>
</li>
<li>
<p>Na verdade, a Biblioteca CS50 define uma <code>string</code> com <code>typedef char *string</code>, o que significa apenas que queremos nomear um novo tipo, <code>string</code>, como um <code>char *</code>, ou um ponteiro para um caractere.</p>
</li>
<li>
<p>Vamos imprimir uma string:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string s = &quot;EMMA&quot;;
    printf(&quot;%s\n&quot;, s);
}
</code></pre>
</li>
<li>
<p>Isso √© familiar, mas podemos apenas dizer:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char *s = &quot;EMMA&quot;;
    printf(&quot;%s\n&quot;, s);
}
</code></pre>
<ul>
<li>Isso tamb√©m imprimir√° <code>EMMA</code>.</li>
</ul>
</li>
<li>
<p>Com <code>printf(&quot;%p\n&quot;, s);</code>, podemos imprimir <code>s</code> como seu valor como um ponteiro, como <code>0x42ab52</code>. (<code>printf</code> sabe acessar o endere√ßo e imprimir a string inteira quando usamos <code>%s</code> e passamos <code>s</code>, mesmo <code>s</code> apontando apenas para o primeiro caractere.)</p>
</li>
<li>
<p>Tamb√©m podemos tentar <code>printf(&quot;%p\n&quot;, &amp;s[0]);</code>, que √© o endere√ßo do primeiro caractere de <code>s</code> e √© exatamente o mesmo que imprimir <code>s</code>. E imprimir <code>&amp;s[1]</code>, <code>&amp;s[2]</code> e <code>&amp;s[3]</code> nos d√° os endere√ßos que s√£o os pr√≥ximos caracteres na mem√≥ria ap√≥s <code>&amp;s[0]</code>, como <code>0x42ab53</code>, <code>0x42ab54</code> e <code>0x42ab55</code>, exatamente um byte ap√≥s o outro.</p>
</li>
<li>
<p>E finalmente, se tentarmos <code>printf(&quot;%c\n&quot;, *s);</code>, obtemos um √∫nico caractere <code>E</code>, pois estamos acessando o endere√ßo armazenado em <code>s</code>, que √© o primeiro caractere da string.</p>
</li>
<li>
<p>Na verdade, <code>s[0]</code>, <code>s[1]</code> e <code>s[2]</code> mapeiam diretamente para <code>*s</code>, <code>*(s+1)</code> e <code>*(s+2)</code>, j√° que cada um dos pr√≥ximos caracteres est√° no endere√ßo do pr√≥ximo byte.</p>
</li>
</ul>
<h2>Compare e copie</h2>
<ul>
<li>
<p>Vamos olhar para <code>compare0</code>:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Obter dois inteiros
    int i = get_int(&quot;i: &quot;);
    int j = get_int(&quot;j: &quot;);

    // Comparar inteiros
    if (i == j)
    {
        printf(&quot;Iguais\n&quot;);
    }
    else
    {
        printf(&quot;Diferentes\n&quot;);
    }
}
</code></pre>
<ul>
<li>Podemos compilar e executar isso, e nosso programa funciona como esperado, com os mesmos valores dos dois inteiros nos dando &quot;Iguais&quot; e valores diferentes &quot;Diferentes&quot;.</li>
</ul>
</li>
<li>
<p>Em <code>compare1</code>, vemos que os mesmos valores de string fazem com que nosso programa imprima &quot;Diferentes&quot;:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Obter duas strings
    string s = get_string(&quot;s: &quot;);
    string t = get_string(&quot;t: &quot;);

    // Comparar endere√ßos das strings
    if (s == t)
    {
        printf(&quot;Iguais\n&quot;);
    }
    else
    {
        printf(&quot;Diferentes\n&quot;);
    }
}
</code></pre>
<ul>
<li>Com base no que sabemos agora sobre strings, isso faz sentido porque cada vari√°vel &quot;string&quot; est√° apontando para uma localiza√ß√£o diferente na mem√≥ria, onde o primeiro caractere de cada string est√° armazenado. Portanto, mesmo que os valores das strings sejam os mesmos, isso sempre imprimir√° &quot;Diferentes&quot;.</li>
<li>Por exemplo, nossa primeira string pode estar no endere√ßo 0x123, nossa segunda pode estar no 0x456, e <code>s</code> ser√° <code>0x123</code> e <code>t</code> ser√° <code>0x456</code>, ent√£o esses valores ser√£o diferentes.</li>
<li>E <code>get_string</code>, durante todo esse tempo, estava retornando apenas um <code>char *</code>, ou seja, um ponteiro para o primeiro caractere de uma string do usu√°rio.</li>
</ul>
</li>
<li>
<p>Agora vamos tentar copiar uma string:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string s = get_string(&quot;s: &quot;);

    string t = s;

    t[0] = toupper(t[0]);

    // Imprimir string duas vezes
    printf(&quot;s: %s\n&quot;, s);
    printf(&quot;t: %s\n&quot;, t);
}
</code></pre>
<ul>
<li>Obtemos uma string <code>s</code> e copiamos o valor de <code>s</code> para <code>t</code>. Em seguida, capitalizamos a primeira letra em <code>t</code>.</li>
<li>Mas quando executamos nosso programa, vemos que tanto <code>s</code> quanto <code>t</code> est√£o agora capitalizados.</li>
<li>Como definimos <code>s</code> e <code>t</code> com os mesmos valores, eles s√£o na verdade ponteiros para o mesmo caractere, ent√£o capitalizamos o mesmo caractere!</li>
</ul>
</li>
<li>
<p>Para realmente fazer uma c√≥pia de uma string, temos que fazer um pouco mais de trabalho:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char *s = get_string(&quot;s: &quot;);

    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i &lt; n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf(&quot;s: %s\n&quot;, s);
    printf(&quot;t: %s\n&quot;, t);
}
</code></pre>
<ul>
<li>Criamos uma nova vari√°vel, <code>t</code>, do tipo <code>char *</code>, com <code>char *t</code>. Agora, queremos apont√°-la para um novo bloco de mem√≥ria grande o suficiente para armazenar a c√≥pia da string. Com <code>malloc</code>, podemos alocar algum n√∫mero de bytes na mem√≥ria (que n√£o estejam sendo usados para armazenar outros valores) e passamos o n√∫mero de bytes que queremos. J√° conhecemos o comprimento de <code>s</code>, ent√£o adicionamos 1 para o caractere nulo terminador. Portanto, nossa √∫ltima linha de c√≥digo √© <code>char *t = malloc(strlen(s) + 1);</code>.</li>
<li>Em seguida, copiamos cada caractere, um de cada vez, e agora podemos capitalizar apenas a primeira letra de <code>t</code>. E usamos <code>i &lt; n + 1</code>, pois queremos ir at√© <code>n</code>, para garantir que copiamos o caractere terminador da string.</li>
<li>Na verdade, podemos usar tamb√©m a fun√ß√£o de biblioteca <code>strcpy</code> com <code>strcpy(t, s)</code> em vez do nosso loop, para copiar a string <code>s</code> para <code>t</code>. Para ficar claro, o conceito de &quot;string&quot; vem da linguagem C e √© bem suportado; as √∫nicas &quot;rodinhas de treinamento&quot; do CS50 s√£o o tipo <code>string</code> em vez de <code>char *</code> e a fun√ß√£o <code>get_string</code>.</li>
</ul>
</li>
<li>
<p>Se n√£o copiarmos o caractere nulo terminador, <code>\0</code>, e tentarmos imprimir nossa string <code>t</code>, <code>printf</code> continuar√° e imprimir√° os valores desconhecidos ou lixo que temos na mem√≥ria, at√© chegar a um <code>\0</code> ou travar completamente, pois nosso programa pode acabar tentando ler mem√≥ria que n√£o pertence a ele!</p>
</li>
</ul>
<h2>valgrind</h2>
<ul>
<li>
<p>Descobre-se que, ap√≥s terminarmos de usar a mem√≥ria alocada com <code>malloc</code>, devemos chamar <code>free</code> (como em <code>free(t)</code>), que informa ao computador que aqueles bytes n√£o s√£o mais √∫teis para nosso programa, ent√£o esses bytes na mem√≥ria podem ser reutilizados novamente.</p>
</li>
<li>
<p>Se continuarmos executando nosso programa e alocando mem√≥ria com <code>malloc</code>, mas nunca liberando a mem√≥ria ap√≥s terminarmos de us√°-la, teremos um <strong>vazamento de mem√≥ria</strong>, que deixar√° nosso computador mais lento e consumir√° cada vez mais mem√≥ria at√© que nosso computador fique sem mem√≥ria.</p>
</li>
<li>
<p><code>valgrind</code> √© uma ferramenta de linha de comando que podemos usar para executar nosso programa e verificar se ele tem vazamentos de mem√≥ria. Podemos executar o valgrind em nosso programa acima com <code>help50 valgrind ./copy</code> e ver, a partir da mensagem de erro, que na linha 10 alocamos mem√≥ria que nunca foi liberada (ou &quot;perdida&quot;).</p>
</li>
<li>
<p>Ent√£o, no final, podemos adicionar uma linha <code>free(t)</code>, que n√£o alterar√° o funcionamento do nosso programa, mas eliminar√° os erros do valgrind.</p>
</li>
<li>
<p>Vamos dar uma olhada no arquivo <code>memory.c</code>:</p>
<pre><code>// http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare

#include &lt;stdlib.h&gt;

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
</code></pre>
<ul>
<li>Este √© um exemplo da documenta√ß√£o do valgrind (valgrind √© uma ferramenta real, enquanto o help50 foi escrito especificamente para nos ajudar neste curso).</li>
<li>A fun√ß√£o <code>f</code> aloca mem√≥ria suficiente para 10 inteiros e armazena o endere√ßo em um ponteiro chamado <code>x</code>. Em seguida, tentamos definir o valor do 11¬∫ elemento de <code>x</code> com <code>x[10]</code> como <code>0</code>, o que ultrapassa o tamanho do array de mem√≥ria alocado para nosso programa. Isso √© chamado de <strong>buffer overflow</strong>, onde ultrapassamos os limites do buffer ou array e acessamos a mem√≥ria desconhecida.</li>
</ul>
</li>
<li>
<p>O valgrind tamb√©m nos informar√° que existe uma &quot;Escrita inv√°lida de tamanho 4&quot; na linha 8, onde de fato estamos tentando alterar o valor de um inteiro (de tamanho 4 bytes).</p>
</li>
<li>
<p>E durante todo esse tempo, a Biblioteca CS50 tem liberado a mem√≥ria alocada em <code>get_string</code> quando nosso programa termina!</p>
</li>
</ul>
<h2>Swap</h2>
<ul>
<li>
<p>Temos duas bebidas de cores diferentes, roxo e verde, cada uma em um copo. Queremos trocar as bebidas entre os dois copos, mas n√£o podemos fazer isso sem um terceiro copo para despejar uma das bebidas primeiro.</p>
</li>
<li>
<p>Agora, digamos que queiramos trocar os valores de dois inteiros.</p>
<pre><code>void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
</code></pre>
<ul>
<li>Com uma terceira vari√°vel para usar como espa√ßo de armazenamento tempor√°rio, podemos fazer isso facilmente, colocando <code>a</code> em <code>tmp</code>, depois <code>b</code> em <code>a</code> e, finalmente, o valor original de <code>a</code>, agora em <code>tmp</code>, em <code>b</code>.</li>
</ul>
</li>
<li>
<p>Mas, se tentarmos usar essa fun√ß√£o em um programa, n√£o veremos nenhuma mudan√ßa:</p>
<pre><code>#include &lt;stdio.h&gt;

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf(&quot;x √© %i, y √© %i\n&quot;, x, y);
    swap(x, y);
    printf(&quot;x √© %i, y √© %i\n&quot;, x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
</code></pre>
<ul>
<li>Acontece que a fun√ß√£o <code>swap</code> recebe suas pr√≥prias vari√°veis, <code>a</code> e <code>b</code>, quando s√£o passadas, que s√£o c√≥pias de <code>x</code> e <code>y</code>, portanto, alterar esses valores n√£o altera <code>x</code> e <code>y</code> na fun√ß√£o <code>main</code>.</li>
</ul>
</li>
</ul>
<h2>Layout de Mem√≥ria</h2>
<ul>
<li>
<p>Dentro da mem√≥ria do nosso computador, os diferentes tipos de dados que precisam ser armazenados para o nosso programa s√£o organizados em diferentes se√ß√µes:
<img src="https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png" alt="Grade com se√ß√µes, de cima para baixo: c√≥digo de m√°quina, globais, heap (com seta apontando para baixo), stack (com seta apontando para cima)" /></p>
<ul>
<li>A se√ß√£o <em>c√≥digo de m√°quina</em> √© o c√≥digo bin√°rio do nosso programa compilado. Quando executamos nosso programa, esse c√≥digo √© carregado no &quot;topo&quot; da mem√≥ria.</li>
<li><em>Globais</em> s√£o vari√°veis globais que declaramos em nosso programa ou outras vari√°veis compartilhadas que todo o nosso programa pode acessar.</li>
<li>A se√ß√£o <em>heap</em> √© uma √°rea vazia onde o <code>malloc</code> pode obter mem√≥ria livre para o nosso programa usar.</li>
<li>
A se√ß√£o <em>stack</em> √© usada pelas fun√ß√µes em nosso programa conforme elas s√£o chamadas. Por exemplo, nossa fun√ß√£o <code>main</code> est√° na parte inferior da stack e possui as vari√°veis locais <code>x</code> e <code>y</code>. A fun√ß√£o <code>swap</code>, quando chamada, tem seu pr√≥prio quadro, ou &quot;fatia&quot;, de mem√≥ria que est√° no topo do quadro de <code>main</code>, com as vari√°veis locais <code>a</code>, <code>b</code> e <code>tmp</code>:
<img src="https://cs50.harvard.edu/x/2020/notes/4/stack.png" alt="Se√ß√£o da stack com (a, b, tmp) acima de (x, y)" /><ul>
<li>Uma vez que a fun√ß√£o <code>swap</code> retorna, a mem√≥ria que ela estava usando √© liberada para a pr√≥xima chamada de fun√ß√£o, e perdemos qualquer coisa que fizemos, exceto os valores de retorno, e nosso programa volta para a fun√ß√£o que chamou <code>swap</code>.</li>
<li>Portanto, ao passar os endere√ßos de <code>x</code> e <code>y</code> de <code>main</code> para <code>swap</code>, podemos alterar os valores de <code>x</code> e <code>y</code>: <img src="https://cs50.harvard.edu/x/2020/notes/4/pointers.png" alt="Se√ß√£o da stack com (a, b, tmp) acima de (x, y), e a apontando para x e b apontando para y" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ao passar o endere√ßo de <code>x</code> e <code>y</code>, nossa fun√ß√£o <code>swap</code> pode realmente funcionar:</p>
<p>#include &lt;stdio.h&gt;</p>
<p>void swap(int *a, int *b);</p>
<p>int main(void)
{
int x = 1;
int y = 2;</p>
<pre><code>printf(&quot;x √© %i, y √© %i\n&quot;, x, y);
swap(&amp;x, &amp;y);
printf(&quot;x √© %i, y √© %i\n&quot;, x, y);
</code></pre>
<p>}</p>
<p>void swap(int *a, int *b)
{
int tmp = *a;
*a = *b;
*b = tmp;
}</p>
<ul>
<li>Os endere√ßos de <code>x</code> e <code>y</code> s√£o passados de <code>main</code> para <code>swap</code>, e usamos a sintaxe <code>int *a</code> para declarar que nossa fun√ß√£o <code>swap</code> recebe ponteiros. Salvamos o valor de <code>x</code> em <code>tmp</code> seguindo o ponteiro <code>a</code>, ent√£o pegamos o valor de <code>y</code> seguindo o ponteiro <code>b</code> e armazenamos isso no local para onde <code>a</code> est√° apontando (<code>x</code>). Por fim, armazenamos o valor de <code>tmp</code> no local apontado por <code>b</code> (<code>y</code>), e estamos prontos.</li>
</ul>
</li>
<li>
<p>Se chamarmos <code>malloc</code> muitas vezes, teremos um <strong>estouro do heap</strong>, onde ultrapassamos o tamanho do heap. Ou, se tivermos muitas fun√ß√µes sendo chamadas, teremos um <strong>estouro da stack</strong>, onde nossa stack tem muitos quadros de mem√≥ria alocados tamb√©m. E esses dois tipos de estouro geralmente s√£o conhecidos como estouros de buffer, ap√≥s os quais nosso programa (ou computador inteiro) pode travar.</p>
</li>
</ul>
<h2>get_int</h2>
<ul>
<li>
<p>Podemos implementar <code>get_int</code> n√≥s mesmos com uma fun√ß√£o da biblioteca C, <code>scanf</code>:</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)
{
int x;
printf(&quot;x: &quot;);
scanf(&quot;%i&quot;, &amp;x);
printf(&quot;x: %i\n&quot;, x);
}</p>
<ul>
<li><code>scanf</code> recebe um formato, <code>%i</code>, ent√£o a entrada √© &quot;escaneada&quot; para esse formato e o endere√ßo na mem√≥ria onde queremos que essa entrada v√°. Mas <code>scanf</code> n√£o possui muita verifica√ß√£o de erros, ent√£o talvez n√£o obtenhamos um n√∫mero inteiro.</li>
</ul>
</li>
<li>
<p>Podemos tentar obter uma string da mesma maneira:</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)
{
char *s = NULL;
printf(&quot;s: &quot;);
scanf(&quot;%s&quot;, s);
printf(&quot;s: %s\n&quot;, s);
}</p>
<ul>
<li>Mas na verdade n√£o alocamos nenhuma mem√≥ria para <code>s</code> (<code>s</code> √© <code>NULL</code>, ou n√£o est√° apontando para nada), ent√£o talvez queiramos chamar <code>char s[5]</code> para alocar um array de 5 caracteres para nossa string. Em seguida, <code>s</code> ser√° tratado como um ponteiro em <code>scanf</code> e <code>printf</code>.</li>
<li>Agora, se o usu√°rio digitar uma string com comprimento igual ou menor que 4, nosso programa funcionar√° com seguran√ßa. Mas se o usu√°rio digitar uma string mais longa, <code>scanf</code> pode estar tentando escrever al√©m do final de nosso array em mem√≥ria desconhecida, causando o travamento de nosso programa.</li>
</ul>
</li>
</ul>
<h2>Arquivos</h2>
<ul>
<li>
<p>Com a capacidade de usar ponteiros, tamb√©m podemos abrir arquivos:</p>
<pre><code>#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Abre o arquivo
    FILE *file = fopen(&quot;agenda.csv&quot;, &quot;a&quot;);

    // Obt√©m strings do usu√°rio
    char *nome = get_string(&quot;Nome: &quot;);
    char *numero = get_string(&quot;N√∫mero: &quot;);

    // Escreve as strings no arquivo
    fprintf(file, &quot;%s,%s\n&quot;, nome, numero);

    // Fecha o arquivo
    fclose(file);
}
</code></pre>
<ul>
<li><code>fopen</code> √© uma nova fun√ß√£o que podemos usar para abrir um arquivo. Ela retornar√° um ponteiro para um novo tipo, <code>FILE</code>, que podemos ler e escrever. O primeiro argumento √© o nome do arquivo e o segundo argumento √© o modo que queremos abrir o arquivo (<code>r</code> para ler, <code>w</code> para escrever e <code>a</code> para acrescentar, ou adicionar).</li>
<li>Depois de obtermos algumas strings, podemos usar <code>fprintf</code> para escrever no arquivo.</li>
<li>Por fim, fechamos o arquivo com <code>fclose</code>.</li>
</ul>
</li>
<li>
<p>Agora podemos criar nossos pr√≥prios arquivos CSV, arquivos de valores separados por v√≠rgula (como uma mini-planilha), de forma program√°tica.</p>
</li>
</ul>
<h1>JPEG</h1>
<ul>
<li>
<p>Tamb√©m podemos criar um programa que abre um arquivo e nos informa se √© um arquivo JPEG (imagem):</p>
<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    // Verifica o uso
    if (argc != 2)
    {
        return 1;
    }

    // Abre o arquivo
    FILE *file = fopen(argv[1], &quot;r&quot;);
    if (!file)
    {
        return 1;
    }

    // L√™ os primeiros tr√™s bytes
    unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    // Verifica os primeiros tr√™s bytes
    if (bytes[0] == 0xff &amp;&amp; bytes[1] == 0xd8 &amp;&amp; bytes[2] == 0xff)
    {
        printf(&quot;Talvez\n&quot;);
    }
    else
    {
        printf(&quot;N√£o\n&quot;);
    }

    // Fecha o arquivo
    fclose(file);
}
</code></pre>
<ul>
<li>Agora, se executarmos esse programa com <code>./jpeg brian.jpg</code>, nosso programa tentar√° abrir o arquivo especificado (verificando se realmente obtivemos um arquivo n√£o nulo) e ler os primeiros tr√™s bytes do arquivo com <code>fread</code>.</li>
<li>Podemos comparar os primeiros tr√™s bytes (em hexadecimal) com os tr√™s bytes necess√°rios para iniciar um arquivo JPEG. Se forem iguais, ent√£o nosso arquivo provavelmente √© um arquivo JPEG (embora outros tipos de arquivos ainda possam come√ßar com esses bytes). Mas, se eles n√£o forem iguais, sabemos que definitivamente n√£o √© um arquivo JPEG.</li>
</ul>
</li>
<li>
<p>Podemos usar essas habilidades para ler e escrever arquivos, em particular imagens, e modific√°-los alterando os bytes neles, no conjunto de problemas desta semana!</p>
</li>
</ul>


        </main>
      </div>
    </div>
  </body>
</html>