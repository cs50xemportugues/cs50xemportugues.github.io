<!DOCTYPE html>

<html lang="en-us">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:description"
      content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci√™ncias naturais. O curso culmina em um projeto final."
    />

    <meta property="og:image" content="" />
    <meta property="og:title" content="CS50" />
    <link
      href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821"
      rel="icon"
    />

    <script
      src="https://kit.fontawesome.com/df44463090.js"
      crossorigin="anonymous"
    ></script>

    <link
      href="/static/css/all.min.css"
      rel="stylesheet"
    />

    <link
      href="/static/css/page.css"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="/static/css/personalizado.css"
    />

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <title>CS50x em Portugu√™s</title>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: green">
  <header>
    <h1 data-id="this-is-cs50">
      <a href="/2023/index.html"
        >Este √© o CS50x</a
      >
    </h1>

    <p>
      <a href="https://cs50.harvard.edu/x">O curso de Ci√™ncias da Computa√ß√£o da Universidade de Harvard</a
      ><br />2023
    </p>
  </header>

  <button
    aria-controls="nav"
    aria-expanded="false"
    class="btn btn-sm collapsed d-md-none"
    data-target="aside &gt; nav"
    data-toggle="collapse"
  >
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/0.html"
          >Semana 0
          <span class="semana-titulo"
            >Scratch <strong class="text-white">üò∫</strong></span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/1.html"
          >Semana 1
          <span class="semana-titulo">C</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/2.html"
          >Semana 2
          <span class="semana-titulo"
            >Vetores</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/3.html"
          >Semana 3
          <span class="semana-titulo"
            >Algoritmos</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/4.html"
          >Semana 4
          <span class="semana-titulo"
            >Mem√≥ria</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/5.html"
          >Semana 5
          <span class="semana-titulo"
            >Estruturas de Dados</span
          ></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/6.html"
          >Semana 6
          <span class="semana-titulo">Python</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/7.html"
          >Semana 7
          <span class="semana-titulo">SQL</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/8.html"
          >Semana 8
          <span class="semana-titulo">HTML, CSS, JavaScript</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/9.html"
          >Semana 9
          <span class="semana-titulo">Flask</span></a
        >
      </li>

      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/semanas/10.html"
          >Semana 10
          <span class="semana-titulo">Emoji</span></a
        >
      </li>
    </ul>

    <ul class="fa-ul">
      <li data-marker="*" class="small">
        <span class="fa-li"><i class="fas fa-square"></i></span
        ><a href="/2023/semanas/ciberseguranca.html"
          >Ciberseguran√ßa</a
        >
      </li>
    </ul>

    <hr />
    <ul>
      <li data-marker="*">
        <a href="/2023/projeto_final.html"
          >Projeto Final</a
        >
      </li>
    </ul>

    <hr />

    <ul class="fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/manual/index.html"
          >Manual do Programador</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/honestidade.html"
          >Honestidade Acad√™mica</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/certificado.html"
          >Certificado CS50</a
        >
      </li>
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/perguntas_frequentes.html"
          >Perguntas Frequentes</a
        >
      </li>
      -->
      <!--
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/equipe.html">Equipe</a>
      </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="/2023/curriculo.html"
          >Curr√≠culo do Curso</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.me/cs50x">Boletim de Notas</a>
      </li>
    </ul>

    <hr />

    <ul class="small fa-ul">
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://cs50.dev">Visual Studio Code</a>
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://sqlitebrowser.org/"
          >Navegador SQLite</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://adminer.cs50.net/"
          >Navegador PostgreSQL</a
        >
      </li>
      <!--
            <li data-marker="*">
                <span class="fa-li"><i class="fas fa-circle"></i></span>
                <a href="https://man.cs50.io/">Manual CS50</a>
            </li>-->
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://docs.python.org/pt-br/3/search.html"
          >Documenta√ß√£o Python</a
        >
      </li>
      <li data-marker="*">
        <span class="fa-li"><i class="fas fa-circle"></i></span>
        <a href="https://pt.stackoverflow.com/">Stack Overflow</a>
      </li>
    </ul>

    <hr />

    <p style="font-size: initial">
      <a href="/2023/obrigado.html"
        ></a
      >
    </p>
  </nav>

  <footer></footer>
</aside>

        <main class="col-md markdown-body" style="margin-bottom: 286px">
          
<h1>Lecture 5</h1>
<ul>
<li><a href="#ponteiros">Pointers</a></li>
<li><a href="#redimensionando-matrizes">Redimensionando matrizes</a></li>
<li><a href="#estruturas-de-dados">Estruturas de dados</a></li>
<li><a href="#listas-encadeadas">Listas Encadeadas</a></li>
<li><a href="#mais-estruturas-de-dados">Mais estruturas de dados</a></li>
</ul>
<h2>Ponteiros</h2>
<ul>
<li>
<p>Na √∫ltima vez, aprendemos sobre ponteiros, <code>malloc</code> e outras ferramentas √∫teis para trabalhar com mem√≥ria.</p>
</li>
<li>
<p>Vamos revisar este trecho de c√≥digo:</p>
<pre><code>int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
</code></pre>
<ul>
<li>
<p>Aqui, as duas primeiras linhas de c√≥digo em nossa fun√ß√£o <code>main</code> est√£o declarando dois ponteiros, <code>x</code> e <code>y</code>. Em seguida, alocamos mem√≥ria suficiente para um <code>int</code> com <code>malloc</code> e armazenamos o endere√ßo retornado pelo <code>malloc</code> em <code>x</code>.</p>
</li>
<li>
<p>Com <code>*x = 42;</code>, vamos para o endere√ßo apontado por <code>x</code> e armazenamos o valor <code>42</code> nesse local.</p>
</li>
<li>
<p>A √∫ltima linha, no entanto, cont√©m um bug porque n√£o sabemos qual √© o valor de <code>y</code>, uma vez que nunca atribu√≠mos um valor a ele. Em vez disso, podemos escrever:</p>
<pre><code>y = x;
*y = 13;
</code></pre>
<ul>
<li>E isso far√° com que <code>y</code> aponte para o mesmo local que <code>x</code> e, em seguida, defina aquele valor para <code>13</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Damos uma olhada em um pequeno clipe, <a href="https://www.youtube.com/watch?v=3uLKjb973HU">Pointer Fun with Binky</a>, que tamb√©m explica esse trecho de c√≥digo de forma animada!</p>
</li>
</ul>
<h2>Redimensionando matrizes</h2>
<ul>
<li>
<p>Na segunda semana, aprendemos sobre matrizes, onde podemos armazenar o mesmo tipo de valor em uma lista, lado a lado. Mas precisamos declarar o tamanho das matrizes quando as criamos e, quando queremos aumentar o tamanho da matriz, a mem√≥ria ao seu redor pode ser ocupada por outros dados.</p>
</li>
<li>
<p>Uma solu√ß√£o pode ser alocar mais mem√≥ria em uma √°rea maior que esteja livre e mover nossa matriz para l√°, onde ela ter√° mais espa√ßo. Mas precisaremos copiar nossa matriz, o que se torna uma opera√ß√£o com tempo de execu√ß√£o de <em>O</em>(<em>n</em>), pois precisamos copiar cada um dos <em>n</em> elementos em uma matriz.</p>
</li>
<li>
<p>Podemos escrever um programa como o seguinte para fazer isso em c√≥digo:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    // Aqui, alocamos mem√≥ria suficiente para armazenar tr√™s inteiros, e nossa vari√°vel
    // lista apontar√° para o primeiro inteiro.
    int *lista = malloc(3 * sizeof(int));
    // Devemos verificar se alocamos mem√≥ria corretamente, j√° que o malloc pode
    // falhar em nos fornecer mem√≥ria livre suficiente.
    if (lista == NULL)
    {
        return 1;
    }

    // Com essa sintaxe, o compilador far√° a aritm√©tica de ponteiros para n√≥s e
    // calcular√° o byte na mem√≥ria que lista[0], lista[1] e lista[2] mapeiam,
    // j√° que os inteiros t√™m tamanho de 4 bytes.
    lista[0] = 1;
    lista[1] = 2;
    lista[2] = 3;

    // Agora, se quisermos redimensionar nossa matriz para conter 4 inteiros, tentaremos alocar
    // mem√≥ria suficiente para eles e temporariamente usaremos tmp para apontar para o primeiro:
    int *tmp = malloc(4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // Agora, copiamos os inteiros da matriz antiga para a nova matriz ...
    for (int i = 0; i &lt; 3; i++)
    {
        tmp[i] = lista[i];
    }

    // ... e adicionamos o quarto inteiro:
    tmp[3] = 4;

    // Devemos liberar a mem√≥ria original alocada para lista, √© por isso que precisamos de uma
    // vari√°vel tempor√°ria para apontar para a nova matriz ...
    free(lista);

    // ... e agora podemos definir nossa vari√°vel lista para apontar para a nova matriz que o
    // tmp aponta:
    lista = tmp;

    // Agora, podemos imprimir a nova matriz:
    for (int i = 0; i &lt; 4; i++)
    {
        printf(&quot;%i\n&quot;, lista[i]);
    }

    // Finalmente, liberamos a mem√≥ria da nova matriz.
    free(lista);
}
</code></pre>
</li>
<li>
<p>Acontece que existe uma fun√ß√£o √∫til chamada <code>realloc</code>, que permite realocar alguma mem√≥ria:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int *lista = malloc(3 * sizeof(int));
    if (lista == NULL)
    {
        return 1;
    }

    lista[0] = 1;
    lista[1] = 2;
    lista[2] = 3;

    // Aqui, passamos para realloc nossa matriz original, para qual lista aponta, e ela ir√°
    // retornar um novo endere√ßo para uma nova matriz, com os dados antigos copiados:
    int *tmp = realloc(lista, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }
    // Agora, tudo o que precisamos fazer √© lembrar a localiza√ß√£o da nova matriz:
    lista = tmp;

    lista[3] = 4;

    for (int i = 0; i &lt; 4; i++)
    {
        printf(&quot;%i\n&quot;, lista[i]);
    }

    free(lista);
}
</code></pre>
<p>'</p>
</li>
</ul>
<h2>Estruturas de dados</h2>
<ul>
<li><strong>Estruturas de dados</strong> s√£o constru√ß√µes de programa√ß√£o que nos permitem armazenar informa√ß√µes em diferentes layouts na mem√≥ria do nosso computador.</li>
<li>
Para construir uma estrutura de dados, precisamos de algumas ferramentas que vimos anteriormente:<ul>
<li><code>struct</code> para criar tipos de dados personalizados</li>
<li><code>.</code> para acessar propriedades em uma estrutura</li>
<li><code>*</code> para ir para um endere√ßo na mem√≥ria apontado por um ponteiro</li>
</ul>
</li>
</ul>
<h2>Listas Encadeadas</h2>
<ul>
<li>
<p>Com uma <strong>lista encadeada</strong>, podemos armazenar uma lista de valores que pode ser facilmente expandida, armazenando valores em diferentes partes da mem√≥ria:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/5/linked_list.png" alt="grade representando a mem√≥ria, com tr√™s caixas rotuladas com caixas vazias entre elas, cada uma rotulada por 1 0x123, 2 0x456 e 3 0x789" /></p>
<ul>
<li>Isso √© diferente de uma matriz, pois nossos valores n√£o est√£o mais pr√≥ximos um do outro na mem√≥ria.</li>
</ul>
</li>
<li>
<p>Podemos ligar nossa lista alocando, para cada elemento, mem√≥ria suficiente para o valor que queremos armazenar e o endere√ßo do pr√≥ximo elemento:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png" alt="tr√™s caixas, cada uma dividida em duas e rotulada (1 0x123 e 0x456), (2 0x456 e 0x789) e (3 0x789 e NULL)" /></p>
<ul>
<li>A prop√≥sito, <code>NUL</code> refere-se a <code>\0</code>, um caractere que termina uma string, e <code>NULL</code> refere-se a um endere√ßo de todos os zeros, ou um ponteiro nulo que podemos pensar como apontando para nenhum lugar.</li>
</ul>
</li>
<li>
<p>Ao contr√°rio do que podemos fazer com matrizes, n√£o podemos mais acessar elementos em uma lista encadeada aleatoriamente. Por exemplo, n√£o podemos mais acessar o quinto elemento da lista calculando onde ele est√°, em tempo constante. (Uma vez que sabemos que as matrizes armazenam elementos lado a lado, podemos adicionar 1, ou 4, ou o tamanho do nosso elemento, para calcular endere√ßos.) Em vez disso, precisamos seguir o ponteiro de cada elemento, um de cada vez. E precisamos alocar o dobro de mem√≥ria do que precis√°vamos antes para cada elemento.</p>
</li>
<li>
<p>No c√≥digo, podemos criar nossa pr√≥pria struct chamada <code>node</code> (como um n√≥ de um gr√°fico em matem√°tica), e precisamos armazenar tanto um <code>int</code> como um ponteiro para o pr√≥ximo <code>node</code> chamado <code>next</code>:</p>
<pre><code>typedef struct node
{
    int number;
    struct node *next;
}
node;
</code></pre>
<ul>
<li>Come√ßamos essa struct com <code>typedef struct node</code> para que possamos nos referir a um <code>node</code> dentro de nossa struct.</li>
</ul>
</li>
<li>
<p>Podemos construir uma lista encadeada no c√≥digo a partir de nossa struct. Primeiro, vamos querer lembrar de uma lista vazia, para que possamos usar o ponteiro nulo: <code>node *list = NULL;</code>.</p>
</li>
<li>
<p>Para adicionar um elemento, primeiro precisaremos alocar algum espa√ßo na mem√≥ria para um n√≥ e definir seus valores:</p>
<pre><code>node *n = malloc(sizeof(node));
// Queremos ter certeza de que malloc teve sucesso em obter mem√≥ria para n√≥s:
if (n != NULL)
{
    // Isto √© equivalente a (*n).number, onde primeiro vamos para o n√≥ apontado
    // por n e, em seguida, definimos a propriedade number. Em C, tamb√©m podemos
    // usar esta nota√ß√£o de seta:
    n-&gt;number = 2;
    // Em seguida, precisamos armazenar um ponteiro para o pr√≥ximo n√≥ em nossa lista, mas o
    // novo n√≥ n√£o vai apontar para nada (por enquanto):
    n-&gt;next = NULL;
}
</code></pre>
</li>
<li>
<p>Agora nossa lista pode apontar para esse n√≥: <code>list = n;</code>:<br />
<img src="https://cs50.harvard.edu/x/2020/notes/5/list_with_one_node.png" alt="uma caixa rotulada lista com seta para fora apontando para duas caixas conectadas, uma com 2 e outra vazia" /></p>
</li>
<li>
<p>Para adicionar √† lista, criaremos um novo n√≥ da mesma maneira, talvez com o valor 4. Mas agora precisamos atualizar o ponteiro em nosso primeiro n√≥ para apontar para ele.</p>
</li>
<li>
<p>Como nosso ponteiro <code>list</code> aponta apenas para o primeiro n√≥ (e n√£o podemos ter certeza de que a lista tem apenas um n√≥), precisamos ‚Äúseguir as migalhas‚Äù e seguir o ponteiro <code>next</code> de cada n√≥:</p>
<pre><code>// Crie um ponteiro tempor√°rio para o que list est√° apontando
node *tmp = list;
// Enquanto o n√≥ tiver um pr√≥ximo ponteiro ...
while (tmp-&gt;next != NULL)
{
    // ... defina o tempor√°rio para o pr√≥ximo n√≥
    tmp = tmp-&gt;next;
}
// Agora, tmp aponta para o √∫ltimo n√≥ em nossa lista e podemos atualizar seu pr√≥ximo
// ponteiro para apontar para nosso novo n√≥.
</code></pre>
</li>
<li>
<p>Se quisermos inserir um n√≥ no in√≠cio de nossa lista encadeada, precisaremos atualizar cuidadosamente nosso n√≥ para apontar para o seguinte, antes de atualizar a lista. Caso contr√°rio, perderemos o resto de nossa lista:</p>
<pre><code>// Aqui, estamos inserindo um n√≥ no in√≠cio da lista, ent√£o queremos que seu
// pr√≥ximo ponteiro aponte para a lista original, antes de apontar a lista para
// o n.
n-&gt;next = list;
list = n;
</code></pre>
</li>
<li>
<p>E para inserir um n√≥ no meio de nossa lista, podemos percorrer a lista, seguindo cada elemento um de cada vez, comparando seus valores e mudando os ponteiros <code>next</code> com cuidado tamb√©m.</p>
</li>
<li>
<p>Com alguns volunt√°rios no palco, simulamos uma lista, com cada volunt√°rio atuando como a vari√°vel <code>list</code> ou um n√≥. √Ä medida que inserimos n√≥s na lista, precisamos de um ponteiro tempor√°rio para seguir a lista e garantir que n√£o percamos nenhuma parte dela. Nossa lista encadeada aponta apenas para o primeiro n√≥ em nossa lista, portanto, s√≥ podemos olhar um n√≥ de cada vez, mas podemos alocar dinamicamente mais mem√≥ria √† medida que precisamos expandir nossa lista.</p>
</li>
<li>
<p>Agora, mesmo que a nossa lista encadeada esteja ordenada, o tempo de execu√ß√£o de pesquis√°-la ser√° <em>O</em>(<em>n</em>), j√° que precisamos seguir cada n√≥ para verificar seus valores e n√£o sabemos onde estar√° o meio da nossa lista.</p>
</li>
<li>
<p>Podemos combinar todos os trechos de c√≥digo em um programa completo:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Representa um n√≥
typedef struct node
{
    int number;
    struct node *next;
}
node;

int main(void)
{
    // Lista de tamanho 0, inicialmente n√£o apontando para nada
    node *list = NULL;

    // Adicionar n√∫mero √† lista
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }
    n-&gt;number = 1;
    n-&gt;next = NULL;
    // Criamos nosso primeiro n√≥, armazenamos o valor 1 nele e deixamos o pr√≥ximo
    // ponteiro apontar para nada. Em seguida, nossa vari√°vel de lista pode apontar para ele.
    list = n;

    // Adicionar n√∫mero √† lista
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }
    n-&gt;number = 2;
    n-&gt;next = NULL;
    // Agora, n√≥s vamos ao nosso primeiro n√≥ para o qual a lista aponta e definimos o pr√≥ximo ponteiro
    // sobre ele para apontar para o nosso novo n√≥, adicionando-o ao final da lista:
    list-&gt;next = n;

    // Adicionar n√∫mero √† lista
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }
    n-&gt;number = 3;
    n-&gt;next = NULL;
    // Podemos seguir v√°rios n√≥s com esta sintaxe, usando o ponteiro pr√≥ximo
    // repetidamente, para adicionar nosso terceiro novo n√≥ ao final da lista:
    list-&gt;next-&gt;next = n;
    // Normalmente, por√©m, gostar√≠amos de ter um loop e uma vari√°vel tempor√°ria para adicionar
    // um novo n√≥ √† nossa lista.

    // Imprimir lista
    // Aqui podemos percorrer todos os n√≥s em nossa lista com uma vari√°vel tempor√°ria
    // Primeiro, temos um ponteiro tempor√°rio, tmp, que aponta para a
    // lista. Em seguida, nossa condi√ß√£o para continuar √© que tmp n√£o seja NULO e
    // finalmente, atualizamos
</code></pre>
</li>
</ul>
<h2>Mais estruturas de dados</h2>
<ul>
<li>
<p>Uma <strong>√°rvore</strong> √© outra estrutura de dados em que cada n√≥ aponta para outros dois n√≥s, um para a esquerda (com um valor menor) e outro para a direita (com um valor maior):
<img src="https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png" alt="√°rvore com n√≥ 4 no topo central, seta esquerda para 3 abaixo, seta direita para 6 abaixo; 2 tem seta esquerda para 1 abaixo, seta direita para 3 abaixo; 6 tem seta esquerda para 5 abaixo, seta direita para 7 abaixo" /></p>
<ul>
<li>Note que agora h√° duas dimens√µes nessa estrutura de dados, onde alguns n√≥s est√£o em diferentes &quot;n√≠veis&quot; em rela√ß√£o aos outros. E podemos imaginar que isso seja implementado com uma vers√£o mais complexa de um n√≥ em uma lista encadeada, onde cada n√≥ n√£o tem apenas um, mas dois ponteiros, um para o valor &quot;no meio da metade esquerda&quot; e outro para o valor &quot;no meio da metade direita&quot;. E todos os elementos √† esquerda de um n√≥ s√£o menores e todos os elementos √† direita s√£o maiores.</li>
<li>Isso √© chamado de √°rvore bin√°ria de busca porque cada n√≥ tem no m√°ximo dois filhos, ou n√≥s para os quais est√° apontando, e √°rvore de busca porque est√° ordenada de uma maneira que nos permite fazer buscas corretamente.</li>
<li>E, como em uma lista encadeada, vamos querer manter um ponteiro apenas para o in√≠cio da lista, mas neste caso queremos apontar para a raiz, ou seja, o n√≥ central superior da √°rvore (o 4).</li>
</ul>
</li>
<li>
<p>Agora, podemos facilmente fazer uma busca bin√°ria e, como cada n√≥ est√° apontando para outro, tamb√©m podemos inserir n√≥s na √°rvore sem mov√™-los todos como ter√≠amos que fazer em um array. A busca recursiva nesta √°rvore seria algo como:</p>
<pre><code>typedef struct node
{
    int number;
    struct node *left;
    struct node *right;
} node;

// Aqui, *tree √© um ponteiro para a raiz de nossa √°rvore.
bool search(node *tree)
{
    // Precisamos de um caso base, se a √°rvore atual (ou parte da √°rvore) for NULA,
    // para retornar false:
    if (tree == NULL)
    {
        return false;
    }
    // Agora, dependendo se o n√∫mero no n√≥ atual √© maior ou menor,
    // podemos apenas olhar para o lado esquerdo ou direito da √°rvore:
    else if (50 &lt; tree-&gt;number)
    {
        return search(tree-&gt;left);
    }
    else if (50 &gt; tree-&gt;number)
    {
        return search(tree-&gt;right);
    }
    // Caso contr√°rio, o n√∫mero deve ser igual ao que procuramos:
    else {
        return true;
    }
}
</code></pre>
</li>
<li>
<p>O tempo de execu√ß√£o para pesquisar em uma √°rvore √© <em>O</em>(log <em>n</em>), e inserir n√≥s mantendo a √°rvore equilibrada tamb√©m √© <em>O</em>(log <em>n</em>). Ao gastarmos um pouco mais de mem√≥ria e tempo para manter a √°rvore, agora temos uma pesquisa mais r√°pida em compara√ß√£o com uma simples lista encadeada.</p>
</li>
<li>
<p>Uma estrutura de dados com tempo de pesquisa quase constante √© uma <strong>tabela de dispers√£o</strong> (hash table), que √© uma combina√ß√£o de um array e uma lista encadeada. Temos um array de listas encadeadas, e cada lista encadeada no array tem elementos de uma determinada categoria. Por exemplo, no mundo real, podemos ter muitos crach√°s de identifica√ß√£o e podemos classific√°-los em 26 compartimentos, um rotulado com cada letra do alfabeto, para que possamos encontrar os crach√°s de identifica√ß√£o olhando em apenas um compartimento.</p>
</li>
<li>
<p>Podemos implementar isso em uma tabela de dispers√£o com um array de 26 ponteiros, cada um apontando para uma lista encadeada para uma letra do alfabeto:
<img src="https://cs50.harvard.edu/x/2020/notes/5/hash_table.png" alt="array vertical com 26 caixas, a primeira com uma seta apontando para uma caixa rotulada Albus, a segunda vazia, a terceira com uma seta apontando para uma caixa rotulada Cedric ... a s√©tima com uma seta apontando para uma caixa rotulada Ginny com uma seta dessa caixa apontando para uma caixa rotulada George..." /></p>
</li>
<li>
<p>Como temos acesso aleat√≥rio com arrays, podemos adicionar elementos rapidamente, e tamb√©m indexar rapidamente um compartimento.</p>
</li>
<li>
<p>Um compartimento pode ter v√°rios valores correspondentes, ent√£o usaremos uma lista encadeada para armazenar todos eles horizontalmente. (Chamamos isso de colis√£o, quando dois valores correspondem de alguma maneira.)</p>
</li>
<li>
<p>Isso √© chamado de tabela de dispers√£o porque usamos uma fun√ß√£o de dispers√£o, que recebe uma entrada e a mapeia para um compartimento em que deve ser colocada. Em nosso exemplo, a fun√ß√£o de dispers√£o est√° apenas olhando para a primeira letra do nome, ent√£o pode retornar <code>0</code> para &quot;Albus&quot; e <code>25</code> para &quot;Zacharias&quot;.</p>
</li>
<li>
<p>Mas no pior caso, todos os nomes podem come√ßar com a mesma letra, ent√£o podemos acabar com o equivalente a uma √∫nica lista encadeada novamente. Podemos olhar para as primeiras duas letras e alocar compartimentos suficientes para 26*26 poss√≠veis valores dispersados, ou at√© mesmo as primeiras tr√™s letras, e agora precisar√≠amos de 26*26*26 compartimentos. No entanto, ainda poder√≠amos ter um pior caso em que todos os nossos valores comecem com os mesmos tr√™s caracteres, portanto o tempo de execu√ß√£o para pesquisa √© <em>O</em>(<em>n</em>). Na pr√°tica, por√©m, podemos chegar mais perto de <em>O</em>(1) se tivermos cerca de tantos compartimentos quanto valores poss√≠veis, especialmente se tivermos uma fun√ß√£o de dispers√£o ideal, onde podemos classificar nossas entradas em compartimentos √∫nicos.</p>
</li>
<li>
<p>Podemos usar outra estrutura de dados chamada <strong>√°rvore trie</strong> (l√™-se como &quot;try&quot; e √© a abrevia√ß√£o de &quot;retrieval&quot;):</p>
<p><img src="https://cs50.harvard.edu/x/2020/notes/5/trie.png" alt="array com letras de A-Z em 26 elementos, com H apontando para outro array com todas as 26 letras. os A e E deste array cada um apontam para outros dois arrays de todas as 26 letras, e isso continua em uma √°rvore at√© os arrays mais inferiores terem apenas uma letra marcada como v√°lida" /></p>
<ul>
<li>Imagine que queremos armazenar um dicion√°rio de palavras de maneira eficiente e ser capazes de acessar cada uma delas em tempo constante. Um √°rvore trie √© como uma √°rvore, mas cada n√≥ √© um array. Cada array ter√° cada letra, de A a Z, armazenada. Para cada palavra, a primeira letra apontar√° para um array, onde a pr√≥xima letra v√°lida apontar√° para outro array, e assim por diante, at√© chegarmos a algo que indique o final de uma palavra v√°lida. Se a palavra n√£o estiver no trie, ent√£o um dos arrays n√£o ter√° um ponteiro ou caractere de finaliza√ß√£o para a nossa palavra. Agora, mesmo se a nossa estrutura de dados tiver muitas palavras, o tempo de busca ser√° apenas o comprimento da palavra que estamos procurando, e isso pode ser um m√°ximo fixo, ent√£o temos <em>O</em>(1) para busca e inser√ß√£o. O custo disso, por√©m, √© 26 vezes mais mem√≥ria do que precisamos para cada caractere.</li>
</ul>
</li>
<li>
<p>Existem at√© constru√ß√µes de n√≠vel mais alto, <strong>estruturas de dados abstratas</strong>, onde usamos nossos blocos de constru√ß√£o de arrays, listas encadeadas, tabelas de dispers√£o e √°rvores trie para implementar uma solu√ß√£o para algum problema.</p>
</li>
<li>
<p>Por exemplo, uma estrutura de dados abstrata √© uma <strong>fila</strong>, onde queremos ser capazes de adicionar valores e remover valores de forma que o primeiro a entrar seja o primeiro a sair (FIFO). Para adicionar um valor, podemos enfileir√°-lo, e para remover um valor, podemos desenfileir√°-lo. E podemos implementar isso com um array que redimensionamos √† medida que adicionamos itens, ou uma lista encadeada onde apendicamos valores ao final.</p>
</li>
<li>
<p>Uma estrutura de dados &quot;oposta&quot; seria uma <strong>pilha</strong>, onde os itens adicionados mais recentemente (empilhados) s√£o removidos (desempilhados) primeiro, em uma forma de √∫ltimo a entrar, primeiro a sair (LIFO). Nossa caixa de entrada de e-mail √© uma pilha, onde nossos e-mails mais recentes est√£o no topo.</p>
</li>
<li>
<p>Outro exemplo √© um <strong>dicion√°rio</strong>, onde podemos mapear chaves para valores, ou strings para valores, e podemos implementar um com uma tabela de dispers√£o onde uma palavra vem com alguma outra informa√ß√£o (como sua defini√ß√£o ou significado).</p>
</li>
<li>
<p>Vamos dar uma olhada em <a href="https://www.youtube.com/watch?v=2wM6_PuBIxY">‚ÄúJack Learns the Facts About Queues and Stacks‚Äù</a>, uma anima√ß√£o sobre essas estruturas de dados.</p>
</li>
</ul>


        </main>
      </div>
    </div>
  </body>
</html>