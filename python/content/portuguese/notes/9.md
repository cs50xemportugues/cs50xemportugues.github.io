

## # Aula 9

- [Et Cetera](#et-cetera)
- [`set`](#set)
- [VariÃ¡veis Globais](#global-variables)
- [Constantes](#constants)
- [Dicas de Tipo](#type-hints)
- [Docstrings](#docstrings)
- [`argparse`](#argparse)
- [Desempacotamento](#unpacking)
- [`args` e `kwargs`](#args-and-kwargs)
- [`map`](#map)
- [CompreensÃ£o de Listas](#list-comprehensions)
- [`filter`](#filter)
- [CompreensÃ£o de DicionÃ¡rios](#dictionary-comprehensions)
- [`enumerate`](#enumerate)
- [Geradores e Iteradores](#generators-and-iterators)
- [ParabÃ©ns!](#congratulations)
- [Isso foi CS50!](#this-was-cs50)

## Et cetera

- Ao longo das muitas liÃ§Ãµes passadas, abordamos muitas coisas relacionadas ao Python!
- Nesta liÃ§Ã£o, estaremos focando em muitos dos itens "et cetera" que nÃ£o foram discutidos anteriormente. "Et cetera" literalmente significa "e o restante"!
- De fato, se vocÃª olhar a documentaÃ§Ã£o do Python, encontrarÃ¡ vÃ¡rias outras funcionalidades "o restante".

## `conjunto`

- Na matemÃ¡tica, um conjunto seria considerado um conjunto de nÃºmeros sem duplicatas.
- Na janela do editor de texto, o cÃ³digo Ã© o seguinte:

      alunos = [
          {"nome": "Hermione", "casa": "GrifinÃ³ria"},
          {"nome": "Harry", "casa": "GrifinÃ³ria"},
          {"nome": "Rony", "casa": "GrifinÃ³ria"},
          {"nome": "Draco", "casa": "Sonserina"},
          {"nome": "Padma", "casa": "Corvinal"},
      ]

      casas = []
      for aluno in alunos:
          if aluno["casa"] not in casas:
              casas.append(aluno["casa"])

      for casa in sorted(casas):
          print(casa)

  Observe como temos uma lista de dicionÃ¡rios, sendo cada um um aluno. Uma lista vazia chamada `casas` Ã© criada. Iteramos por cada `aluno` em `alunos`. Se a `casa` de um aluno nÃ£o estiver em `casas`, adicionamos Ã  nossa lista de `casas`.

- Descobrimos que podemos usar as funcionalidades incorporadas do `conjunto` para eliminar duplicatas.
- Na janela do editor de texto, o cÃ³digo Ã© o seguinte:

      alunos = [
          {"nome": "Hermione", "casa": "GrifinÃ³ria"},
          {"nome": "Harry", "casa": "GrifinÃ³ria"},
          {"nome": "Rony", "casa": "GrifinÃ³ria"},
          {"nome": "Draco", "casa": "Sonserina"},
          {"nome": "Padma", "casa": "Corvinal"},
      ]

      casas = set()
      for aluno in alunos:
          casas.add(aluno["casa"])

      for casa in sorted(casas):
          print(casa)

  Observe como nÃ£o Ã© necessÃ¡rio incluir verificaÃ§Ãµes para garantir que nÃ£o haja duplicatas. O objeto `conjunto` cuida disso automaticamente para nÃ³s.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [`conjunto`](https://docs.python.org/3/library/stdtypes.html#set).

## VariÃ¡veis globais

- Em outras linguagens de programaÃ§Ã£o, existe a noÃ§Ã£o de variÃ¡veis globais que sÃ£o acessÃ­veis por qualquer funÃ§Ã£o.
- Podemos aproveitar essa capacidade no Python. No editor de texto, digite o seguinte cÃ³digo:

      balance = 0


      def main():
          print("Saldo:", balance)


      if __name__ == "__main__":
          main()

  Observe como criamos uma variÃ¡vel global chamada `balance`, fora de qualquer funÃ§Ã£o.

- Como nenhuma mensagem de erro Ã© apresentada ao executar o cÃ³digo acima, vocÃª poderia pensar que estÃ¡ tudo bem. No entanto, nÃ£o estÃ¡! No editor de texto, digite o seguinte cÃ³digo:

      balance = 0


      def main():
          print("Saldo:", balance)
          deposit(100)
          withdraw(50)
          print("Saldo:", balance)


      def deposit(n):
          balance += n


      def withdraw(n):
          balance -= n


      if __name__ == "__main__":
          main()

  Observe como agora adicionamos a funcionalidade de adicionar e retirar fundos do `balance`. No entanto, ao executar esse cÃ³digo, um erro Ã© apresentado! Vemos um erro chamado `UnboundLocalError`. VocÃª pode imaginar que, pelo menos da maneira como codificamos `balance` e nossas funÃ§Ãµes `deposit` e `withdraw` atualmente, nÃ£o Ã© possÃ­vel atribuir um valor para dentro de uma funÃ§Ã£o.

- Para interagir com uma variÃ¡vel global dentro de uma funÃ§Ã£o, a soluÃ§Ã£o Ã© usar a palavra-chave `global`. No editor de texto, digite o seguinte cÃ³digo:

      balance = 0


      def main():
          print("Saldo:", balance)
          deposit(100)
          withdraw(50)
          print("Saldo:", balance)


      def deposit(n):
          global balance
          balance += n


      def withdraw(n):
          global balance
          balance -= n


      if __name__ == "__main__":
          main()

  Observe como a palavra-chave `global` informa a cada funÃ§Ã£o que `balance` nÃ£o se refere a uma variÃ¡vel local: em vez disso, ela se refere Ã  variÃ¡vel global que colocamos originalmente no topo do nosso cÃ³digo. Agora, nosso cÃ³digo funciona!

- Utilizando nossos conhecimentos de programaÃ§Ã£o orientada a objetos, podemos modificar nosso cÃ³digo para usar uma classe em vez de uma variÃ¡vel global. No editor de texto, digite o seguinte cÃ³digo:

      class Conta:
          def __init__(self):
              self._saldo = 0

          @property
          def saldo(self):
              return self._saldo

          def depositar(self, n):
              self._saldo += n

          def sacar(self, n):
              self._saldo -= n


      def main():
          conta = Conta()
          print("Saldo:", conta.saldo)
          conta.depositar(100)
          conta.sacar(50)
          print("Saldo:", conta.saldo)


      if __name__ == "__main__":
          main()

  Observe como usamos `conta = Conta()` para criar uma conta. As classes nos permitem resolver esse problema da necessidade de uma variÃ¡vel global de forma mais limpa porque essas variÃ¡veis de instÃ¢ncia sÃ£o acessÃ­veis a todos os mÃ©todos dessa classe utilizando `self`.

- Em geral, as variÃ¡veis globais devem ser usadas com muita moderaÃ§Ã£o, se Ã© que devem ser usadas!

## Constantes

- Alguns idiomas permitem que vocÃª crie variÃ¡veis que sÃ£o imutÃ¡veis, chamadas de "constantes". As constantes permitem programar defensivamente e reduzir as oportunidades de os valores importantes serem alterados.
- Na janela do editor de texto, escreva o seguinte cÃ³digo:

      MEOWS = 3

      for _ in range(MEOWS):
          print("meow")

  Note que `MEOWS` Ã© nossa constante neste caso. As constantes geralmente sÃ£o indicadas por nomes de variÃ¡veis em letras maiÃºsculas e sÃ£o colocadas no topo do nosso cÃ³digo. Embora isso _pareÃ§a_ uma constante, na realidade, o Python na verdade nÃ£o tem nenhum mecanismo para evitar que nÃ³s mudemos esse valor dentro do nosso cÃ³digo! Em vez disso, vocÃª estÃ¡ no sistema de honra: se um nome de variÃ¡vel estiver escrito em letras maiÃºsculas, simplesmente nÃ£o o altere!

- Ã‰ possÃ­vel criar uma "constante" de classe, agora entre aspas porque sabemos que o Python nÃ£o suporta totalmente "constantes". Na janela do editor de texto, escreva o seguinte cÃ³digo:

      class Gato:
          MEOWS = 3

          def miar(self):
              for _ in range(Gato.MEOWS):
                  print("meow")


      gato = Gato()
      gato.miar()

  Porque `MEOWS` Ã© definida fora de qualquer mÃ©todo especÃ­fico da classe, todos eles tÃªm acesso a esse valor por meio de `Gato.MEOWS`.

## Dicas de Tipos

- Em outras linguagens de programaÃ§Ã£o, Ã© possÃ­vel expressar explicitamente o tipo de variÃ¡vel que se deseja usar.
- Como vimos anteriormente no curso, o Python nÃ£o requer a declaraÃ§Ã£o explÃ­cita de tipos.
- No entanto, Ã© uma boa prÃ¡tica garantir que todas as suas variÃ¡veis sejam do tipo correto.
- O `mypy` Ã© um programa que pode ajudar a verificar se todas as suas variÃ¡veis sÃ£o do tipo correto.
- VocÃª pode instalar o `mypy` executando o seguinte comando em sua janela de terminal: `pip install mypy`.

No editor de texto, escreva o cÃ³digo da seguinte maneira:

      def meow(n):
          for _ in range(n):
              print("meow")


      number = input("NÃºmero: ")
      meow(number)

VocÃª pode notar que `number = input("NÃºmero: ")` retorna uma `string`, nÃ£o um `int`. Mas `meow` provavelmente espera um `int`!

- Uma dica de tipo pode ser adicionada para dar uma dica ao Python sobre o tipo de variÃ¡vel que `meow` deve esperar. No editor de texto, escreva o cÃ³digo da seguinte maneira:

      def meow(n: int):
          for _ in range(n):
              print("meow")


      number = input("NÃºmero: ")
      meow(number)

  Note, porÃ©m, que nosso programa ainda lanÃ§a um erro.

- ApÃ³s a instalaÃ§Ã£o do `mypy`, execute `mypy meows.py` na janela do terminal. O `mypy` fornecerÃ¡ algumas orientaÃ§Ãµes sobre como corrigir esse erro.
- Ã‰ possÃ­vel fazer anotaÃ§Ãµes em todas as suas variÃ¡veis. No editor de texto, escreva o cÃ³digo da seguinte maneira:

      def meow(n: int):
          for _ in range(n):
              print("meow")


      number: int = input("NÃºmero: ")
      meow(number)

  Note como `number` agora recebe uma dica de tipo.

- Novamente, executar `mypy meows.py` na janela do terminal fornece feedback muito mais especÃ­fico para vocÃª, o programador.
- Podemos corrigir nosso Ãºltimo erro escrevendo o cÃ³digo da seguinte maneira:

      def meow(n: int):
          for _ in range(n):
              print("meow")


      number: int = int(input("NÃºmero: "))
      meow(number)

  Note como a execuÃ§Ã£o de `mypy` agora nÃ£o exibe erros porque transformamos nossa entrada em um inteiro.

- Vamos introduzir um novo erro, assumindo que `meow` nos retornarÃ¡ uma string, ou `str`. No editor de texto, escreva o cÃ³digo da seguinte maneira:

      def meow(n: int):
          for _ in range(n):
              print("meow")


      number: int = int(input("NÃºmero: "))
      meows: str = meow(number)
      print(meows)

  Note como a funÃ§Ã£o `meow` tem apenas um efeito colateral. Como sÃ³ tentamos imprimir "meow", sem retornar um valor, ocorre um erro ao tentarmos armazenar o valor de retorno de `meow` em `meows`.

- Podemos usar dicas de tipos para verificar erros, desta vez anotando os valores de retorno das funÃ§Ãµes. No editor de texto, escreva o cÃ³digo da seguinte maneira:

      def meow(n: int) -> None:
          for _ in range(n):
              print("meow")


      number: int = int(input("NÃºmero: "))
      meows: str = meow(number)
      print(meows)

  Note como a notaÃ§Ã£o `-> None` informa ao `mypy` que nÃ£o hÃ¡ um valor de retorno.

- Podemos modificar nosso cÃ³digo para retornar uma string se desejarmos:

      def meow(n: int) -> str:
          return "meow\n" * n


      number: int = int(input("NÃºmero: "))
      meows: str = meow(number)
      print(meows, end="")

  Note como armazenamos em `meows` vÃ¡rias `str`s. A execuÃ§Ã£o de `mypy` nÃ£o exibe erros.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [Dicas de Tipos](https://docs.python.org/3/library/typing.html).
- VocÃª pode aprender mais sobre o [`mypy`](https://mypy.readthedocs.io/) por meio da prÃ³pria documentaÃ§Ã£o do programa.

## Docstrings

- Uma maneira padrÃ£o de comentar o propÃ³sito de sua funÃ§Ã£o Ã© usar um docstring. Na janela do editor de texto, escreva o cÃ³digo da seguinte forma:

      def meow(n):
          """Miar n vezes."""
          return "miar\n" * n


      number = int(input("NÃºmero: "))
      miados = meow(number)
      print(miados, end="")

  Observe como as trÃªs aspas duplas indicam o que a funÃ§Ã£o faz.

- VocÃª pode usar docstrings para padronizar como vocÃª documenta as caracterÃ­sticas de uma funÃ§Ã£o. Na janela do editor de texto, escreva o cÃ³digo da seguinte forma:

      def meow(n):
          """
          Miar n vezes.

          :param n: NÃºmero de vezes para miar
          :type n: int
          :raise TypeError: Se n nÃ£o for um int
          :return: Uma string com n miados, um por linha
          :rtype: str
          """
          return "miar\n" * n


      number = int(input("NÃºmero: "))
      miados = meow(number)
      print(miados, end="")

  Observe como vÃ¡rios argumentos de docstring sÃ£o incluÃ­dos. Por exemplo, ele descreve os parÃ¢metros recebidos pela funÃ§Ã£o e o que Ã© retornado pela funÃ§Ã£o.

- Ferramentas estabelecidas, como [Sphinx](https://www.sphinx-doc.org/en/master/index.html), podem ser usadas para analisar docstrings e criar automaticamente documentaÃ§Ã£o para nÃ³s na forma de pÃ¡ginas da web e arquivos PDF, que podem ser publicados e compartilhados com outras pessoas.
- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [docstrings](https://peps.python.org/pep-0257/).

## `argparse`

- Suponha que queremos usar argumentos de linha de comando em nosso programa. Na janela do editor de texto, codifique da seguinte forma:

Â Â Â Â import sys

Â Â Â Â if len(sys.argv) == 1:
Â Â Â Â Â Â Â Â print("meow")
Â Â Â Â elif len(sys.argv) == 3 and sys.argv[1] == "-n":
Â Â Â Â Â Â Â Â n = int(sys.argv[2])
Â Â Â Â Â Â Â Â for _ in range(n):
Â Â Â Â Â Â Â Â Â Â Â Â print("meow")
Â Â Â Â else:
Â Â Â Â Â Â Â Â print("uso: meows.py [-n NÃšMERO]")

Â  Observe como `sys` Ã© importado, de onde obtemos acesso a `sys.argv` - um array de argumentos de linha de comando fornecidos ao nosso programa quando executado. Podemos usar vÃ¡rias instruÃ§Ãµes `if` para verificar se o usuÃ¡rio executou corretamente nosso programa.

- Vamos supor que este programa fique muito mais complicado. Como poderÃ­amos verificar todos os argumentos que podem ser inseridos pelo usuÃ¡rio? Podemos desistir se tivermos mais do que alguns argumentos de linha de comando!
- Felizmente, `argparse` Ã© uma biblioteca que lida com a anÃ¡lise de strings complicadas de argumentos de linha de comando. Na janela do editor de texto, codifique da seguinte forma:

Â Â Â Â import argparse

Â Â Â Â parser = argparse.ArgumentParser()
Â Â Â Â parser.add_argument("-n")
Â Â Â Â args = parser.parse_args()

Â Â Â Â for _ in range(int(args.n)):
Â Â Â Â Â Â Â Â print("meow")

Â  Observe como `argparse` Ã© importado em vez de `sys`. Um objeto chamado `parser` Ã© criado a partir de uma classe `ArgumentParser`. O mÃ©todo `add_argument` dessa classe Ã© usado para informar ao `argparse` quais argumentos devemos esperar do usuÃ¡rio quando eles executam nosso programa. Por fim, executar o mÃ©todo `parse_args` do analisador garante que todos os argumentos tenham sido incluÃ­dos corretamente pelo usuÃ¡rio.

- TambÃ©m podemos programar de forma mais limpa, de modo que o usuÃ¡rio possa obter informaÃ§Ãµes sobre o uso correto do nosso cÃ³digo quando falhar ao usar o programa corretamente. Na janela do editor de texto, codifique da seguinte forma:

Â Â Â Â import argparse

Â Â Â Â parser = argparse.ArgumentParser(description="Meow como um gato")
Â Â Â Â parser.add_argument("-n", help="nÃºmero de vezes para miar")
Â Â Â Â args = parser.parse_args()

Â Â Â Â for _ in range(int(args.n)):
Â Â Â Â Â Â Â Â print("meow")

Â  Observe como o usuÃ¡rio recebe alguma documentaÃ§Ã£o. Especificamente, um argumento `help` Ã© fornecido. Agora, se o usuÃ¡rio executar `python meows.py --help` ou `-h`, o usuÃ¡rio receberÃ¡ algumas dicas sobre como usar este programa.

- Podemos melhorar ainda mais este programa. Na janela do editor de texto, codifique da seguinte forma:

Â Â Â Â import argparse

Â Â Â Â parser = argparse.ArgumentParser(description="Meow como um gato")
Â Â Â Â parser.add_argument("-n", default=1, help="nÃºmero de vezes para miar", type=int)
Â Â Â Â args = parser.parse_args()

Â Â Â Â for _ in range(args.n):
Â Â Â Â Â Â Â Â print("meow")

Â  Observe como nÃ£o apenas a documentaÃ§Ã£o de ajuda estÃ¡ incluÃ­da, mas vocÃª pode fornecer um valor `default` quando nenhum argumento Ã© fornecido pelo usuÃ¡rio.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [`argparse`](https://docs.python.org/3/library/argparse.html).

## Desempacotando

- NÃ£o seria bom poder dividir uma Ãºnica variÃ¡vel em duas variÃ¡veis? Na janela do editor de texto, escreva o seguinte cÃ³digo:

      primeiro, _ = input("Qual Ã© o seu nome? ").split(" ")
      print(f"olÃ¡, {primeiro}")

  Observe como este programa tenta obter o primeiro nome do usuÃ¡rio, dividindo ingenuamente em um Ãºnico espaÃ§o.

- Descobriu-se que existem outras maneiras de desempacotar variÃ¡veis. VocÃª pode escrever um cÃ³digo mais poderoso e elegante ao entender como desempacotar variÃ¡veis de maneiras aparentemente mais avanÃ§adas. Na janela do editor de texto, escreva o seguinte cÃ³digo:

      def total(galeÃµes, sickles, knuts):
          return (galeÃµes * 17 + sickles) * 29 + knuts


      print(total(100, 50, 25), "Knuts")

  Observe como isso retorna o valor total em Knuts.

- E se quisermos armazenar nossas moedas em uma lista? Na janela do editor de texto, escreva o seguinte cÃ³digo:

      def total(galeÃµes, sickles, knuts):
          return (galeÃµes * 17 + sickles) * 29 + knuts


      coins = [100, 50, 25]

      print(total(coins[0], coins[1], coins[2]), "Knuts")

  Observe como uma lista chamada `coins` Ã© criada. Podemos passar cada valor indexando usando `0`, `1` e assim por diante.

- Isso estÃ¡ ficando muito verboso. NÃ£o seria bom se pudÃ©ssemos simplesmente passar a lista de moedas para nossa funÃ§Ã£o?
- Para possibilitar a passagem da lista inteira, podemos usar o desempacotamento. Na janela do editor de texto, escreva o seguinte cÃ³digo:

      def total(galeÃµes, sickles, knuts):
          return (galeÃµes * 17 + sickles) * 29 + knuts


      coins = [100, 50, 25]

      print(total(*coins), "Knuts")

  Observe como o `*` desempacota a sequÃªncia da lista de moedas e passa cada um de seus elementos individuais para `total`.

- Suponha que pudÃ©ssemos passar os nomes das moedas em qualquer ordem? Na janela do editor de texto, escreva o seguinte cÃ³digo:

      def total(galeÃµes, sickles, knuts):
          return (galeÃµes * 17 + sickles) * 29 + knuts


      print(total(galeÃµes=100, sickles=50, knuts=25), "Knuts")

  Observe como isso ainda Ã© calculado corretamente.

- Quando vocÃª comeÃ§a a falar sobre "nomes" e "valores", os dicionÃ¡rios podem vir Ã  mente! VocÃª pode implementar isso como um dicionÃ¡rio. Na janela do editor de texto, escreva o seguinte cÃ³digo:

      def total(galeÃµes, sickles, knuts):
          return (galeÃµes * 17 + sickles) * 29 + knuts


      coins = {"galeÃµes": 100, "sickles": 50, "knuts": 25}

      print(total(coins["galeÃµes"], coins["sickles"], coins["knuts"]), "Knuts")

  Observe como um dicionÃ¡rio chamado `coins` Ã© fornecido. Podemos indexÃ¡-lo usando chaves, como "galeÃµes" ou "sickles".

- Como a funÃ§Ã£o `total` espera trÃªs argumentos, nÃ£o podemos passar um dicionÃ¡rio. Podemos usar o desempacotamento para ajudar com isso. Na janela do editor de texto, escreva o seguinte cÃ³digo:

      def total(galeÃµes, sickles, knuts):
          return (galeÃµes * 17 + sickles) * 29 + knuts


      coins = {"galeÃµes": 100, "sickles": 50, "knuts": 25}

      print(total(**coins), "Knuts")

  Observe como `**` permite que vocÃª desempacote um dicionÃ¡rio. Ao desempacotar um dicionÃ¡rio, ele fornece tanto as chaves quanto os valores.

## `args` e `kwargs`

- Lembre-se da documentaÃ§Ã£o do `print` que vimos anteriormente neste curso:

      print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

- `args` sÃ£o argumentos posicionais, como aqueles que fornecemos para `print` como `print("OlÃ¡", "Mundo")`.
- `kwargs` sÃ£o argumentos nomeados, ou "argumentos de palavra-chave", como aqueles que fornecemos para `print` como `print(end="")`.
- Como podemos ver no protÃ³tipo da funÃ§Ã£o `print` acima, podemos informar Ã  nossa funÃ§Ã£o que ela pode esperar um nÃºmero desconhecido de argumentos posicionais. TambÃ©m podemos informar que ela pode esperar um nÃºmero desconhecido de argumentos de palavra-chave. No editor de texto, escreva o seguinte cÃ³digo:

      def f(*args, **kwargs):
          print("Posicional:", args)


      f(100, 50, 25)

  Observe como a execuÃ§Ã£o deste cÃ³digo imprimirÃ¡ os argumentos posicionais.

- Podemos atÃ© passar argumentos nomeados. No editor de texto, escreva o seguinte cÃ³digo:

      def f(*args, **kwargs):
          print("Nomeados:", kwargs)


      f(galeÃµes=100, sicles=50, knuts=25)

  Observe como os valores nomeados sÃ£o fornecidos na forma de um dicionÃ¡rio.

- Ao pensar na funÃ§Ã£o `print` acima, vocÃª pode ver como `*objects` aceita qualquer nÃºmero de argumentos posicionais.
- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [`print`](https://docs.python.org/3/library/functions.html#print).

## `map`

- No inÃ­cio, comeÃ§amos com programaÃ§Ã£o procedural.
- Mais tarde, descobrimos que o Python Ã© uma linguagem de programaÃ§Ã£o orientada a objetos.
- Vimos indÃ­cios de programaÃ§Ã£o funcional, onde as funÃ§Ãµes tÃªm efeitos colaterais sem um valor de retorno. Podemos ilustrar isso na janela do editor de texto, digitando `code yell.py` e o cÃ³digo a seguir:

        def main():
            yell("This is CS50")


        def yell(word):
            print(word.upper())


        if __name__ == "__main__":
            main()

  Observe como a funÃ§Ã£o `yell` apenas imprime o texto em caixa alta.

- NÃ£o seria legal gritar uma lista ilimitada de palavras? Modifique seu cÃ³digo da seguinte forma:

        def main():
            yell(["This", "is", "CS50"])


        def yell(words):
            uppercased = []
            for word in words:
                uppercased.append(word.upper())
            print(*uppercased)


        if __name__ == "__main__":
            main()

  Observe como acumulamos as palavras em caixa alta, percorrendo cada uma das palavras e convertendo-as em maiÃºsculas. A lista de palavras em maiÃºsculo Ã© impressa usando o `*` para desempacotÃ¡-la.

- Removendo os colchetes, podemos passar as palavras como argumentos. No editor de texto, digite o seguinte cÃ³digo:

        def main():
            yell("This", "is", "CS50")


        def yell(*words):
            uppercased = []
            for word in words:
                uppercased.append(word.upper())
            print(*uppercased)


        if __name__ == "__main__":
            main()

  Observe como `*words` permite que muitos argumentos sejam passados para a funÃ§Ã£o.

- `map` permite mapear uma funÃ§Ã£o para uma sequÃªncia de valores. Na prÃ¡tica, podemos escrever o cÃ³digo da seguinte forma:

        def main():
            yell("This", "is", "CS50")


        def yell(*words):
            uppercased = map(str.upper, words)
            print(*uppercased)


        if __name__ == "__main__":
            main()

  Observe como `map` recebe dois argumentos. Primeiro, ele recebe uma funÃ§Ã£o que queremos aplicar a cada elemento de uma lista. Em segundo lugar, ele recebe a prÃ³pria lista, Ã  qual aplicaremos a funÃ§Ã£o mencionada anteriormente. Assim, todas as palavras em `words` serÃ£o passadas para a funÃ§Ã£o `str.upper` e retornadas para `uppercased`.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [`map`](https://docs.python.org/3/library/functions.html#map).

## CompreensÃµes de Lista

- As compreensÃµes de lista permitem que vocÃª crie uma lista rapidamente em uma Ãºnica linha elegante.
- Podemos implementar isso em nosso cÃ³digo da seguinte forma:

      def main():
          yell("This", "is", "CS50")


      def yell(*words):
          uppercased = [arg.upper() for arg in words]
          print(*uppercased)


      if __name__ == "__main__":
          main()

  Note como, em vez de usar `map`, escrevemos uma expressÃ£o Python entre colchetes. Para cada argumento, `.upper` Ã© aplicado a ele.

- Levando esse conceito adiante, vamos nos voltar para outro programa.
- Na janela do editor de texto, digite `code gryffindors.py` e o cÃ³digo a seguir:

      students = [
          {"name": "Hermione", "house": "Gryffindor"},
          {"name": "Harry", "house": "Gryffindor"},
          {"name": "Ron", "house": "Gryffindor"},
          {"name": "Draco", "house": "Slytherin"},
      ]

      gryffindors = []
      for student in students:
          if student["house"] == "Gryffindor":
              gryffindors.append(student["name"])

      for gryffindor in sorted(gryffindors):
          print(gryffindor)

  Note que temos uma condiÃ§Ã£o enquanto estamos criando nossa lista. _Se_ a casa do estudante for Gryffindor, adicionamos o estudante Ã  lista de nomes. Finalmente, imprimimos todos os nomes.

- De forma mais elegante, podemos simplificar esse cÃ³digo com uma compreensÃ£o de lista da seguinte forma:

      students = [
          {"name": "Hermione", "house": "Gryffindor"},
          {"name": "Harry", "house": "Gryffindor"},
          {"name": "Ron", "house": "Gryffindor"},
          {"name": "Draco", "house": "Slytherin"},
      ]

      gryffindors = [
          student["name"] for student in students if student["house"] == "Gryffindor"
      ]

      for gryffindor in sorted(gryffindors):
          print(gryffindor)

  Note como a compreensÃ£o de lista estÃ¡ em uma Ãºnica linha!

## `filter`

- Usar a funÃ§Ã£o `filter` do Python nos permite retornar um subconjunto de uma sequÃªncia para a qual uma determinada condiÃ§Ã£o Ã© verdadeira.
- Na janela do editor de texto, insira o seguinte cÃ³digo:

      students = [
          {"name": "Hermione", "house": "Gryffindor"},
          {"name": "Harry", "house": "Gryffindor"},
          {"name": "Ron", "house": "Gryffindor"},
          {"name": "Draco", "house": "Slytherin"},
      ]


      def is_gryffindor(s):
          return s["house"] == "Gryffindor"


      gryffindors = filter(is_gryffindor, students)

      for gryffindor in sorted(gryffindors, key=lambda s: s["name"]):
          print(gryffindor["name"])

  Observe como uma funÃ§Ã£o chamada `is_gryffindor` Ã© criada. Esta Ã© nossa funÃ§Ã£o de filtragem que receberÃ¡ um estudante `s` e retornarÃ¡ `True` ou `False` dependendo se a casa do aluno Ã© Gryffindor. VocÃª pode ver que a nova funÃ§Ã£o `filter` recebe dois argumentos. Primeiro, ele recebe a funÃ§Ã£o que serÃ¡ aplicada a cada elemento em uma sequÃªncia - neste caso, `is_gryffindor`. Segundo, ele recebe a sequÃªncia Ã  qual aplicarÃ¡ a funÃ§Ã£o de filtragem - neste caso, `students`. Em `gryffindors`, devemos ver apenas os alunos que estÃ£o em Gryffindor.

- `filter` tambÃ©m pode usar funÃ§Ãµes lambda da seguinte forma:

      students = [
          {"name": "Hermione", "house": "Gryffindor"},
          {"name": "Harry", "house": "Gryffindor"},
          {"name": "Ron", "house": "Gryffindor"},
          {"name": "Draco", "house": "Slytherin"},
      ]


      gryffindors = filter(lambda s: s["house"] == "Gryffindor", students)

      for gryffindor in sorted(gryffindors, key=lambda s: s["name"]):
          print(gryffindor["name"])

  Observe como a mesma lista de alunos Ã© fornecida.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [`filter`](https://docs.python.org/3/library/functions.html#filter).

## CompreensÃµes de DicionÃ¡rios

- Podemos aplicar a mesma ideia das compreensÃµes de listas aos dicionÃ¡rios. Na janela do editor de texto, digite o seguinte cÃ³digo:

      students = ["Hermione", "Harry", "Ron"]

      gryffindors = []

      para estudante em students:
          gryffindors.append({"nome": estudante, "casa": "Gryffindor"})

      print(gryffindors)

  Observe como esse cÃ³digo ainda nÃ£o usa nenhuma compreensÃ£o. Em vez disso, ele segue os mesmos paradigmas que vimos anteriormente.

- Agora podemos aplicar compreensÃµes de dicionÃ¡rios modificando nosso cÃ³digo da seguinte maneira:

      students = ["Hermione", "Harry", "Ron"]

      gryffindors = [{"nome": estudante, "casa": "Gryffindor"} para estudante em students]

      print(gryffindors)

  Observe como todo o cÃ³digo anterior Ã© simplificado em uma Ãºnica linha, onde a estrutura do dicionÃ¡rio Ã© fornecida para cada `estudante` em `students`.

- Podemos atÃ© simplificar ainda mais da seguinte maneira:

      students = ["Hermione", "Harry", "Ron"]

      gryffindors = {estudante: "Gryffindor" para estudante em students}

      print(gryffindors)

  Observe como o dicionÃ¡rio serÃ¡ construÃ­do com pares chave-valor.

## `enumerate`

- Podemos querer fornecer alguma classificaÃ§Ã£o para cada aluno. Na janela do editor de texto, escreva o cÃ³digo da seguinte forma:

      students = ["Hermione", "Harry", "Ron"]

      for i in range(len(students)):
          print(i + 1, students[i])

  Observe como cada aluno Ã© enumerado ao executar este cÃ³digo.

- Utilizando a enumeraÃ§Ã£o, podemos fazer o mesmo:

      students = ["Hermione", "Harry", "Ron"]

      for i, student in enumerate(students):
          print(i + 1, student)

  Observe como a enumeraÃ§Ã£o apresenta o Ã­ndice e o valor de cada `student`.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [`enumerate`](https://docs.python.org/3/library/functions.html#enumerate).

## Geradores e Iteradores

- No Python, hÃ¡ uma maneira de proteger contra seu sistema ficar sem recursos quando os problemas que eles estÃ£o abordando se tornam muito grandes.
- Nos Estados Unidos, Ã© costumeiro "contar carneiros" mentalmente quando alguÃ©m estÃ¡ tendo dificuldade em pegar no sono.
- Na janela do editor de texto, digite `code sleep.py` e o cÃ³digo a seguir:

      n = int(input("Qual Ã© o valor de n? "))
      for i in range(n):
          print("ğŸ‘" * i)

  Observe como este programa irÃ¡ contar o nÃºmero de ovelhas que vocÃª solicitar a ele.

- Podemos tornar nosso programa mais sofisticado adicionando uma funÃ§Ã£o `main` codificando da seguinte maneira:

      def main():
          n = int(input("Qual Ã© o valor de n? "))
          for i in range(n):
              print("ğŸ‘" * i)


      if __name__ == "__main__":
          main()

  Observe como uma funÃ§Ã£o `main` Ã© fornecida.

- Temos adquirido o hÃ¡bito de abstrair partes do nosso cÃ³digo.
- Podemos chamar uma funÃ§Ã£o ovelha modificando nosso cÃ³digo da seguinte maneira:

      def main():
          n = int(input("Qual Ã© o valor de n? "))
          for i in range(n):
              print(ovelha(i))


      def ovelha(n):
          return "ğŸ‘" * n


      if __name__ == "__main__":
          main()

  Observe como a funÃ§Ã£o `main` faz a iteraÃ§Ã£o.

- Podemos fornecer mais habilidades Ã  funÃ§Ã£o `ovelha`. Na janela do editor de texto, codifique da seguinte maneira:

      def main():
          n = int(input("Qual Ã© o valor de n? "))
          for s in ovelha(n):
              print(s)


      def ovelha(n):
          rebanho = []
          for i in range(n):
              rebanho.append("ğŸ‘" * i)
          return rebanho


      if __name__ == "__main__":
          main()

  Observe como criamos um rebanho de ovelhas e retornamos o `rebanho`.

- Executando nosso cÃ³digo, vocÃª pode tentar diferentes nÃºmeros de ovelhas, como `10`, `1000` e `10000`. E se vocÃª pedisse `1000000` ovelhas, seu programa poderia ficar completamente travado ou travar. Porque vocÃª tentou gerar uma lista enorme de ovelhas, seu computador pode estar lutando para concluir o cÃ¡lculo.
- O gerador `yield` pode solucionar esse problema, retornando um pequeno pedaÃ§o dos resultados de cada vez. Na janela do editor de texto, codifique da seguinte maneira:

      def main():
          n = int(input("Qual Ã© o valor de n? "))
          for s in ovelha(n):
              print(s)


      def ovelha(n):
          for i in range(n):
              yield "ğŸ‘" * i


      if __name__ == "__main__":
          main()

  Observe como o `yield` fornece apenas um valor por vez, enquanto o laÃ§o `for` continua funcionando.

- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [geradores](https://docs.python.org/3/howto/functional.html#generators).
- VocÃª pode aprender mais na documentaÃ§Ã£o do Python sobre [iteradores](https://docs.python.org/3/howto/functional.html#iterators).

## ParabÃ©ns!

- Ao concluir este curso, vocÃª tem um modelo mental e uma caixa de ferramentas para lidar com problemas relacionados Ã  programaÃ§Ã£o.
- Primeiro, vocÃª aprendeu sobre funÃ§Ãµes e variÃ¡veis.
- Segundo, vocÃª aprendeu sobre condicionais.
- Terceiro, vocÃª aprendeu sobre loops.
- Quarto, vocÃª aprendeu sobre exceÃ§Ãµes.
- Quinto, vocÃª aprendeu sobre bibliotecas.
- Sexto, vocÃª aprendeu sobre testes unitÃ¡rios.
- SÃ©timo, vocÃª aprendeu sobre E/S de arquivos.
- Oitavo, vocÃª aprendeu sobre expressÃµes regulares.
- Mais recentemente, vocÃª aprendeu sobre programaÃ§Ã£o orientada a objetos.
- Hoje, vocÃª aprendeu sobre muitas outras ferramentas que pode utilizar.

## Isto foi o CS50!

- Para criar um programa final juntos, digite `code say.py` em sua janela de terminal e digite o seguinte cÃ³digo:

      import cowsay
      import pyttsx3

      engine = pyttsx3.init()
      this = input("O que Ã© isso? ")
      cowsay.cow(this)
      engine.say(this)
      engine.runAndWait()

  Observe como a execuÃ§Ã£o deste programa lhe proporciona uma despedida animada.

- Nossa grande esperanÃ§a Ã© que vocÃª use o que aprendeu neste curso para resolver problemas reais no mundo, tornando nosso planeta um lugar melhor.
- Isto foi o CS50!