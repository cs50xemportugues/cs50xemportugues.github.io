

## # Aula 8

- [Programa√ß√£o Orientada a Objetos](#programa√ß√£o-orientada-a-objetos)
- [Classes](#classes)
- [`raise`](#raise)
- [Decoradores](#decoradores)
- [Conex√£o com o Trabalho Anterior neste Curso](#conex√£o-com-o-trabalho-anterior-neste-curso)
- [M√©todos de Classe](#m√©todos-de-classe)
- [M√©todos Est√°ticos](#m√©todos-est√°ticos)
- [Heran√ßa](#heran√ßa)
- [Heran√ßa e Exce√ß√µes](#heran√ßa-e-exce√ß√µes)
- [Sobrecarga de Operadores](#sobrecarga-de-operadores)
- [Resumindo](#resumindo)

## Programa√ß√£o Orientada a Objetos

- Existem diferentes paradigmas de programa√ß√£o. Conforme voc√™ aprende outras linguagens, come√ßar√° a reconhecer padr√µes como esses.
- At√© agora, voc√™ tem trabalhado procedimentalmente, passo a passo.
- A programa√ß√£o orientada a objetos (OOP) √© uma solu√ß√£o convincente para problemas relacionados √† programa√ß√£o.
- Para come√ßar, digite `code student.py` na janela do terminal e escreva o c√≥digo a seguir:

     nome = input("Nome: ")
     casa = input("Casa: ")
     print(f"{nome} da casa {casa}")

   Observe que este programa segue um paradigma procedural, passo a passo: assim como voc√™ viu nas partes anteriores deste curso.

- Com base no nosso trabalho nas semanas anteriores, podemos criar fun√ß√µes para abstrair partes desse programa.

     def main():
         nome = get_nome()
         casa = get_casa()
         print(f"{nome} da casa {casa}")


     def get_nome():
         return input("Nome: ")


     def get_casa():
         return input("Casa: ")


     if __name__ == "__main__":
         main()

   Observe como `get_nome` e `get_casa` abstraem algumas das necessidades da nossa fun√ß√£o `main`. Al√©m disso, observe que as √∫ltimas linhas do c√≥digo acima dizem ao compilador para executar a fun√ß√£o `main`.

- Podemos simplificar ainda mais nosso programa armazenando o estudante como uma `tuple`. Uma `tuple` √© uma sequ√™ncia de valores. Ao contr√°rio de uma `list`, uma `tuple` n√£o pode ser modificada. Em ess√™ncia, estamos retornando dois valores.

     def main():
         nome, casa = get_estudante()
         print(f"{nome} da casa {casa}")


     def get_estudante():
         nome = input("Nome: ")
         casa = input("Casa: ")
         return nome, casa


     if __name__ == "__main__":
         main()

   Observe como `get_estudante` retorna `nome, casa`.

- Empacotando essa `tuple`, para que possamos retornar ambos os itens para uma vari√°vel chamada `estudante`, podemos modificar nosso c√≥digo da seguinte forma.

     def main():
         estudante = get_estudante()
         print(f"{estudante[0]} da casa {estudante[1]}")


     def get_estudante():
         nome = input("Nome: ")
         casa = input("Casa: ")
         return (nome, casa)


     if __name__ == "__main__":
         main()

   Observe que `(nome, casa)` explicitamente informa a qualquer pessoa que l√™ nosso c√≥digo que estamos retornando dois valores em um. Al√©m disso, observe como podemos indexar `tuple`s usando `estudante[0]` ou `estudante[1]`.

- As `tuple`s s√£o imut√°veis, o que significa que n√£o podemos alterar esses valores. A imutabilidade √© uma forma pela qual podemos programar defensivamente.

     def main():
         estudante = get_estudante()
         if estudante[0] == "Padma":
             estudante[1] = "Ravenclaw"
         print(f"{estudante[0]} da casa {estudante[1]}")


     def get_estudante():
         nome = input("Nome: ")
         casa = input("Casa: ")
         return nome, casa


     if __name__ == "__main__":
         main()

   Observe que este c√≥digo gera um erro. Como as `tuple`s s√£o imut√°veis, n√£o podemos atribuir um novo valor a `estudante[1]`.

- Se quis√©ssemos fornecer flexibilidade aos nossos colegas programadores, poder√≠amos usar uma `list` da seguinte forma.

     def main():
         estudante = get_estudante()
         if estudante[0] == "Padma":
             estudante[1] = "Ravenclaw"
         print(f"{estudante[0]} da casa {estudante[1]}")


     def get_estudante():
         nome = input("Nome: ")
         casa = input("Casa: ")
         return [nome, casa]


     if __name__ == "__main__":
         main()

   Observe que as `list` s√£o mut√°veis. Ou seja, a ordem de `casa` e `nome` pode ser alterada por um programador. Voc√™ pode decidir usar isso em alguns casos em que deseja fornecer mais flexibilidade, em detrimento da seguran√ßa do seu c√≥digo. Afinal, se a ordem desses valores for mut√°vel, os programadores que trabalham com voc√™ podem cometer erros no futuro.

- Um dicion√°rio tamb√©m poderia ser utilizado nessa implementa√ß√£o. Lembre-se de que os dicion√°rios fornecem um par de chave-valor.

     def main():
         estudante = get_estudante()
         print(f"{estudante['nome']} da casa {estudante['casa']}")


     def get_estudante():
         estudante = {}
         estudante["nome"] = input("Nome: ")
         estudante["casa"] = input("Casa: ")
         return estudante


     if __name__ == "__main__":
         main()

   Observe que neste caso, s√£o retornados dois pares de chave-valor. Uma vantagem dessa abordagem √© que podemos usar as chaves para indexar esse dicion√°rio.

- Ainda assim, nosso c√≥digo pode ser melhorado. Observe que h√° uma vari√°vel desnecess√°ria. Podemos remover `estudante = {}` porque n√£o precisamos criar um dicion√°rio vazio.

     def main():
         estudante = get_estudante()
         print(f"{estudante['nome']} da casa {estudante['casa']}")


     def get_estudante():
         nome = input("Nome: ")
         casa = input("Casa: ")
         return {"nome": nome, "casa": casa}


     if __name__ == "__main__":
         main()

   Observe que podemos usar as chaves `{}` na declara√ß√£o `return` para criar o dicion√°rio e retorn√°-lo na mesma linha.

- Podemos adicionar nosso caso especial com Padma na vers√£o do nosso c√≥digo com dicion√°rio.

     def main():
         estudante = get_estudante()
         if estudante["nome"] == "Padma":
             estudante["casa"] = "Ravenclaw"
         print(f"{estudante['nome']} da casa {estudante['casa']}")


     def get_estudante():
         nome = input("Nome: ")
         casa = input("Casa: ")
         return {"nome": nome, "casa": casa}


     if __name__ == "__main__":
         main()

   Observe como, de forma semelhante √†s itera√ß√µes anteriores deste c√≥digo, podemos usar os nomes das chaves para indexar nosso dicion√°rio de estudante.

## Classes

- Classes s√£o uma forma, na programa√ß√£o orientada a objetos, de podermos criar nosso pr√≥prio tipo de dado e dar-lhes nomes.
- Uma classe √© como um molde para um tipo de dado - onde podemos inventar nosso pr√≥prio tipo de dado e dar-lhes um nome.
- Podemos modificar nosso c√≥digo da seguinte forma para implementar nossa pr√≥pria classe chamada `Student`:

      class Student:
          ...


      def main():
          student = get_student()
          print(f"{student.name} da casa {student.house}")


      def get_student():
          student = Student()
          student.name = input("Nome: ")
          student.house = input("Casa: ")
          return student


      if __name__ == "__main__":
          main()

  Observe que por conven√ß√£o `Student` √© capitalizado. Al√©m disso, observe que `...` simplesmente significa que voltaremos posteriormente para terminar essa parte do c√≥digo. Al√©m disso, observe que em `get_student`, podemos criar um `student` da classe `Student` usando a sintaxe `student = Student()`. Al√©m disso, observe que utilizamos a "nota√ß√£o de ponto" para acessar atributos dessa vari√°vel `student` da classe `Student`.

- Toda vez que voc√™ cria uma classe e utiliza esse modelo para criar algo, voc√™ cria o que √© chamado de "objeto" ou "inst√¢ncia". No caso do nosso c√≥digo, `student` √© um objeto.
- Al√©m disso, podemos estabelecer os atributos que s√£o esperados dentro de um objeto cuja classe √© `Student`. Podemos modificar nosso c√≥digo da seguinte forma:

      class Student:
          def __init__(self, name, house):
              self.name = name
              self.house = house


      def main():
          student = get_student()
          print(f"{student.name} da casa {student.house}")


      def get_student():
          name = input("Nome: ")
          house = input("Casa: ")
          student = Student(name, house)
          return student


      if __name__ == "__main__":
          main()

  Observe que dentro de `Student`, padronizamos os atributos dessa classe. Podemos criar uma fun√ß√£o dentro da classe `Student`, chamada de "m√©todo", que determina o comportamento de um objeto da classe `Student`. Dentro dessa fun√ß√£o, ela pega o `name` e `house` passados para ela e atribui essas vari√°veis a esse objeto. Al√©m disso, observe como o construtor `student = Student(name, house)` chama essa fun√ß√£o dentro da classe `Student` e cria um `student`. `self` se refere ao objeto atual que acabou de ser criado.

- Podemos simplificar nosso c√≥digo da seguinte forma:

      class Student:
          def __init__(self, name, house):
              self.name = name
              self.house = house


      def main():
          student = get_student()
          print(f"{student.name} da casa {student.house}")


      def get_student():
          name = input("Nome: ")
          house = input("Casa: ")
          return Student(name, house)


      if __name__ == "__main__":
          main()

  Observe como `return Student(name, house)` simplifica a itera√ß√£o anterior do nosso c√≥digo onde a instru√ß√£o do construtor era executada em sua pr√≥pria linha.

- Voc√™ pode aprender mais na documenta√ß√£o do Python sobre [classes](https://docs.python.org/3/tutorial/classes.html).

## `raise`

- A programa√ß√£o orientada a objetos encoraja voc√™ a encapsular toda a funcionalidade de uma classe dentro da defini√ß√£o da classe. E se algo der errado? E se algu√©m tentar digitar algo aleat√≥rio? E se algu√©m tentar criar um estudante sem um nome? Modifique seu c√≥digo da seguinte forma:

      class Aluno:
          def __init__(self, nome, casa):
              if not nome:
                  raise ValueError("Nome ausente")
              if casa not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
                  raise ValueError("Casa inv√°lida")
              self.nome = nome
              self.casa = casa


      def principal():
          aluno = obter_aluno()
          print(f"{aluno.nome} da casa {aluno.casa}")


      def obter_aluno():
          nome = input("Nome: ")
          casa = input("Casa: ")
          return Aluno(nome, casa)


      if __name__ == "__main__":
          principal()

  Observe como verificamos agora se um nome √© fornecido e se uma casa adequada √© designada. Acaba que podemos criar nossas pr√≥prias exce√ß√µes que alertam o programador para um erro potencial criado pelo usu√°rio chamado `raise`. No caso acima, lan√ßamos um `ValueError` com uma mensagem de erro espec√≠fica.

- Acontece que o Python permite criar uma fun√ß√£o espec√≠fica que imprime os atributos de um objeto. Modifique seu c√≥digo da seguinte forma:

      class Aluno:
          def __init__(self, nome, casa, patronus):
              if not nome:
                  raise ValueError("Nome ausente")
              if casa not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
                  raise ValueError("Casa inv√°lida")
              self.nome = nome
              self.casa = casa
              self.patronus = patronus

          def __str__(self):
              return f"{self.nome} da casa {self.casa}"


      def principal():
          aluno = obter_aluno()
          print(aluno)


      def obter_aluno():
          nome = input("Nome: ")
          casa = input("Casa: ")
          patronus = input("Patronus: ")
          return Aluno(nome, casa, patronus)


      if __name__ == "__main__":
          principal()

  Observe como `def __str__(self)` fornece uma forma de retornar um aluno quando chamado. Portanto, voc√™ agora, como programador, pode imprimir um objeto, seus atributos ou quase qualquer coisa relacionada a esse objeto.

- `__str__` √© um m√©todo integrado que vem com as classes em Python. Acontece que tamb√©m podemos criar nossos pr√≥prios m√©todos para uma classe! Modifique seu c√≥digo da seguinte forma:

      class Aluno:
          def __init__(self, nome, casa, patronus=None):
              if not nome:
                  raise ValueError("Nome ausente")
              if casa not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
                  raise ValueError("Casa inv√°lida")
              if patronus and patronus not in ["Stag", "Otter", "Jack Russell terrier"]:
                  raise ValueError("Patronus inv√°lido")
              self.nome = nome
              self.casa = casa
              self.patronus = patronus

          def __str__(self):
              return f"{self.nome} da casa {self.casa}"

          def encanto(self):
              match self.patronus:
                  case "Stag":
                      return "üê¥"
                  case "Otter":
                      return "ü¶¶"
                  case "Jack Russell terrier":
                      return "üê∂"
                  case _:
                      return "ü™Ñ"


      def principal():
          aluno = obter_aluno()
          print("Expecto Patronum!")
          print(aluno.encanto())


      def obter_aluno():
          nome = input("Nome: ")
          casa = input("Casa: ")
          patronus = input("Patronus: ") or None
          return Aluno(nome, casa, patronus)


      if __name__ == "__main__":
          principal()

  Observe como definimos nosso pr√≥prio m√©todo `encanto`. Ao contr√°rio de dicion√°rios, classes podem ter fun√ß√µes integradas chamadas m√©todos. Neste caso, definimos nosso m√©todo `encanto` onde casos espec√≠ficos t√™m resultados espec√≠ficos. Al√©m disso, observe que o Python tem a capacidade de usar emojis diretamente em nosso c√≥digo.

- Antes de prosseguir, vamos remover nosso c√≥digo do patronus. Modifique seu c√≥digo da seguinte forma:

      class Aluno:
          def __init__(self, nome, casa):
              if not nome:
                  raise ValueError("Nome inv√°lido")
              if casa not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
                  raise ValueError("Casa inv√°lida")
              self.nome = nome
              self.casa = casa

          def __str__(self):
              return f"{self.nome} da casa {self.casa}"


      def principal():
          aluno = obter_aluno()
          aluno.casa = "N√∫mero Quatro, Rua dos Alfeneiros"
          print(aluno)


      def obter_aluno():
          nome = input("Nome: ")
          casa = input("Casa: ")
          return Aluno(nome, casa)


      if __name__ == "__main__":
          principal()

  Observe como temos apenas dois m√©todos: `__init__` e `__str__`.

## Decoradores

- Propriedades podem ser utilizadas para fortalecer nosso c√≥digo. Em Python, definimos propriedades usando "decorators", que come√ßam com `@`. Modifique seu c√≥digo da seguinte forma:

      class Aluno:
          def __init__(self, nome, casa):
              if not nome:
                  raise ValueError("Nome inv√°lido")
              self.nome = nome
              self.casa = casa

          def __str__(self):
              return f"{self.nome} da casa {self.casa}"

          # Getter para casa
          @property
          def casa(self):
              return self._casa

          # Setter para casa
          @casa.setter
          def casa(self, casa):
              if casa not in ["Grifin√≥ria", "Lufa-Lufa", "Corvinal", "Sonserina"]:
                  raise ValueError("Casa inv√°lida")
              self._casa = casa


      def main():
          aluno = pegar_aluno()
          print(aluno)


      def pegar_aluno():
          nome = input("Nome: ")
          casa = input("Casa: ")
          return Aluno(nome, casa)


      if __name__ == "__main__":
          main()

  Note como escrevemos `@property` acima de uma fun√ß√£o chamada `casa`. Fazendo isso, definimos `casa` como uma propriedade da nossa classe. Com `casa` como uma propriedade, ganhamos a capacidade de definir como algum atributo da nossa classe, `_casa`, deve ser configurado e obtido. Na verdade, agora podemos definir uma fun√ß√£o chamada "setter", via `@casa.setter`, que ser√° chamada sempre que a propriedade casa for configurada - por exemplo, com `aluno.casa = "Grifin√≥ria"`. Aqui, fizemos nosso setter validar os valores de `casa` para n√≥s. Note como lan√ßamos um `ValueError` se o valor de `casa` n√£o for nenhuma das casas de Harry Potter, caso contr√°rio, usaremos `casa` para atualizar o valor de `_casa`. Por que `_casa` e n√£o `casa`? `casa` √© uma propriedade da nossa classe, com fun√ß√µes por meio das quais um usu√°rio tenta configurar o atributo da nossa classe. `_casa` √© esse pr√≥prio atributo da classe. O sublinhado inicial, `_`, indica aos usu√°rios que eles n√£o precisam (e na verdade, n√£o devem!) modificar esse valor diretamente. `_casa` deve ser _apenas_ configurado por meio do setter `casa`. Observe como a propriedade `casa` simplesmente retorna o valor de `_casa`, nosso atributo da classe que presumivelmente foi validado usando nosso setter `casa`. Quando um usu√°rio chama `aluno.casa`, eles est√£o obtendo o valor de `_casa` por meio do nosso "getter" `casa`.

- Al√©m do nome da casa, tamb√©m podemos proteger o nome do nosso aluno. Modifique seu c√≥digo da seguinte forma:

      class Aluno:
          def __init__(self, nome, casa):
              self.nome = nome
              self.casa = casa

          def __str__(self):
              return f"{self.nome} da casa {self.casa}"

          # Getter para nome
          @property
          def nome(self):
              return self._nome

          # Setter para nome
          @nome.setter
          def nome(self, nome):
              if not nome:
                  raise ValueError("Nome inv√°lido")
              self._nome = nome

          @property
          def casa(self):
              return self._casa

          @casa.setter
          def casa(self, casa):
              if casa not in ["Grifin√≥ria", "Lufa-Lufa", "Corvinal", "Sonserina"]:
                  raise ValueError("Casa inv√°lida")
              self._casa = casa


      def main():
          aluno = pegar_aluno()
          print(aluno)


      def pegar_aluno():
          nome = input("Nome: ")
          casa = input("Casa: ")
          return Aluno(nome, casa)


      if __name__ == "__main__":
          main()

  Note como, assim como no c√≥digo anterior, fornecemos um getter e um setter para o nome.

- Voc√™ pode aprender mais na documenta√ß√£o do Python sobre [m√©todos](https://docs.python.org/3/tutorial/classes.html).

## Conectando com Trabalhos Anteriores neste Curso

- Embora n√£o seja explicitamente declarado nas se√ß√µes anteriores deste curso, voc√™ vem utilizando classes e objetos o tempo todo.
- Se voc√™ examinar a documenta√ß√£o de `int`, voc√™ ver√° que ela √© uma classe com um construtor. √â um modelo para criar objetos do tipo `int`. Voc√™ pode aprender mais na documenta√ß√£o do Python para [`int`](https://docs.python.org/3/library/functions.html#int).
- As strings tamb√©m s√£o uma classe. Se voc√™ utilizou o `str.lower()`, voc√™ estava utilizando um m√©todo que faz parte da classe `str`. Voc√™ pode aprender mais na documenta√ß√£o do Python para [`str`](https://docs.python.org/3/library/stdtypes.html#str).
- `list` tamb√©m √© uma classe. Olhando a documenta√ß√£o para `list`, voc√™ pode ver os m√©todos que est√£o contidos nela, como `list.append()`. Voc√™ pode aprender mais na documenta√ß√£o do Python para [`list`](https://docs.python.org/3/library/stdtypes.html#list).
- `dict` tamb√©m √© uma classe do Python. Voc√™ pode aprender mais na documenta√ß√£o do Python para [`dict`](https://docs.python.org/3/library/stdtypes.html#dict).
- Para ver como voc√™ vem utilizando classes o tempo todo, v√° para o seu console e digite `code type.py` e ent√£o o c√≥digo a seguir:

      print(type(50))

  Observe como, ao executar esse c√≥digo, ele ir√° exibir que a classe de `50` √© `int`.

- Tamb√©m podemos aplicar isso para `str` da seguinte forma:

      print(type("ol√°, mundo"))

  Observe como a execu√ß√£o desse c√≥digo indicar√° que isso √© da classe `str`.

- Tamb√©m podemos aplicar isso para `list` da seguinte forma:

      print(type([]))

  Observe como a execu√ß√£o desse c√≥digo indicar√° que isso √© da classe `list`.

- Tamb√©m podemos aplicar isso para `list` usando o nome da classe embutida do Python `list` da seguinte forma:

      print(type(list()))

  Observe como a execu√ß√£o desse c√≥digo indicar√° que isso √© da classe `list`.

- Tamb√©m podemos aplicar isso para `dict` da seguinte forma:

      print(type({}))

  Observe como a execu√ß√£o desse c√≥digo indicar√° que isso √© da classe `dict`.

- Tamb√©m podemos aplicar isso para `dict` usando o nome da classe embutida do Python `dict` da seguinte forma:

      print(type(dict()))

  Observe como a execu√ß√£o desse c√≥digo indicar√° que isso √© da classe `dict`.

## M√©todos de Classe

- √Äs vezes, queremos adicionar funcionalidade a uma classe em si, n√£o a inst√¢ncias dessa classe.
- `@classmethod` √© uma fun√ß√£o que podemos usar para adicionar funcionalidade a uma classe como um todo.
- Aqui est√° um exemplo de _n√£o_ uso de um m√©todo de classe. Na janela do seu terminal, digite `code hat.py` e insira o seguinte c√≥digo:

      import random


      class Hat:
          def __init__(self):
              self.houses = ["Grifin√≥ria", "Lufa-Lufa", "Corvinal", "Sonserina"]

          def sort(self, name):
              print(name, "est√° em", random.choice(self.houses))


      hat = Hat()
      hat.sort("Harry")

  Observe como, quando passamos o nome do aluno para o chap√©u seletor, ele nos dir√° a qual casa o aluno foi designado. Observe que `hat = Hat()` inst√¢ncia um `hat`. A funcionalidade `sort` √© sempre tratada pela _inst√¢ncia_ da classe `Hat`. Ao executar `hat.sort("Harry")`, passamos o nome do aluno para o m√©todo `sort` da inst√¢ncia particular de `Hat`, que chamamos de `hat`.

- No entanto, podemos querer executar a fun√ß√£o `sort` sem criar uma inst√¢ncia espec√≠fica do chap√©u seletor (afinal, h√° apenas um!). Podemos modificar nosso c√≥digo da seguinte forma:

      import random


      class Hat:

          houses = ["Grifin√≥ria", "Lufa-Lufa", "Corvinal", "Sonserina"]

          @classmethod
          def sort(cls, name):
              print(name, "est√° em", random.choice(cls.houses))


      Hat.sort("Harry")

  Observe como o m√©todo `__init__` √© removido porque n√£o precisamos instanciar um chap√©u em nenhum lugar do c√≥digo. Portanto, `self` n√£o √© mais relevante e √© removido. Especificamos esse `sort` como um `@classmethod`, substituindo `self` por `cls`. Finalmente, observe como `Hat` √© escrito em mai√∫sculas por conven√ß√£o perto do final deste c√≥digo, pois esse √© o nome da nossa classe.

- Voltando para o arquivo `students.py`, podemos modificar nosso c√≥digo da seguinte forma, abordando algumas oportunidades perdidas relacionadas aos `@classmethod`s:

      class Student:
          def __init__(self, name, house):
              self.name = name
              self.house = house

          def __str__(self):
              return f"{self.name} da casa {self.house}"

          @classmethod
          def get(cls):
              name = input("Nome: ")
              house = input("Casa: ")
              return cls(name, house)


      def main():
          student = Student.get()
          print(student)


      if __name__ == "__main__":
          main()

  Observe que `get_student` √© removido e um `@classmethod` chamado `get` √© criado. Agora, esse m√©todo pode ser chamado sem precisar criar um aluno primeiro.

## M√©todos Est√°ticos

- Acontece que, al√©m dos `@classmethod`s, que s√£o distintos dos m√©todos de inst√¢ncia, existem outros tipos de m√©todos tamb√©m.
- Usar `@staticmethod` pode ser algo que voc√™ pode desejar explorar. Embora n√£o seja abordado explicitamente neste curso, voc√™ est√° convidado a buscar e aprender mais sobre m√©todos est√°ticos e a diferen√ßa deles em rela√ß√£o aos m√©todos de classe.

## Heran√ßa

- A heran√ßa √©, talvez, o recurso mais poderoso da programa√ß√£o orientada a objetos.
- Acontece que voc√™ pode criar uma classe que "herda" m√©todos, vari√°veis ‚Äã‚Äãe atributos de outra classe.
- No terminal, execute `code wizard.py`. O c√≥digo √© o seguinte:

      class Mago:
          def __init__(self, nome):
              if not nome:
                  raise ValueError("Nome faltando")
              self.nome = nome

          ...


      class Estudante(Mago):
          def __init__(self, nome, casa):
              super().__init__(nome)
              self.casa = casa

          ...


      class Professor(Mago):
          def __init__(self, nome, mat√©ria):
              super().__init__(nome)
              self.mat√©ria = mat√©ria

          ...


      mago = Mago("Albus")
      estudante = Estudante("Harry", "Gryffindor")
      professor = Professor("Severus", "Defesa Contra as Artes das Trevas")
      ...

  Observe que h√° uma classe acima chamada `Mago` e uma classe chamada `Estudante`. Al√©m disso, observe que h√° uma classe chamada `Professor`. Ambos os estudantes e professores t√™m nomes. Al√©m disso, tanto estudantes quanto professores s√£o magos. Portanto, tanto `Estudante` quanto `Professor` herdam as caracter√≠sticas de `Mago`. Dentro da classe "filha" `Estudante`, `Estudante` pode herdar da classe "pai" ou "super" `Mago`, pois a linha `super().__init__(nome)` executa o m√©todo `init` de `Mago`. Por fim, observe que as √∫ltimas linhas deste c√≥digo criam um mago chamado Albus, um estudante chamado Harry, e assim por diante.

## Heran√ßa e Exce√ß√µes

- Embora tenhamos acabado de introduzir a heran√ßa, temos usado isso o tempo todo durante o uso de exce√ß√µes.
- Acontece tamb√©m que as exce√ß√µes seguem uma hierarquia, onde existem classes filhas, pais e av√≥s. Isso √© ilustrado abaixo:

      BaseException
       +-- KeyboardInterrupt
       +-- Exception
            +-- ArithmeticError
            |    +-- ZeroDivisionError
            +-- AssertionError
            +-- AttributeError
            +-- EOFError
            +-- ImportError
            |    +-- ModuleNotFoundError
            +-- LookupError
            |    +-- KeyError
            +-- NameError
            +-- SyntaxError
            |    +-- IndentationError
            +-- ValueError
       ...

- Voc√™ pode aprender mais na documenta√ß√£o do Python sobre [exce√ß√µes](https://docs.python.org/3/library/exceptions.html).

## Sobrecarga de Operadores

- Alguns operadores, como `+` e `-`, podem ser "sobrecarregados" de forma que eles possam ter mais habilidades al√©m da simples aritm√©tica.
- Na janela do seu terminal, digite `code vault.py`. Em seguida, codifique da seguinte forma:

      class Vault:
          def __init__(self, gale√µes=0, sicles=0, nuques=0):
              self.gale√µes = gale√µes
              self.sicles = sicles
              self.nuques = nuques

          def __str__(self):
              return f"{self.gale√µes} Gale√µes, {self.sicles} Sicles, {self.nuques} Nuques"

          def __add__(self, other):
              gale√µes = self.gale√µes + other.gale√µes
              sicles = self.sicles + other.sicles
              nuques = self.nuques + other.nuques
              return Vault(gale√µes, sicles, nuques)


      potter = Vault(100, 50, 25)
      print(potter)

      weasley = Vault(25, 50, 100)
      print(weasley)

      total = potter + weasley
      print(total)

  Observe como o m√©todo `__str__` retorna uma string formatada. Al√©m disso, observe como o m√©todo `__add__` permite a adi√ß√£o dos valores de dois cofres. `self` √© o que est√° √† esquerda do operando `+`. `other` √© o que est√° √† direita do `+`.

- Voc√™ pode aprender mais na documenta√ß√£o do Python sobre [sobrecarga de operadores](https://docs.python.org/3/reference/datamodel.html#special-method-names).

## Resumindo

Agora, voc√™ aprendeu um novo n√≠vel de capacidade atrav√©s da programa√ß√£o orientada a objetos.

- Programa√ß√£o orientada a objetos
- Classes
- `raise`
- M√©todos de classe
- M√©todos est√°ticos
- Heran√ßa
- Sobrecarga de operadores