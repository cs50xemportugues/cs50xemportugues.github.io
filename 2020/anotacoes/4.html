<!DOCTYPE html>
<!-- saved from url=(0037)https://cs50.harvard.edu/summer/2020/ -->
<html lang="en-us"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta property="og:description" content="Introdu√ß√£o √†s faculdades intelectuais da ci√™ncia da computa√ß√£o e a arte da programa√ß√£o. Este curso ensina aos estudantes a como pensar algoritmicamente e a como resulver problemas eficientemente. Os t√≥picos incluem abstra√ß√£o, algoritmos, estruturas de dados, encapsula√ß√£o, gerenciamento de recursos, seguran√ßa, e engenharia de software. O curso inclui as linguagens C, Python, e SQL, assim como HTML, CSS, e JavaScript. As listas de problemas s√£o inspiradas pelas √°reas das artes, humanas, ci√™ncias sociais, e ci·∫Ωncias naturais. O curso cultina em um projeto final.">

<meta property="og:image" content=""><meta property="og:title" content="CS50"><link href="https://cs50.harvard.edu/summer/2020/favicon.ico?1593528821" rel="icon">

<!-- https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use -->
<script src="https://kit.fontawesome.com/df44463090.js" crossorigin="anonymous"></script>
<link href="../arquivos/all.min.css" rel="stylesheet">

<link href="../arquivos/page.css" rel="stylesheet">

<link rel="stylesheet" type="text/css" href="../arquivos/personalizado.css">

<!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
<script src="../arquivos/jquery.min.js"></script>
<script src="../arquivos/popper.min.js"></script>
<script src="../arquivos/bootstrap.min.js"></script>

<!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
<script src="../arquivos/moment.min.js"></script>
<script src="../arquivos/moment-timezone-with-data.min.js"></script>
<script src="../arquivos/luxon.min.js"></script>

<!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
<script src="../arquivos/algoliasearchLite.min.js"></script>
<script src="../arquivos/instantsearch.production.min.js"></script>

<script src="../arquivos/jekyll-theme-cs50.js"></script>

<title>Aula 4 - CS50x em Portugu√™s</title>
</head>

    <body>

        

        <div class="container-fluid">

            <div class="row">

                <aside class="col-md">
 
                    <header><h1 data-id="this-is-cs50"><a href="https://cs50xemportugues.github.io/">Este √© o CS50x</a></h1>

<p><a href="https://cs50.harvard.edu/">O curso da Universidade de Harvard em Portugu√™s!</a><br>
2020</p></header>

                    <button aria-controls="nav" aria-expanded="false" class="btn btn-sm collapsed d-md-none" data-target="aside &gt; nav" data-toggle="collapse">
                        Menu
                    </button>

                    <nav class="collapse d-md-block" id="nav"><hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/0">Semana 0</a> Scratch <strong class="text-white">üò∫</strong></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/1">Semana 1</a> Linguagem C</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/2">Semana 2</a> Vetores</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/3">Semana 3</a> Algoritmos</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/4">Semana 4</a> Mem√≥ria <strong class="text-white">üß†</strong></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/5">Semana 5</a> Estruturas de Dados</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/6">Semana 6</a> Python <strong class="text-white">üêç</strong></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/7">Semana 7</a> SQL</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../semanas/8">Semana 8</a> Informa√ß√£o</li>
</ul>
                        
<ul>
  <li data-marker="*"><a href="../especializacoes">Especializa√ß√µes</a></li>
  <li data-marker="*"><a href="../projetofinal">Projeto Final</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../guia.pdf">Guia R√°pido de Inicializa√ß√£o</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../perguntasfrequentes">Perguntas Frequentes</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../atendimento">Atendimento aos Alunos</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../problemas">Listas de Problemas</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../secoes">Se√ß√µes</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../equipe">Equipe</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../curriculo">Curr√≠culo do Curso</a></li>
</ul>

<hr>

<ul class="small fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://ide.cs50.io/">CS50 IDE</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://sqlitebrowser.org/">Navegador de Banco de Dados para o SQLite</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://man.cs50.io/">Manual CS50</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://docs.python.org/3.7/search.html">Documenta√ß√£o Python</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://stackoverflow.com/search">Stack Overflow</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="../guiadeestilo">Guia de Estilo</a></li>
</ul>

<hr>

<p style="font-size: initial"><a href="../obrigado">Agradecemos</a> √† todos os ex-alunos e amigos do CS50</p></nav>

                    <footer></footer>

                </aside>

                <main class="col-md markdown-body" style="margin-bottom: 286px;">
                  
<h1 class="no_toc" id="lecture-4">Lecture 4</h1>

<ul id="markdown-toc">
  <li><a href="#hexadecimal" id="markdown-toc-hexadecimal">Hexadecimal</a></li>
  <li><a href="#pointers" id="markdown-toc-pointers">Pointers</a></li>
  <li><a href="#string" id="markdown-toc-string">string</a></li>
  <li><a href="#compare-and-copy" id="markdown-toc-compare-and-copy">Compare and copy</a></li>
  <li><a href="#valgrind" id="markdown-toc-valgrind">valgrind</a></li>
  <li><a href="#swap" id="markdown-toc-swap">Swap</a></li>
  <li><a href="#memory-layout" id="markdown-toc-memory-layout">Memory layout</a></li>
  <li><a href="#get_int" id="markdown-toc-get_int">get_int</a></li>
  <li><a href="#files" id="markdown-toc-files">Files</a></li>
  <li><a href="#jpeg" id="markdown-toc-jpeg">JPEG</a></li>
</ul>

<h2 id="hexadecimal">Hexadecimal</h2>

<ul>
  <li data-marker="*">In week 0, we learned binary, a counting system with 0s and 1s.</li>
  <li data-marker="*">In week 2, we talked about memory and how each byte has an address, or identifier, so we can refer to where our variables are actually stored.</li>
  <li data-marker="*">It turns out that, by convention, the addresses for memory use the counting system <strong>hexadecimal</strong>, where there are 16 digits, 0-9 and A-F.</li>
  <li data-marker="*">Recall that, in binary, each digit stood for a power of 2:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>128 64 32 16  8  4  2  1
  1  1  1  1  1  1  1  1
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">With 8 bits, we can count up to 255.</li>
    </ul>
  </li>
  <li data-marker="*">It turns out that, in hexadecimal, we can perfectly count up to 8 binary bits with just 2 digits:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>16^1 16^0
   F    F
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Here, the <code class="highlighter-rouge">F</code> is a value of 15 in decimal, and each place is a power of 16, so the first <code class="highlighter-rouge">F</code> is 16^1 * 15 = 240, plus the second <code class="highlighter-rouge">F</code> with the value of 16^0 * 15 = 15, for a total of 255.</li>
    </ul>
  </li>
  <li data-marker="*">And <code class="highlighter-rouge">0A</code> is the same as 10 in decimal, and <code class="highlighter-rouge">0F</code> the same as 15. <code class="highlighter-rouge">10</code> in hexadecimal would be 16, and we would say it as ‚Äúone zero in hexadecimal‚Äù instead of ‚Äúten‚Äù, if we wanted to avoid confusion.</li>
  <li data-marker="*">The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, <code class="highlighter-rouge">000000</code> in hexadecimal means 0 of each red, green, and blue, for a color of black. And <code class="highlighter-rouge">FF0000</code> would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors.</li>
  <li data-marker="*">In writing, we can also indicate a value is in hexadecimal by prefixing it with <code class="highlighter-rouge">0x</code>, as in <code class="highlighter-rouge">0x10</code>, where the value is equal to 16 in decimal, as opposed to 10.</li>
</ul>

<h2 id="pointers">Pointers</h2>

<ul>
  <li data-marker="*">We might create a value <code class="highlighter-rouge">n</code>, and print it out:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">In our computer‚Äôs memory, there are now 4 bytes somewhere that have the binary value of 50, labeled <code class="highlighter-rouge">n</code>:<br>
<img src="n.png" alt="grid representing bytes, with four boxes together containing 50 with small n underneath"></li>
  <li data-marker="*">It turns out that, with the billions of bytes in memory, those bytes for the variable <code class="highlighter-rouge">n</code> starts at some unique address that might look like <code class="highlighter-rouge">0x12345678</code>.</li>
  <li data-marker="*">In C, we can actually see the address with the <code class="highlighter-rouge">&amp;</code> operator, which means ‚Äúget the address of this variable‚Äù:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">And in the CS50 IDE, we might see an address like <code class="highlighter-rouge">0x7ffe00b3adbc</code>, where this is a specific location in the server‚Äôs memory.</li>
    </ul>
  </li>
  <li data-marker="*">The address of a variable is called a <strong>pointer</strong>, which we can think of as a value that ‚Äúpoints‚Äù to a location in memory. The <code class="highlighter-rouge">*</code> operator lets us ‚Äúgo to‚Äù the location that a pointer is pointing to.</li>
  <li data-marker="*">For example, we can print <code class="highlighter-rouge">*&amp;n</code>, where we ‚Äúgo to‚Äù the address of <code class="highlighter-rouge">n</code>, and that will print out the value of <code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">50</code>, since that‚Äôs the value at the address of <code class="highlighter-rouge">n</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">We also have to use the <code class="highlighter-rouge">*</code> operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Here, we use <code class="highlighter-rouge">int *p</code> to declare a variable, <code class="highlighter-rouge">p</code>, that has the type of <code class="highlighter-rouge">*</code>, a pointer, to a value of type <code class="highlighter-rouge">int</code>, an integer. Then, we can print its value (something like <code class="highlighter-rouge">0x12345678</code>), or print the value at its location with <code class="highlighter-rouge">printf("%i\n", *p);</code>.</li>
    </ul>
  </li>
  <li data-marker="*">In our computer‚Äôs memory, the variables might look like this:<br>
<img src="p.png" alt="grid representing bytes, with four boxes together containing 50 with small 0x12345678 underneath, and eight boxes together containing 0x12345678 with small p underneath">
    <ul>
      <li data-marker="*">We have a pointer, <code class="highlighter-rouge">p</code>, with the address of some variable.</li>
    </ul>
  </li>
  <li data-marker="*">We can abstract away the actual value of the addresses now, since they‚Äôll be different as we declare variables in our programs, and simply think of <code class="highlighter-rouge">p</code> as ‚Äúpointing at‚Äù some value:<br>
<img src="pointing.png" alt="one box containing p pointing at smaller box containing 50"></li>
  <li data-marker="*">Let‚Äôs say we have a mailbox labeled ‚Äú123‚Äù, with the number ‚Äú50‚Äù inside it. The mailbox would be <code class="highlighter-rouge">int n</code>, since it stores an integer. We might have another mailbox with the address ‚Äú456‚Äù, inside of which is the value ‚Äú123‚Äù, which is the address of our other mailbox. This would be <code class="highlighter-rouge">int *p</code>, since it‚Äôs a pointer to an integer.</li>
  <li data-marker="*">With the ability to use pointers, we can create different data structures, or different ways to organize data in memory that we‚Äôll see next week.</li>
  <li data-marker="*">Many modern computer systems are ‚Äú64-bit‚Äù, meaning that they use 64 bits to address memory, so a pointer will be 8 bytes, twice as big as an integer of 4 bytes.</li>
</ul>

<h2 id="string">string</h2>

<ul>
  <li data-marker="*">We might have a variable <code class="highlighter-rouge">string s</code> for a name like <code class="highlighter-rouge">EMMA</code>, and be able to access each character with <code class="highlighter-rouge">s[0]</code> and so on:<br>
<img src="s_array.png" alt="boxes side by side, containing: E labeled s[0], M labeled s[1], M labeled s[2], A labeled s[3], \0 labeled s[4]"></li>
  <li data-marker="*">But it turns out that each character is stored in memory at a byte with some address, and <code class="highlighter-rouge">s</code> is actually just a pointer with the address of the first character:<br>
<img src="s_pointer.png" alt="box containing 0x123 labeled s, boxes side by side containing E labeled 0x123, M labeled 0x124, M labeled 0x125, A labeled 0x126, \0 labeled 0x127"></li>
  <li data-marker="*">And since <code class="highlighter-rouge">s</code> is just a pointer to the beginning, only the <code class="highlighter-rouge">\0</code> indicates the end of the string.</li>
  <li data-marker="*">In fact, the CS50 Library defines a <code class="highlighter-rouge">string</code> with <code class="highlighter-rouge">typedef char *string</code>, which just says that we want to name a new type, <code class="highlighter-rouge">string</code>, as a <code class="highlighter-rouge">char *</code>, or a pointer to a character.</li>
  <li data-marker="*">Let‚Äôs print out a string:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"EMMA"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*">This is familiar, but we can just say:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"EMMA"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">This will also print <code class="highlighter-rouge">EMMA</code>.</li>
    </ul>
  </li>
  <li data-marker="*">With <code class="highlighter-rouge">printf("%p\n", s);</code>, we can print <code class="highlighter-rouge">s</code> as its value as a pointer, like <code class="highlighter-rouge">0x42ab52</code>. (<code class="highlighter-rouge">printf</code> knows to go to the address and print the entire string when we use <code class="highlighter-rouge">%s</code> and pass in <code class="highlighter-rouge">s</code>, even though <code class="highlighter-rouge">s</code> only points to the first character.)</li>
  <li data-marker="*">We can also try <code class="highlighter-rouge">printf("%p\n", &amp;s[0]);</code>, which is the address of the first character of <code class="highlighter-rouge">s</code>, and it‚Äôs exactly the same as printing <code class="highlighter-rouge">s</code>. And printing <code class="highlighter-rouge">&amp;s[1]</code>, <code class="highlighter-rouge">&amp;s[2]</code>, and <code class="highlighter-rouge">&amp;s[3]</code> gets us the addresses that are the next characters in memory after <code class="highlighter-rouge">&amp;s[0]</code>, like <code class="highlighter-rouge">0x42ab53</code>, <code class="highlighter-rouge">0x42ab54</code>, and <code class="highlighter-rouge">0x42ab55</code>, exactly one byte after another.</li>
  <li data-marker="*">And finally, if we try to <code class="highlighter-rouge">printf("%c\n", *s);</code>, we get a single character <code class="highlighter-rouge">E</code>, since we‚Äôre going to the address contained in <code class="highlighter-rouge">s</code>, which has the first character in the string.</li>
  <li data-marker="*">In fact, <code class="highlighter-rouge">s[0]</code>, <code class="highlighter-rouge">s[1]</code>, and <code class="highlighter-rouge">s[2]</code> actually map directly to <code class="highlighter-rouge">*s</code>, <code class="highlighter-rouge">*(s+1)</code>, and <code class="highlighter-rouge">*(s+2)</code>, since each of the next characters are just at the address of the next byte.</li>
</ul>

<h2 id="compare-and-copy">Compare and copy</h2>

<ul>
  <li data-marker="*">Let‚Äôs look at <code class="highlighter-rouge">compare0</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get two integers</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"i: "</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"j: "</span><span class="p">);</span>

    <span class="c1">// Compare integers</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Same</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Different</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We can compile and run this, and our program works as we‚Äôd expect, with the same values of the two integers giving us ‚ÄúSame‚Äù and different values ‚ÄúDifferent‚Äù.</li>
    </ul>
  </li>
  <li data-marker="*">In <code class="highlighter-rouge">compare1</code>, we see that the same string values are causing our program to print ‚ÄúDifferent‚Äù:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get two strings</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"t: "</span><span class="p">);</span>

    <span class="c1">// Compare strings' addresses</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Same</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Different</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Given what we now know about strings, this makes sense because each ‚Äústring‚Äù variable is pointing to a different location in memory, where the first character of each string is stored. So even if the values of the strings are the same, this will always print ‚ÄúDifferent‚Äù.</li>
      <li data-marker="*">For example, our first string might be at address 0x123, our second might be at 0x456, and <code class="highlighter-rouge">s</code> will be <code class="highlighter-rouge">0x123</code> and <code class="highlighter-rouge">t</code> will be <code class="highlighter-rouge">0x456</code>, so those values will be different.</li>
      <li data-marker="*">And <code class="highlighter-rouge">get_string</code>, this whole time, has been returning just a <code class="highlighter-rouge">char *</code>, or a pointer to the first character of a string from the user.</li>
    </ul>
  </li>
  <li data-marker="*">Now let‚Äôs try to copy a string:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>

    <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// Print string twice</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"t: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We get a string <code class="highlighter-rouge">s</code>, and copy the value of <code class="highlighter-rouge">s</code> into <code class="highlighter-rouge">t</code>. Then, we capitalize the first letter in <code class="highlighter-rouge">t</code>.</li>
      <li data-marker="*">But when we run our program, we see that both <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">t</code> are now capitalized.</li>
      <li data-marker="*">Since we set <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">t</code> to the same values, they‚Äôre actually pointers to the same character, and so we capitalized the same character!</li>
    </ul>
  </li>
  <li data-marker="*">To actually make a copy of a string, we have to do a little more work:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"t: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">We create a new variable, <code class="highlighter-rouge">t</code>, of the type <code class="highlighter-rouge">char *</code>, with <code class="highlighter-rouge">char *t</code>. Now, we want to point it to a new chunk of memory that‚Äôs large enough to store the copy of the string. With <code class="highlighter-rouge">malloc</code>, we can allocate some number of bytes in memory (that aren‚Äôt already used to store other values), and we pass in the number of bytes we‚Äôd like. We already know the length of <code class="highlighter-rouge">s</code>, so we add 1 to that for the terminating null character. So, our final line of code is <code class="highlighter-rouge">char *t = malloc(strlen(s) + 1);</code>.</li>
      <li data-marker="*">Then, we copy each character, one at a time, and now we can capitalize just the first letter of <code class="highlighter-rouge">t</code>. And we use <code class="highlighter-rouge">i &lt; n + 1</code>, since we actually want to go up to <code class="highlighter-rouge">n</code>, to ensure we copy the terminating character in the string.</li>
      <li data-marker="*">We can actually also use the <code class="highlighter-rouge">strcpy</code> library function with <code class="highlighter-rouge">strcpy(t, s)</code> instead of our loop, to copy the string <code class="highlighter-rouge">s</code> into <code class="highlighter-rouge">t</code>. To be clear, the concept of a ‚Äústring‚Äù is from the C language and well-supported; the only training wheels from CS50 are the type <code class="highlighter-rouge">string</code> instead of <code class="highlighter-rouge">char *</code>, and the <code class="highlighter-rouge">get_string</code> function.</li>
    </ul>
  </li>
  <li data-marker="*">If we didn‚Äôt copy the null terminating character, <code class="highlighter-rouge">\0</code>, and tried to print out our string <code class="highlighter-rouge">t</code>, <code class="highlighter-rouge">printf</code> will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a <code class="highlighter-rouge">\0</code>, or crashes entirely, since our program might end up trying to read memory that doesn‚Äôt belong to it!</li>
</ul>

<h2 id="valgrind">valgrind</h2>

<ul>
  <li data-marker="*">It turns out that, after we‚Äôre done with memory that we‚Äôve allocated with <code class="highlighter-rouge">malloc</code>, we should call <code class="highlighter-rouge">free</code> (as in <code class="highlighter-rouge">free(t)</code>), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again.</li>
  <li data-marker="*">If we kept running our program and allocating memory with <code class="highlighter-rouge">malloc</code>, but never freed the memory after we were done using it, we would have a <strong>memory leak</strong>, which will slow down our computer and use up more and more memory until our computer runs out.</li>
  <li data-marker="*"><code class="highlighter-rouge">valgrind</code> is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with <code class="highlighter-rouge">help50 valgrind ./copy</code> and see, from the error message, that line 10, we allocated memory that we never freed (or ‚Äúlost‚Äù).</li>
  <li data-marker="*">So at the end, we can add a line <code class="highlighter-rouge">free(t)</code>, which won‚Äôt change how our program runs, but no errors from valgrind.</li>
  <li data-marker="*">Let‚Äôs take a look at <code class="highlighter-rouge">memory.c</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare</span>

<span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">This is an example from valgrind‚Äôs documentation (valgrind is a real tool, while help50 was written specifically to help us in this course).</li>
      <li data-marker="*">The function <code class="highlighter-rouge">f</code> allocates enough memory for 10 integers, and stores the address in a pointer called <code class="highlighter-rouge">x</code>. Then we try to set the 11th value of <code class="highlighter-rouge">x</code> with <code class="highlighter-rouge">x[10]</code> to <code class="highlighter-rouge">0</code>, which goes past the array of memory we‚Äôve allocated for our program. This is called <strong>buffer overflow</strong>, where we go past the boundaries of our buffer, or array, and into unknown memory.</li>
    </ul>
  </li>
  <li data-marker="*">valgrind will also tell us there‚Äôs an ‚ÄúInvalid write of size 4‚Äù for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes).</li>
  <li data-marker="*">And this whole time, the CS50 Library has been freeing memory it‚Äôs allocated in <code class="highlighter-rouge">get_string</code>, when our program finishes!</li>
</ul>

<h2 id="swap">Swap</h2>

<ul>
  <li data-marker="*">We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can‚Äôt do that without a third cup to pour one of the drink into first.</li>
  <li data-marker="*">Now, let‚Äôs say we wanted to swap the values of two integers.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">With a third variable to use as temporary storage space, we can do this pretty easily, by putting <code class="highlighter-rouge">a</code> into <code class="highlighter-rouge">tmp</code>, and then <code class="highlighter-rouge">b</code> to <code class="highlighter-rouge">a</code>, and finally the original value of <code class="highlighter-rouge">a</code>, now in <code class="highlighter-rouge">tmp</code>, into <code class="highlighter-rouge">b</code>.</li>
    </ul>
  </li>
  <li data-marker="*">But, if we tried to use that function in a program, we don‚Äôt see any changes:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">It turns out that the <code class="highlighter-rouge">swap</code> function gets its own variables, <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> when they are passed in, that are copies of <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>, and so changing those values don‚Äôt change <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> in the <code class="highlighter-rouge">main</code> function.</li>
    </ul>
  </li>
</ul>

<h2 id="memory-layout">Memory layout</h2>

<ul>
  <li data-marker="*">Within our computer‚Äôs memory, the different types of data that need to be stored for our program are organized into different sections:<br>
<img src="memory_layout.png" alt="Grid with sections, from top to bottom: machine code, globals, heap (with arrow pointing downward), stack (with arrow pointing upward)">
    <ul>
      <li data-marker="*">The <em>machine code</em> section is our compiled program‚Äôs binary code. When we run our program, that code is loaded into the ‚Äútop‚Äù of memory.</li>
      <li data-marker="*"><em>Globals</em> are global variables we declare in our program or other shared variables that our entire program can access.</li>
      <li data-marker="*">The <em>heap</em> section is an empty area where <code class="highlighter-rouge">malloc</code> can get free memory from, for our program to use.</li>
      <li data-marker="*">The <em>stack</em> section is used by functions in our program as they are called. For example, our <code class="highlighter-rouge">main</code> function is at the very bottom of the stack, and has the local variables <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>. The <code class="highlighter-rouge">swap</code> function, when it‚Äôs called, has its own frame, or slice, of memory that‚Äôs on top of <code class="highlighter-rouge">main</code>‚Äôs, with the local variables <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, and <code class="highlighter-rouge">tmp</code>:<br>
<img src="stack.png" alt="Stack section with (a, b, tmp) above (x, y)">
        <ul>
          <li data-marker="*">Once the function <code class="highlighter-rouge">swap</code> returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called <code class="highlighter-rouge">swap</code>.</li>
          <li data-marker="*">So by passing in the addresses of <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> from <code class="highlighter-rouge">main</code> to <code class="highlighter-rouge">swap</code>, we can actually change the values of <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>:
<img src="pointers.png" alt="Stack section with (a, b, tmp) above (x, y), and a pointing to x and b pointing to y"></li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*">By passing in the address of <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>, our <code class="highlighter-rouge">swap</code> function can actually work:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is %i, y is %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">The addresses of <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are passed in from <code class="highlighter-rouge">main</code> to <code class="highlighter-rouge">swap</code>, and we use the <code class="highlighter-rouge">int *a</code> syntax to declare that our <code class="highlighter-rouge">swap</code> function takes in pointers. We save the value of <code class="highlighter-rouge">x</code> to <code class="highlighter-rouge">tmp</code> by following the pointer <code class="highlighter-rouge">a</code>, and then take the value of <code class="highlighter-rouge">y</code> by following the pointer <code class="highlighter-rouge">b</code>, and store that to the location <code class="highlighter-rouge">a</code> is pointing to (<code class="highlighter-rouge">x</code>). Finally, we store the value of <code class="highlighter-rouge">tmp</code> to the location pointed to by <code class="highlighter-rouge">b</code> (<code class="highlighter-rouge">y</code>), and we‚Äôre done.</li>
    </ul>
  </li>
  <li data-marker="*">If we call <code class="highlighter-rouge">malloc</code> too many times, we will have a <strong>heap overflow</strong>, where we end up going past our heap. Or, if we have too many functions being called, we will have a <strong>stack overflow</strong>, where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash.</li>
</ul>

<h2 id="get_int">get_int</h2>

<ul>
  <li data-marker="*">We can implement <code class="highlighter-rouge">get_int</code> ourselves with a C library function, <code class="highlighter-rouge">scanf</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x: "</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x: %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*"><code class="highlighter-rouge">scanf</code> takes a format, <code class="highlighter-rouge">%i</code>, so the input is ‚Äúscanned‚Äù for that format, and the address in memory where we want that input to go. But <code class="highlighter-rouge">scanf</code> doesn‚Äôt have much error checking, so we might not get an integer.</li>
    </ul>
  </li>
  <li data-marker="*">We can try to get a string the same way:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"s: "</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">But we haven‚Äôt actually allocated any memory for <code class="highlighter-rouge">s</code> (<code class="highlighter-rouge">s</code> is <code class="highlighter-rouge">NULL</code>, or not pointing to anything), so we might want to call <code class="highlighter-rouge">char s[5]</code> to allocate an array of 5 characters for our string. Then, <code class="highlighter-rouge">s</code> will be treated as a pointer in <code class="highlighter-rouge">scanf</code> and <code class="highlighter-rouge">printf</code>.</li>
      <li data-marker="*">Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, <code class="highlighter-rouge">scanf</code> might be trying to write past the end of our array into unknown memory, causing our program to crash.</li>
    </ul>
  </li>
</ul>

<h2 id="files">Files</h2>

<ul>
  <li data-marker="*">With the ability to use pointers, we can also open files:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Open file</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"phonebook.csv"</span><span class="p">,</span> <span class="s">"a"</span><span class="p">);</span>

    <span class="c1">// Get strings from user</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"Name: "</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">number</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">);</span>

    <span class="c1">// Print (write) strings to file</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"%s,%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>

    <span class="c1">// Close file</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*"><code class="highlighter-rouge">fopen</code> is a new function we can use to open a file. It will return a pointer to a new type, <code class="highlighter-rouge">FILE</code>, that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in (<code class="highlighter-rouge">r</code> for read, <code class="highlighter-rouge">w</code> for write, and <code class="highlighter-rouge">a</code> for append, or adding to).</li>
      <li data-marker="*">After we get some strings, we can use <code class="highlighter-rouge">fprintf</code> to print to a file.</li>
      <li data-marker="*">Finally, we close the file with <code class="highlighter-rouge">fclose</code>.</li>
    </ul>
  </li>
  <li data-marker="*">Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically.</li>
</ul>

<h1 id="jpeg">JPEG</h1>

<ul>
  <li data-marker="*">We can also write a program that opens a file and tells us if it‚Äôs a JPEG (image) file:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// Check usage</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Open file</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Read first three bytes</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Check first three bytes</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xd8</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Maybe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"No</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Close file</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Now, if we run this program with <code class="highlighter-rouge">./jpeg brian.jpg</code>, our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with <code class="highlighter-rouge">fread</code>.</li>
      <li data-marker="*">We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they‚Äôre the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they‚Äôre not the same, we know it‚Äôs definitely not a JPEG file.</li>
    </ul>
  </li>
  <li data-marker="*">We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week‚Äôs problem set!</li>
</ul>

                	
               
				</main>

			</div>

		</div>

        <!--
        <div aria-hidden="true" aria-labelledby="searchTitle" class="markdown-body modal" id="search" role="dialog" tabindex="-1">
            <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="pr-3 w-100" id="searchbox"></div>
                        <button class="btn btn-secondary btn-lg" data-dismiss="modal" type="button">Fechar</button>
                    </div>
                    <div class="modal-body">
                        <div id="hits"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
        -->
        
        
<script>

    // Before shwoing searchbox
    $('#search').on('show.bs.modal', function (e) {

        // Client
        const searchClient = algoliasearch('5RYPGI69HZ', '53d709e59d833870a6886f6fcf0b0bfe');
        const search = instantsearch({
            indexName: 'cs50-2020-summer',
            searchClient: searchClient,
            searchFunction: function(helper) { // https://www.algolia.com/doc/guides/building-search-ui/going-further/conditional-display/js/#handling-empty-queries
                const hits = $('#hits');
                if (helper.state.query === '') {
                    hits.hide();
                    return;
                }
                helper.search();
                hits.show();
            }
        });

        // searchBox
        // https://www.algolia.com/doc/api-reference/widgets/search-box/js/
        search.addWidget(
            instantsearch.widgets.searchBox({
                container: '#searchbox',
                cssClasses: {
                    input: 'form-control'
                },
                placeholder: 'Search',
                showLoadingIndicator: false,
                showReset: false,
                showSubmit: false
            })
        );

        // hits
        // https://www.algolia.com/doc/api-reference/widgets/hits/js/
        search.addWidget(
            instantsearch.widgets.hits({
                container: '#hits',
                templates: {
                    item: function(hit) {

                        // url
                        if (window.baseurl) {
                            var url = window.baseurl + hit.url;
                        }
                        else {
                            var url = hit.url;
                        }
                        if (hit.anchor) {
                            url += '#' + hit.anchor;
                        }

                        // title
                        if (hit._highlightResult && hit._highlightResult.headings) {
                            var title = hit._highlightResult.headings[hit._highlightResult.headings.length - 1].value;
                        }
                        else if (hit._highlightResult && hit._highlightResult.title) {
                            var title = hit._highlightResult.title.value;
                        }
                        else if (hit.headings) {
                            var title = hit.headings[hit.headings.length - 1].value;
                        }
                        else if (hit.title) {
                            var title = hit.title;
                        }
                        else {
                            var title = url;
                        }

                        // content
                        if (hit._highlightResult && hit._highlightResult.content) {
                            var content = hit._highlightResult.content.value;
                        }
                        else if (hit._highlightResult && hit._highlightResult.title) {
                            var content = hit._highlightResult.title.value;
                        }
                        else {
                            var content = hit.excerpt_text;
                        }

                        // Template for hit
                        return '<h2 class="font-weight-bold h3 mb-0">' +
                               '<a href="' + url + '">' +
                               title +
                               '</a>' +
                               '</h2>' +
                               '<p class="mb-0">' +
                               '<a class="text-muted" href="' + url + '">' +
                               url +
                               '</a>' +
                               '</p>' +
                               '<p>' + 
                               content +
                               '</p>';
                    }
                }
            })
        );

        // poweredBy
        search.addWidget(
            instantsearch.widgets.poweredBy({
                container: '#search .modal-footer'
            })
        );

        // Let user start searching
        search.start();

        // Resize form
        $(window).trigger('resize');
    });

    // After showing searchbox
    $('#search').on('shown.bs.modal', function (e) {
        $('#searchbox input[type=search]').focus();
    });

</script>
        

</body>
</html>
